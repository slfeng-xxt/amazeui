(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("window"), require("classNames"), require("React"), require("Blueprint.Core"), require("ReactDOM"));
	else if(typeof define === 'function' && define.amd)
		define(["window", "classNames", "React", "Blueprint.Core", "ReactDOM"], factory);
	else if(typeof exports === 'object')
		exports["Docs"] = factory(require("window"), require("classNames"), require("React"), require("Blueprint.Core"), require("ReactDOM"));
	else
		root["Blueprint"] = root["Blueprint"] || {}, root["Blueprint"]["Docs"] = factory(root["window"], root["classNames"], root["React"], root["Blueprint.Core"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_9__, __WEBPACK_EXTERNAL_MODULE_19__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__webpack_require__(1);
	__export(__webpack_require__(2));
	__export(__webpack_require__(6));
	__export(__webpack_require__(23));
	__export(__webpack_require__(25));
	
	//# sourceMappingURL=index.js.map


/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	/**
	 * Starter class for all React example components.
	 * Examples and options are rendered into separate containers.
	 */
	var BaseExample = (function (_super) {
	    tslib_1.__extends(BaseExample, _super);
	    function BaseExample() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    BaseExample.prototype.render = function () {
	        return (React.createElement("div", { className: classNames("docs-example", this.className), "data-example-id": this.props.id },
	            React.createElement("div", { className: "docs-react-example" }, this.renderExample()),
	            React.createElement("div", { className: "docs-react-options" }, this.actuallyRenderOptions())));
	    };
	    /**
	     * Render the example element. Return any valid React node.
	     */
	    BaseExample.prototype.renderExample = function () {
	        return undefined;
	    };
	    /**
	     * Render the options controls. Return a single element for simple mode, or an array of arrays
	     * of elements to generate columns: each array will be its own column. When using array mode,
	     * the inner elements will each need the `key` prop.
	     */
	    BaseExample.prototype.renderOptions = function () {
	        return [];
	    };
	    BaseExample.prototype.actuallyRenderOptions = function () {
	        var options = this.renderOptions();
	        if (Array.isArray(options)) {
	            return options.map(function (column, i) { return React.createElement("div", { className: "docs-react-options-column", key: i }, column); });
	        }
	        else {
	            return options;
	        }
	    };
	    return BaseExample;
	}(React.PureComponent));
	exports.BaseExample = BaseExample;
	/** Event handler that exposes the target element's value as a boolean. */
	function handleBooleanChange(handler) {
	    return function (event) { return handler(event.target.checked); };
	}
	exports.handleBooleanChange = handleBooleanChange;
	/** Event handler that exposes the target element's value as a string. */
	function handleStringChange(handler) {
	    return function (event) { return handler(event.target.value); };
	}
	exports.handleStringChange = handleStringChange;
	/** Event handler that exposes the target element's value as a number. */
	function handleNumberChange(handler) {
	    return handleStringChange(function (value) { return handler(+value); });
	}
	exports.handleNumberChange = handleNumberChange;
	
	//# sourceMappingURL=baseExample.js.map


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0
	
	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.
	
	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global global, define, System, Reflect, Promise */
	var __extends;
	var __assign;
	var __rest;
	var __decorate;
	var __param;
	var __metadata;
	var __awaiter;
	var __generator;
	(function (factory) {
	    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (exports) { factory(createExporter(root, createExporter(exports))); }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    else if (typeof module === "object" && typeof module.exports === "object") {
	        factory(createExporter(root, createExporter(module.exports)));
	    }
	    else {
	        factory(createExporter(root));
	    }
	    function createExporter(exports, previous) {
	        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
	    }
	})
	(function (exporter) {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	
	    __extends = function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	
	    __assign = Object.assign || function (t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	
	    __rest = function (s, e) {
	        var t = {};
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	            t[p] = s[p];
	        if (s != null && typeof Object.getOwnPropertySymbols === "function")
	            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
	                t[p[i]] = s[p[i]];
	        return t;
	    };
	
	    __decorate = function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	
	    __param = function (paramIndex, decorator) {
	        return function (target, key) { decorator(target, key, paramIndex); }
	    };
	
	    __metadata = function (metadataKey, metadataValue) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
	    };
	
	    __awaiter = function (thisArg, _arguments, P, generator) {
	        return new (P || (P = Promise))(function (resolve, reject) {
	            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	            step((generator = generator.apply(thisArg, _arguments || [])).next());
	        });
	    };
	
	    __generator = function (thisArg, body) {
	        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
	        return { next: verb(0), "throw": verb(1), "return": verb(2) };
	        function verb(n) { return function (v) { return step([n, v]); }; }
	        function step(op) {
	            if (f) throw new TypeError("Generator is already executing.");
	            while (_) try {
	                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
	                if (y = 0, t) op = [0, t.value];
	                switch (op[0]) {
	                    case 0: case 1: t = op; break;
	                    case 4: _.label++; return { value: op[1], done: false };
	                    case 5: _.label++; y = op[1]; op = [0]; continue;
	                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                    default:
	                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                        if (t[2]) _.ops.pop();
	                        _.trys.pop(); continue;
	                }
	                op = body.call(thisArg, _);
	            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	        }
	    };
	
	    exporter("__extends", __extends);
	    exporter("__assign", __assign);
	    exporter("__rest", __rest);
	    exporter("__decorate", __decorate);
	    exporter("__param", __param);
	    exporter("__metadata", __metadata);
	    exporter("__awaiter", __awaiter);
	    exporter("__generator", __generator);
	});
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_5__;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var client_1 = __webpack_require__(7);
	var React = __webpack_require__(5);
	var core_1 = __webpack_require__(9);
	var utils_1 = __webpack_require__(10);
	var navigator_1 = __webpack_require__(11);
	var navMenu_1 = __webpack_require__(20);
	var page_1 = __webpack_require__(21);
	var Documentation = (function (_super) {
	    tslib_1.__extends(Documentation, _super);
	    function Documentation(props) {
	        var _this = _super.call(this, props) || this;
	        _this.refHandlers = {
	            content: function (ref) { return _this.contentElement = ref; },
	            nav: function (ref) { return _this.navElement = ref; },
	        };
	        _this.handleNavigation = function (activeSectionId) {
	            // only update state if this section reference is valid
	            var activePageId = _this.routeToPage[activeSectionId];
	            if (activeSectionId !== undefined && activePageId !== undefined) {
	                _this.setState({ activePageId: activePageId, activeSectionId: activeSectionId });
	            }
	        };
	        _this.handleNextSection = function () { return _this.shiftSection(1); };
	        _this.handlePreviousSection = function () { return _this.shiftSection(-1); };
	        _this.handleScroll = function () {
	            var activeSectionId = getScrolledReference(100, _this.contentElement);
	            if (activeSectionId == null) {
	                return;
	            }
	            // use the longer (deeper) name to avoid jumping up between sections
	            _this.setState(tslib_1.__assign({}, _this.state, { activeSectionId: activeSectionId }));
	        };
	        _this.state = {
	            activePageId: props.defaultPageId,
	            activeSectionId: props.defaultPageId,
	        };
	        // build up static map of all references to their page, for navigation / routing
	        _this.routeToPage = {};
	        utils_1.eachLayoutNode(_this.props.docs.nav, function (node, parents) {
	            var reference = (client_1.isPageNode(node) ? node : parents[0]).reference;
	            _this.routeToPage[node.route] = reference;
	        });
	        return _this;
	    }
	    Documentation.prototype.render = function () {
	        var _a = this.state, activePageId = _a.activePageId, activeSectionId = _a.activeSectionId;
	        var _b = this.props.docs, nav = _b.nav, pages = _b.pages;
	        return (React.createElement("div", { className: classNames("docs-root", this.props.className) },
	            React.createElement("div", { className: "docs-app" },
	                React.createElement("div", { className: "pt-navbar docs-navbar docs-flex-row" },
	                    React.createElement("div", { className: "pt-navbar-group" }, this.props.navbarLeft),
	                    React.createElement("div", { className: "pt-navbar-group" },
	                        React.createElement(navigator_1.Navigator, { items: nav, onNavigate: this.handleNavigation })),
	                    React.createElement("div", { className: "pt-navbar-group" }, this.props.navbarRight)),
	                React.createElement("div", { className: "docs-nav", ref: this.refHandlers.nav },
	                    React.createElement(navMenu_1.NavMenu, { items: nav, activePageId: activePageId, activeSectionId: activeSectionId, onItemClick: this.handleNavigation })),
	                React.createElement("article", { className: "docs-content", ref: this.refHandlers.content, role: "main" },
	                    React.createElement(page_1.Page, { page: pages[activePageId], tagRenderers: this.props.tagRenderers })))));
	    };
	    Documentation.prototype.renderHotkeys = function () {
	        return (React.createElement(core_1.Hotkeys, null,
	            React.createElement(core_1.Hotkey, { global: true, combo: "[", label: "Previous section", onKeyDown: this.handlePreviousSection }),
	            React.createElement(core_1.Hotkey, { global: true, combo: "]", label: "Next section", onKeyDown: this.handleNextSection })));
	    };
	    Documentation.prototype.componentWillMount = function () {
	        this.updateHash();
	    };
	    Documentation.prototype.componentDidMount = function () {
	        var _this = this;
	        // hooray! so you don't have to!
	        core_1.FocusStyleManager.onlyShowFocusOnTabs();
	        this.scrollToActiveSection();
	        this.maybeScrollToActivePageMenuItem();
	        core_1.Utils.safeInvoke(this.props.onComponentUpdate, this.state.activePageId);
	        // whoa handling future history...
	        window.addEventListener("hashchange", function () {
	            if (location.hostname.indexOf("blueprint") !== -1) {
	                // captures a pageview for new location hashes that are dynamically rendered without a full page request
	                window.ga("send", "pageview", { page: location.pathname + location.search + location.hash });
	            }
	            // Don't call componentWillMount since the HotkeysTarget decorator will be invoked on every hashchange.
	            _this.updateHash();
	        });
	        document.addEventListener("scroll", this.handleScroll);
	    };
	    Documentation.prototype.componentWillUnmount = function () {
	        window.removeEventListener("hashchange");
	        document.removeEventListener("scroll", this.handleScroll);
	    };
	    Documentation.prototype.componentDidUpdate = function (_prevProps, prevState) {
	        var activePageId = this.state.activePageId;
	        // only scroll to heading when switching pages, but always check if nav item needs scrolling.
	        if (prevState.activePageId !== activePageId) {
	            this.scrollToActiveSection();
	            this.maybeScrollToActivePageMenuItem();
	        }
	        core_1.Utils.safeInvoke(this.props.onComponentUpdate, activePageId);
	    };
	    Documentation.prototype.updateHash = function () {
	        // update state based on current hash location
	        this.handleNavigation(location.hash.slice(1));
	    };
	    Documentation.prototype.maybeScrollToActivePageMenuItem = function () {
	        var activeSectionId = this.state.activeSectionId;
	        // only scroll nav menu if active item is not visible in viewport.
	        // using activeSectionId so you can see the page title in nav (may not be visible in document).
	        var navMenuElement = this.navElement
	            .query("a[href=\"#" + activeSectionId + "\"]").closest(".docs-menu-item-page");
	        var innerBounds = navMenuElement.getBoundingClientRect();
	        var outerBounds = this.navElement.getBoundingClientRect();
	        if (innerBounds.top < outerBounds.top || innerBounds.bottom > outerBounds.bottom) {
	            navMenuElement.scrollIntoView();
	        }
	    };
	    Documentation.prototype.scrollToActiveSection = function () {
	        scrollToReference(this.state.activeSectionId, this.contentElement);
	    };
	    Documentation.prototype.shiftSection = function (direction) {
	        // use the current hash instead of `this.state.activeSectionId` to avoid cases where the
	        // active section cannot actually be selected in the nav (often a short one at the end).
	        var currentSectionId = location.hash.slice(1);
	        // this map is built by an in-order traversal so the keys are actually sorted correctly!
	        var sections = Object.keys(this.routeToPage);
	        var index = sections.indexOf(currentSectionId);
	        var newIndex = index === -1 ? 0 : (index + direction + sections.length) % sections.length;
	        // updating hash triggers event listener which sets new state.
	        location.hash = sections[newIndex];
	    };
	    return Documentation;
	}(React.PureComponent));
	Documentation.defaultProps = {
	    navbarLeft: "Documentation",
	};
	Documentation = tslib_1.__decorate([
	    core_1.HotkeysTarget
	], Documentation);
	exports.Documentation = Documentation;
	/** Shorthand for element.query() + cast to HTMLElement */
	function queryHTMLElement(parent, selector) {
	    return parent.query(selector);
	}
	/**
	 * Returns the reference of the closest section within `offset` pixels of the top of the viewport.
	 */
	function getScrolledReference(offset, container, scrollParent) {
	    if (scrollParent === void 0) { scrollParent = document.body; }
	    var headings = container.queryAll(".docs-title");
	    while (headings.length > 0) {
	        // iterating in reverse order (popping from end / bottom of page)
	        // so the first element below the threshold is the one we want.
	        var element = headings.pop();
	        if (element.offsetTop < scrollParent.scrollTop + offset) {
	            // relying on DOM structure to get reference
	            return element.query("[name]").getAttribute("name");
	        }
	    }
	    return undefined;
	}
	/**
	 * Scroll the scrollParent such that the reference heading appears at the top of the viewport.
	 */
	function scrollToReference(reference, container, scrollParent) {
	    if (scrollParent === void 0) { scrollParent = document.body; }
	    var headingAnchor = queryHTMLElement(container, "a[name=\"" + reference + "\"]");
	    if (headingAnchor == null || headingAnchor.parentElement == null) {
	        return;
	    }
	    var scrollOffset = headingAnchor.parentElement.offsetTop + headingAnchor.offsetTop;
	    scrollParent.scrollTop = scrollOffset;
	}
	
	//# sourceMappingURL=documentation.js.map


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain
	 * a copy of the license in the LICENSE and PATENTS files in the root of this
	 * repository.
	 */
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(__webpack_require__(8));


/***/ },
/* 8 */
/***/ function(module, exports) {

	/**
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain
	 * a copy of the license in the LICENSE and PATENTS files in the root of this
	 * repository.
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	/** Slugify a string: "Really Cool Heading!" => "really-cool-heading-" */
	function slugify(str) {
	    return str.toLowerCase().replace(/[^\w.\/]/g, "-");
	}
	exports.slugify = slugify;
	/**
	 * Type guard to determine if a `contents` node is an `@tag` statement.
	 * Optionally tests tag name too, if `tagName` arg is provided.
	 */
	function isTag(node, tagName) {
	    return node != null && node.tag !== undefined
	        && (tagName === undefined || node.tag === tagName);
	}
	exports.isTag = isTag;
	/** Type guard to deterimine if a `contents` node is an `@#+` heading tag. */
	function isHeadingTag(node) {
	    return isTag(node, "heading");
	}
	exports.isHeadingTag = isHeadingTag;
	/** Type guard for `IPageNode`, useful for its `children` array. */
	function isPageNode(node) {
	    return node != null && node.children != null;
	}
	exports.isPageNode = isPageNode;


/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = Blueprint.Core;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(9);
	var client_1 = __webpack_require__(7);
	/**
	 * Removes leading indents from a template string without removing all leading whitespace.
	 * Trims resulting string to remove blank first/last lines caused by ` location.
	 */
	function dedent(strings) {
	    var values = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        values[_i - 1] = arguments[_i];
	    }
	    var fullString = strings.reduce(function (accumulator, str, i) {
	        return accumulator + values[i - 1].toString() + str;
	    });
	    // match all leading spaces/tabs at the start of each line
	    var match = fullString.match(/^[ \t]*(?=\S)/gm);
	    // find the smallest indent, we don't want to remove all leading whitespace
	    var indent = Math.min.apply(Math, match.map(function (el) { return el.length; }));
	    var regexp = new RegExp("^[ \\t]{" + indent + "}", "gm");
	    fullString = indent > 0 ? fullString.replace(regexp, "") : fullString;
	    return fullString.trim();
	}
	exports.dedent = dedent;
	function smartSearch(query) {
	    var content = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        content[_i - 1] = arguments[_i];
	    }
	    var terms = query.toLowerCase().split(" ");
	    var dataToSearch = content.map(function (s) { return s.toLowerCase(); });
	    return terms.every(function (term) { return dataToSearch.some(function (d) { return d.indexOf(term) >= 0; }); });
	}
	exports.smartSearch = smartSearch;
	function createKeyEventHandler(actions, preventDefault) {
	    if (preventDefault === void 0) { preventDefault = false; }
	    return function (e) {
	        for (var _i = 0, _a = Object.keys(actions); _i < _a.length; _i++) {
	            var k = _a[_i];
	            var key = Number(k);
	            if (e.which === key) {
	                if (preventDefault) {
	                    e.preventDefault();
	                }
	                actions[key](e);
	            }
	        }
	        core_1.Utils.safeInvoke(actions.all, e);
	    };
	}
	exports.createKeyEventHandler = createKeyEventHandler;
	/**
	 * Performs an in-order traversal of the layout tree, invoking the callback for each node.
	 * Callback receives an array of ancestors with direct parent first in the list.
	 */
	function eachLayoutNode(layout, callback, parents) {
	    if (parents === void 0) { parents = []; }
	    layout.forEach(function (node) {
	        callback(node, parents);
	        if (client_1.isPageNode(node)) {
	            eachLayoutNode(node.children, callback, [node].concat(parents));
	        }
	    });
	}
	exports.eachLayoutNode = eachLayoutNode;
	
	//# sourceMappingURL=utils.js.map


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(9);
	var classNames = __webpack_require__(4);
	var fuzzaldrin_plus_1 = __webpack_require__(12);
	var React = __webpack_require__(5);
	var react_dom_1 = __webpack_require__(19);
	var utils_1 = __webpack_require__(10);
	var baseExample_1 = __webpack_require__(2);
	var Navigator = (function (_super) {
	    tslib_1.__extends(Navigator, _super);
	    function Navigator() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.state = {
	            query: "",
	            selectedIndex: 0,
	        };
	        // this guy must be defined before he's used in handleQueryChange
	        // and it just makes sense to be up here with state init
	        // tslint:disable:member-ordering
	        _this.resetState = function (query) {
	            if (query === void 0) { query = ""; }
	            return _this.setState({ query: query, selectedIndex: 0 });
	        };
	        _this.handleQueryChange = baseExample_1.handleStringChange(_this.resetState);
	        _this.handleKeyDown = utils_1.createKeyEventHandler((_a = {},
	            _a[core_1.Keys.ARROW_DOWN] = _this.selectNext(),
	            _a[core_1.Keys.ARROW_UP] = _this.selectNext(-1),
	            _a[core_1.Keys.ENTER] = function () {
	                var activeItem = react_dom_1.findDOMNode(_this).query("." + core_1.Classes.MENU_ITEM + "." + core_1.Classes.ACTIVE);
	                if (activeItem != null) {
	                    activeItem.click();
	                }
	            },
	            _a));
	        _this.handleFocusSearch = function (e) {
	            if (_this.inputRef != null) {
	                e.preventDefault();
	                _this.inputRef.focus();
	            }
	        };
	        _this.handleSetSearchInputRef = function (ref) {
	            _this.inputRef = ref;
	        };
	        _this.handlePopoverInteraction = function (nextOpenState) {
	            if (!nextOpenState) {
	                _this.resetState();
	            }
	        };
	        _this.handleResultHover = function (e) {
	            var el = e.currentTarget;
	            if (el.parentElement != null) {
	                var selectedIndex = Array.prototype.indexOf.call(el.parentElement.children, el);
	                _this.setState(tslib_1.__assign({}, _this.state, { selectedIndex: selectedIndex }));
	            }
	        };
	        return _this;
	        var _a;
	    }
	    Navigator.prototype.render = function () {
	        return (React.createElement(core_1.Popover, { autoFocus: false, enforceFocus: false, className: "docs-navigator", content: this.renderPopover(), onInteraction: this.handlePopoverInteraction, inline: true, isOpen: this.state.query.length > 0, popoverClassName: core_1.Classes.MINIMAL, position: core_1.Position.BOTTOM_LEFT },
	            React.createElement(core_1.InputGroup, { autoFocus: true, inputRef: this.handleSetSearchInputRef, leftIconName: "search", onChange: this.handleQueryChange, onKeyDown: this.handleKeyDown, placeholder: "Search...", type: "search", value: this.state.query })));
	    };
	    Navigator.prototype.renderHotkeys = function () {
	        return React.createElement(core_1.Hotkeys, null,
	            React.createElement(core_1.Hotkey, { global: true, combo: "shift + s", label: "Focus documentation search box", onKeyDown: this.handleFocusSearch }));
	    };
	    Navigator.prototype.componentDidMount = function () {
	        var _this = this;
	        this.sections = [];
	        utils_1.eachLayoutNode(this.props.items, function (node, parents) {
	            var route = node.route, title = node.title;
	            var path = parents.map(function (p) { return p.title; }).reverse();
	            var filterKey = path.concat([title]).join("/");
	            _this.sections.push({ filterKey: filterKey, path: path, route: route, title: title });
	        });
	    };
	    Navigator.prototype.getMatches = function () {
	        return fuzzaldrin_plus_1.filter(this.sections, this.state.query, {
	            key: "filterKey",
	        });
	    };
	    Navigator.prototype.renderPopover = function () {
	        var _this = this;
	        var matches = this.getMatches();
	        var selectedIndex = Math.min(matches.length, this.state.selectedIndex);
	        var items = matches.map(function (section, index) {
	            var isSelected = index === selectedIndex;
	            var classes = classNames(core_1.Classes.MENU_ITEM, core_1.Classes.POPOVER_DISMISS, (_a = {},
	                _a[core_1.Classes.ACTIVE] = isSelected,
	                _a[core_1.Classes.INTENT_PRIMARY] = isSelected,
	                _a));
	            var headerHtml = { __html: section.title };
	            // add $icons16-family to font stack to support mixing icons with regular text!
	            var pathHtml = { __html: section.path.join(core_1.IconContents.CARET_RIGHT) };
	            return (React.createElement("a", { className: classes, href: "#" + section.route, key: section.route, onMouseEnter: _this.handleResultHover },
	                React.createElement("small", { className: "docs-result-path pt-text-muted", dangerouslySetInnerHTML: pathHtml }),
	                React.createElement("div", { dangerouslySetInnerHTML: headerHtml })));
	            var _a;
	        });
	        if (items.length === 0) {
	            items = [
	                React.createElement("a", { className: classNames(core_1.Classes.MENU_ITEM, core_1.Classes.DISABLED), key: "none" },
	                    "No results. Press ",
	                    React.createElement("code", null, "esc"),
	                    " to reset."),
	            ];
	        }
	        return React.createElement(core_1.Menu, null, items);
	    };
	    Navigator.prototype.selectNext = function (direction) {
	        var _this = this;
	        if (direction === void 0) { direction = 1; }
	        return function () { return _this.setState(tslib_1.__assign({}, _this.state, { selectedIndex: Math.max(0, _this.state.selectedIndex + direction) })); };
	    };
	    return Navigator;
	}(React.PureComponent));
	Navigator = tslib_1.__decorate([
	    core_1.HotkeysTarget
	], Navigator);
	exports.Navigator = Navigator;
	
	//# sourceMappingURL=navigator.js.map


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var PathSeparator, filter, legacy_scorer, matcher, prepQueryCache, scorer;
	
	  scorer = __webpack_require__(13);
	
	  legacy_scorer = __webpack_require__(16);
	
	  filter = __webpack_require__(17);
	
	  matcher = __webpack_require__(18);
	
	  PathSeparator = __webpack_require__(14).sep;
	
	  prepQueryCache = null;
	
	  module.exports = {
	    filter: function(candidates, query, options) {
	      if (!((query != null ? query.length : void 0) && (candidates != null ? candidates.length : void 0))) {
	        return [];
	      }
	      return filter(candidates, query, options);
	    },
	    prepQuery: function(query) {
	      return scorer.prepQuery(query);
	    },
	    score: function(string, query, prepQuery, _arg) {
	      var allowErrors, coreQuery, legacy, queryHasSlashes, score, _ref;
	      _ref = _arg != null ? _arg : {}, allowErrors = _ref.allowErrors, legacy = _ref.legacy;
	      if (!((string != null ? string.length : void 0) && (query != null ? query.length : void 0))) {
	        return 0;
	      }
	      if (prepQuery == null) {
	        prepQuery = prepQueryCache && prepQueryCache.query === query ? prepQueryCache : (prepQueryCache = scorer.prepQuery(query));
	      }
	      if (!legacy) {
	        score = scorer.score(string, query, prepQuery, !!allowErrors);
	      } else {
	        queryHasSlashes = prepQuery.depth > 0;
	        coreQuery = prepQuery.core;
	        score = legacy_scorer.score(string, coreQuery, queryHasSlashes);
	        if (!queryHasSlashes) {
	          score = legacy_scorer.basenameScore(string, coreQuery, score);
	        }
	      }
	      return score;
	    },
	    match: function(string, query, prepQuery, _arg) {
	      var allowErrors, baseMatches, matches, query_lw, string_lw, _i, _ref, _results;
	      allowErrors = (_arg != null ? _arg : {}).allowErrors;
	      if (!string) {
	        return [];
	      }
	      if (!query) {
	        return [];
	      }
	      if (string === query) {
	        return (function() {
	          _results = [];
	          for (var _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
	          return _results;
	        }).apply(this);
	      }
	      if (prepQuery == null) {
	        prepQuery = prepQueryCache && prepQueryCache.query === query ? prepQueryCache : (prepQueryCache = scorer.prepQuery(query));
	      }
	      if (!(allowErrors || scorer.isMatch(string, prepQuery.core_lw, prepQuery.core_up))) {
	        return [];
	      }
	      string_lw = string.toLowerCase();
	      query_lw = prepQuery.query_lw;
	      matches = matcher.match(string, string_lw, prepQuery);
	      if (matches.length === 0) {
	        return matches;
	      }
	      if (string.indexOf(PathSeparator) > -1) {
	        baseMatches = matcher.basenameMatch(string, string_lw, prepQuery);
	        matches = matcher.mergeMatches(matches, baseMatches);
	      }
	      return matches;
	    }
	  };
	
	}).call(this);


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var AcronymResult, PathSeparator, Query, basenameScore, coreChars, countDir, doScore, emptyAcronymResult, file_coeff, isMatch, isSeparator, isWordEnd, isWordStart, miss_coeff, opt_char_re, pos_bonus, scoreAcronyms, scoreCharacter, scoreConsecutives, scoreExact, scoreExactMatch, scorePattern, scorePosition, scoreSize, tau_depth, tau_size, truncatedUpperCase, wm;
	
	  PathSeparator = __webpack_require__(14).sep;
	
	  wm = 150;
	
	  pos_bonus = 20;
	
	  tau_depth = 13;
	
	  tau_size = 85;
	
	  file_coeff = 1.2;
	
	  miss_coeff = 0.75;
	
	  opt_char_re = /[ _\-:\/\\]/g;
	
	  exports.coreChars = coreChars = function(query) {
	    return query.replace(opt_char_re, '');
	  };
	
	  exports.score = function(string, query, prepQuery, allowErrors) {
	    var score, string_lw;
	    if (prepQuery == null) {
	      prepQuery = new Query(query);
	    }
	    if (allowErrors == null) {
	      allowErrors = false;
	    }
	    if (!(allowErrors || isMatch(string, prepQuery.core_lw, prepQuery.core_up))) {
	      return 0;
	    }
	    string_lw = string.toLowerCase();
	    score = doScore(string, string_lw, prepQuery);
	    return Math.ceil(basenameScore(string, string_lw, prepQuery, score));
	  };
	
	  Query = (function() {
	    function Query(query) {
	      if (!(query != null ? query.length : void 0)) {
	        return null;
	      }
	      this.query = query;
	      this.query_lw = query.toLowerCase();
	      this.core = coreChars(query);
	      this.core_lw = this.core.toLowerCase();
	      this.core_up = truncatedUpperCase(this.core);
	      this.depth = countDir(query, query.length);
	    }
	
	    return Query;
	
	  })();
	
	  exports.prepQuery = function(query) {
	    return new Query(query);
	  };
	
	  exports.isMatch = isMatch = function(subject, query_lw, query_up) {
	    var i, j, m, n, qj_lw, qj_up, si;
	    m = subject.length;
	    n = query_lw.length;
	    if (!m || n > m) {
	      return false;
	    }
	    i = -1;
	    j = -1;
	    while (++j < n) {
	      qj_lw = query_lw[j];
	      qj_up = query_up[j];
	      while (++i < m) {
	        si = subject[i];
	        if (si === qj_lw || si === qj_up) {
	          break;
	        }
	      }
	      if (i === m) {
	        return false;
	      }
	    }
	    return true;
	  };
	
	  doScore = function(subject, subject_lw, prepQuery) {
	    var acro, acro_score, align, csc_diag, csc_row, csc_score, i, j, m, miss_budget, miss_left, mm, n, pos, query, query_lw, record_miss, score, score_diag, score_row, score_up, si_lw, start, sz;
	    query = prepQuery.query;
	    query_lw = prepQuery.query_lw;
	    m = subject.length;
	    n = query.length;
	    acro = scoreAcronyms(subject, subject_lw, query, query_lw);
	    acro_score = acro.score;
	    if (acro.count === n) {
	      return scoreExact(n, m, acro_score, acro.pos);
	    }
	    pos = subject_lw.indexOf(query_lw);
	    if (pos > -1) {
	      return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);
	    }
	    score_row = new Array(n);
	    csc_row = new Array(n);
	    sz = scoreSize(n, m);
	    miss_budget = Math.ceil(miss_coeff * n) + 5;
	    miss_left = miss_budget;
	    j = -1;
	    while (++j < n) {
	      score_row[j] = 0;
	      csc_row[j] = 0;
	    }
	    i = subject_lw.indexOf(query_lw[0]);
	    if (i > -1) {
	      i--;
	    }
	    mm = subject_lw.lastIndexOf(query_lw[n - 1], m);
	    if (mm > i) {
	      m = mm + 1;
	    }
	    while (++i < m) {
	      score = 0;
	      score_diag = 0;
	      csc_diag = 0;
	      si_lw = subject_lw[i];
	      record_miss = true;
	      j = -1;
	      while (++j < n) {
	        score_up = score_row[j];
	        if (score_up > score) {
	          score = score_up;
	        }
	        csc_score = 0;
	        if (query_lw[j] === si_lw) {
	          start = isWordStart(i, subject, subject_lw);
	          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
	          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);
	          if (align > score) {
	            score = align;
	            miss_left = miss_budget;
	          } else {
	            if (record_miss && --miss_left <= 0) {
	              return score_row[n - 1] * sz;
	            }
	            record_miss = false;
	          }
	        }
	        score_diag = score_up;
	        csc_diag = csc_row[j];
	        csc_row[j] = csc_score;
	        score_row[j] = score;
	      }
	    }
	    return score * sz;
	  };
	
	  exports.isWordStart = isWordStart = function(pos, subject, subject_lw) {
	    var curr_s, prev_s;
	    if (pos === 0) {
	      return true;
	    }
	    curr_s = subject[pos];
	    prev_s = subject[pos - 1];
	    return isSeparator(curr_s) || isSeparator(prev_s) || (curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1]);
	  };
	
	  exports.isWordEnd = isWordEnd = function(pos, subject, subject_lw, len) {
	    var curr_s, next_s;
	    if (pos === len - 1) {
	      return true;
	    }
	    curr_s = subject[pos];
	    next_s = subject[pos + 1];
	    return isSeparator(curr_s) || isSeparator(next_s) || (curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1]);
	  };
	
	  isSeparator = function(c) {
	    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\';
	  };
	
	  scorePosition = function(pos) {
	    var sc;
	    if (pos < pos_bonus) {
	      sc = pos_bonus - pos;
	      return 100 + sc * sc;
	    } else {
	      return Math.max(100 + pos_bonus - pos, 0);
	    }
	  };
	
	  scoreSize = function(n, m) {
	    return tau_size / (tau_size + Math.abs(m - n));
	  };
	
	  scoreExact = function(n, m, quality, pos) {
	    return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);
	  };
	
	  exports.scorePattern = scorePattern = function(count, len, sameCase, start, end) {
	    var bonus, sz;
	    sz = count;
	    bonus = 6;
	    if (sameCase === count) {
	      bonus += 2;
	    }
	    if (start) {
	      bonus += 3;
	    }
	    if (end) {
	      bonus += 1;
	    }
	    if (count === len) {
	      if (start) {
	        if (sameCase === len) {
	          sz += 2;
	        } else {
	          sz += 1;
	        }
	      }
	      if (end) {
	        bonus += 1;
	      }
	    }
	    return sameCase + sz * (sz + bonus);
	  };
	
	  exports.scoreCharacter = scoreCharacter = function(i, j, start, acro_score, csc_score) {
	    var posBonus;
	    posBonus = scorePosition(i);
	    if (start) {
	      return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);
	    }
	    return posBonus + wm * csc_score;
	  };
	
	  exports.scoreConsecutives = scoreConsecutives = function(subject, subject_lw, query, query_lw, i, j, start) {
	    var k, m, mi, n, nj, sameCase, startPos, sz;
	    m = subject.length;
	    n = query.length;
	    mi = m - i;
	    nj = n - j;
	    k = mi < nj ? mi : nj;
	    startPos = i;
	    sameCase = 0;
	    sz = 0;
	    if (query[j] === subject[i]) {
	      sameCase++;
	    }
	    while (++sz < k && query_lw[++j] === subject_lw[++i]) {
	      if (query[j] === subject[i]) {
	        sameCase++;
	      }
	    }
	    if (sz === 1) {
	      return 1 + 2 * sameCase;
	    }
	    return scorePattern(sz, n, sameCase, start, isWordEnd(i, subject, subject_lw, m));
	  };
	
	  exports.scoreExactMatch = scoreExactMatch = function(subject, subject_lw, query, query_lw, pos, n, m) {
	    var end, i, pos2, sameCase, start;
	    start = isWordStart(pos, subject, subject_lw);
	    if (!start) {
	      pos2 = subject_lw.indexOf(query_lw, pos + 1);
	      if (pos2 > -1) {
	        start = isWordStart(pos2, subject, subject_lw);
	        if (start) {
	          pos = pos2;
	        }
	      }
	    }
	    i = -1;
	    sameCase = 0;
	    while (++i < n) {
	      if (query[pos + i] === subject[i]) {
	        sameCase++;
	      }
	    }
	    end = isWordEnd(pos + n - 1, subject, subject_lw, m);
	    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);
	  };
	
	  AcronymResult = (function() {
	    function AcronymResult(score, pos, count) {
	      this.score = score;
	      this.pos = pos;
	      this.count = count;
	    }
	
	    return AcronymResult;
	
	  })();
	
	  emptyAcronymResult = new AcronymResult(0, 0.1, 0);
	
	  exports.scoreAcronyms = scoreAcronyms = function(subject, subject_lw, query, query_lw) {
	    var count, i, j, m, n, pos, qj_lw, sameCase, score;
	    m = subject.length;
	    n = query.length;
	    if (!(m > 1 && n > 1)) {
	      return emptyAcronymResult;
	    }
	    count = 0;
	    pos = 0;
	    sameCase = 0;
	    i = -1;
	    j = -1;
	    while (++j < n) {
	      qj_lw = query_lw[j];
	      while (++i < m) {
	        if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {
	          if (query[j] === subject[i]) {
	            sameCase++;
	          }
	          pos += i;
	          count++;
	          break;
	        }
	      }
	      if (i === m) {
	        break;
	      }
	    }
	    if (count < 2) {
	      return emptyAcronymResult;
	    }
	    score = scorePattern(count, n, sameCase, true, false);
	    return new AcronymResult(score, pos / count, count);
	  };
	
	  basenameScore = function(subject, subject_lw, prepQuery, fullPathScore) {
	    var alpha, basePathScore, basePos, depth, end;
	    if (fullPathScore === 0) {
	      return 0;
	    }
	    end = subject.length - 1;
	    while (subject[end] === PathSeparator) {
	      end--;
	    }
	    basePos = subject.lastIndexOf(PathSeparator, end);
	    if (basePos === -1) {
	      return fullPathScore;
	    }
	    depth = prepQuery.depth;
	    while (depth-- > 0) {
	      basePos = subject.lastIndexOf(PathSeparator, basePos - 1);
	      if (basePos === -1) {
	        return fullPathScore;
	      }
	    }
	    basePos++;
	    end++;
	    basePathScore = doScore(subject.slice(basePos, end), subject_lw.slice(basePos, end), prepQuery);
	    alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1));
	    return alpha * basePathScore + (1 - alpha) * fullPathScore * scoreSize(0, file_coeff * (end - basePos));
	  };
	
	  exports.countDir = countDir = function(path, end) {
	    var count, i;
	    if (end < 1) {
	      return 0;
	    }
	    count = 0;
	    i = -1;
	    while (++i < end && path[i] === PathSeparator) {
	      continue;
	    }
	    while (++i < end) {
	      if (path[i] === PathSeparator) {
	        count++;
	        while (++i < end && path[i] === PathSeparator) {
	          continue;
	        }
	      }
	    }
	    return count;
	  };
	
	  truncatedUpperCase = function(str) {
	    var char, upper, _i, _len;
	    upper = "";
	    for (_i = 0, _len = str.length; _i < _len; _i++) {
	      char = str[_i];
	      upper += char.toUpperCase()[0];
	    }
	    return upper;
	  };
	
	}).call(this);


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }
	
	  return parts;
	}
	
	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};
	
	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;
	
	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();
	
	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }
	
	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }
	
	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)
	
	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');
	
	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};
	
	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';
	
	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');
	
	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }
	
	  return (isAbsolute ? '/' : '') + path;
	};
	
	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};
	
	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};
	
	
	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);
	
	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }
	
	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }
	
	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }
	
	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));
	
	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }
	
	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }
	
	  outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
	  return outputParts.join('/');
	};
	
	exports.sep = '/';
	exports.delimiter = ':';
	
	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];
	
	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }
	
	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }
	
	  return root + dir;
	};
	
	
	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};
	
	
	exports.extname = function(path) {
	  return splitPath(path)[3];
	};
	
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}
	
	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ },
/* 15 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var PathSeparator, queryIsLastPathSegment;
	
	  PathSeparator = __webpack_require__(14).sep;
	
	  exports.basenameScore = function(string, query, score) {
	    var base, depth, index, lastCharacter, segmentCount, slashCount;
	    index = string.length - 1;
	    while (string[index] === PathSeparator) {
	      index--;
	    }
	    slashCount = 0;
	    lastCharacter = index;
	    base = null;
	    while (index >= 0) {
	      if (string[index] === PathSeparator) {
	        slashCount++;
	        if (base == null) {
	          base = string.substring(index + 1, lastCharacter + 1);
	        }
	      } else if (index === 0) {
	        if (lastCharacter < string.length - 1) {
	          if (base == null) {
	            base = string.substring(0, lastCharacter + 1);
	          }
	        } else {
	          if (base == null) {
	            base = string;
	          }
	        }
	      }
	      index--;
	    }
	    if (base === string) {
	      score *= 2;
	    } else if (base) {
	      score += exports.score(base, query);
	    }
	    segmentCount = slashCount + 1;
	    depth = Math.max(1, 10 - segmentCount);
	    score *= depth * 0.01;
	    return score;
	  };
	
	  exports.score = function(string, query) {
	    var character, characterScore, indexInQuery, indexInString, lowerCaseIndex, minIndex, queryLength, queryScore, stringLength, totalCharacterScore, upperCaseIndex, _ref;
	    if (string === query) {
	      return 1;
	    }
	    if (queryIsLastPathSegment(string, query)) {
	      return 1;
	    }
	    totalCharacterScore = 0;
	    queryLength = query.length;
	    stringLength = string.length;
	    indexInQuery = 0;
	    indexInString = 0;
	    while (indexInQuery < queryLength) {
	      character = query[indexInQuery++];
	      lowerCaseIndex = string.indexOf(character.toLowerCase());
	      upperCaseIndex = string.indexOf(character.toUpperCase());
	      minIndex = Math.min(lowerCaseIndex, upperCaseIndex);
	      if (minIndex === -1) {
	        minIndex = Math.max(lowerCaseIndex, upperCaseIndex);
	      }
	      indexInString = minIndex;
	      if (indexInString === -1) {
	        return 0;
	      }
	      characterScore = 0.1;
	      if (string[indexInString] === character) {
	        characterScore += 0.1;
	      }
	      if (indexInString === 0 || string[indexInString - 1] === PathSeparator) {
	        characterScore += 0.8;
	      } else if ((_ref = string[indexInString - 1]) === '-' || _ref === '_' || _ref === ' ') {
	        characterScore += 0.7;
	      }
	      string = string.substring(indexInString + 1, stringLength);
	      totalCharacterScore += characterScore;
	    }
	    queryScore = totalCharacterScore / queryLength;
	    return ((queryScore * (queryLength / stringLength)) + queryScore) / 2;
	  };
	
	  queryIsLastPathSegment = function(string, query) {
	    if (string[string.length - query.length - 1] === PathSeparator) {
	      return string.lastIndexOf(query) === string.length - query.length;
	    }
	  };
	
	  exports.match = function(string, query, stringOffset) {
	    var character, indexInQuery, indexInString, lowerCaseIndex, matches, minIndex, queryLength, stringLength, upperCaseIndex, _i, _ref, _results;
	    if (stringOffset == null) {
	      stringOffset = 0;
	    }
	    if (string === query) {
	      return (function() {
	        _results = [];
	        for (var _i = stringOffset, _ref = stringOffset + string.length; stringOffset <= _ref ? _i < _ref : _i > _ref; stringOffset <= _ref ? _i++ : _i--){ _results.push(_i); }
	        return _results;
	      }).apply(this);
	    }
	    queryLength = query.length;
	    stringLength = string.length;
	    indexInQuery = 0;
	    indexInString = 0;
	    matches = [];
	    while (indexInQuery < queryLength) {
	      character = query[indexInQuery++];
	      lowerCaseIndex = string.indexOf(character.toLowerCase());
	      upperCaseIndex = string.indexOf(character.toUpperCase());
	      minIndex = Math.min(lowerCaseIndex, upperCaseIndex);
	      if (minIndex === -1) {
	        minIndex = Math.max(lowerCaseIndex, upperCaseIndex);
	      }
	      indexInString = minIndex;
	      if (indexInString === -1) {
	        return [];
	      }
	      matches.push(stringOffset + indexInString);
	      stringOffset += indexInString + 1;
	      string = string.substring(indexInString + 1, stringLength);
	    }
	    return matches;
	  };
	
	}).call(this);


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var PathSeparator, legacy_scorer, pluckCandidates, scorer, sortCandidates;
	
	  scorer = __webpack_require__(13);
	
	  legacy_scorer = __webpack_require__(16);
	
	  pluckCandidates = function(a) {
	    return a.candidate;
	  };
	
	  sortCandidates = function(a, b) {
	    return b.score - a.score;
	  };
	
	  PathSeparator = __webpack_require__(14).sep;
	
	  module.exports = function(candidates, query, _arg) {
	    var allowErrors, bAllowErrors, bKey, candidate, coreQuery, key, legacy, maxInners, maxResults, prepQuery, queryHasSlashes, score, scoredCandidates, spotLeft, string, _i, _j, _len, _len1, _ref;
	    _ref = _arg != null ? _arg : {}, key = _ref.key, maxResults = _ref.maxResults, maxInners = _ref.maxInners, allowErrors = _ref.allowErrors, legacy = _ref.legacy;
	    scoredCandidates = [];
	    spotLeft = (maxInners != null) && maxInners > 0 ? maxInners : candidates.length;
	    bAllowErrors = !!allowErrors;
	    bKey = key != null;
	    prepQuery = scorer.prepQuery(query);
	    if (!legacy) {
	      for (_i = 0, _len = candidates.length; _i < _len; _i++) {
	        candidate = candidates[_i];
	        string = bKey ? candidate[key] : candidate;
	        if (!string) {
	          continue;
	        }
	        score = scorer.score(string, query, prepQuery, bAllowErrors);
	        if (score > 0) {
	          scoredCandidates.push({
	            candidate: candidate,
	            score: score
	          });
	          if (!--spotLeft) {
	            break;
	          }
	        }
	      }
	    } else {
	      queryHasSlashes = prepQuery.depth > 0;
	      coreQuery = prepQuery.core;
	      for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
	        candidate = candidates[_j];
	        string = key != null ? candidate[key] : candidate;
	        if (!string) {
	          continue;
	        }
	        score = legacy_scorer.score(string, coreQuery, queryHasSlashes);
	        if (!queryHasSlashes) {
	          score = legacy_scorer.basenameScore(string, coreQuery, score);
	        }
	        if (score > 0) {
	          scoredCandidates.push({
	            candidate: candidate,
	            score: score
	          });
	        }
	      }
	    }
	    scoredCandidates.sort(sortCandidates);
	    candidates = scoredCandidates.map(pluckCandidates);
	    if (maxResults != null) {
	      candidates = candidates.slice(0, maxResults);
	    }
	    return candidates;
	  };
	
	}).call(this);


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var PathSeparator, scorer;
	
	  PathSeparator = __webpack_require__(14).sep;
	
	  scorer = __webpack_require__(13);
	
	  exports.basenameMatch = function(subject, subject_lw, prepQuery) {
	    var basePos, depth, end;
	    end = subject.length - 1;
	    while (subject[end] === PathSeparator) {
	      end--;
	    }
	    basePos = subject.lastIndexOf(PathSeparator, end);
	    if (basePos === -1) {
	      return [];
	    }
	    depth = prepQuery.depth;
	    while (depth-- > 0) {
	      basePos = subject.lastIndexOf(PathSeparator, basePos - 1);
	      if (basePos === -1) {
	        return [];
	      }
	    }
	    basePos++;
	    end++;
	    return exports.match(subject.slice(basePos, end), subject_lw.slice(basePos, end), prepQuery, basePos);
	  };
	
	  exports.mergeMatches = function(a, b) {
	    var ai, bj, i, j, m, n, out;
	    m = a.length;
	    n = b.length;
	    if (n === 0) {
	      return a.slice();
	    }
	    if (m === 0) {
	      return b.slice();
	    }
	    i = -1;
	    j = 0;
	    bj = b[j];
	    out = [];
	    while (++i < m) {
	      ai = a[i];
	      while (bj <= ai && ++j < n) {
	        if (bj < ai) {
	          out.push(bj);
	        }
	        bj = b[j];
	      }
	      out.push(ai);
	    }
	    while (j < n) {
	      out.push(b[j++]);
	    }
	    return out;
	  };
	
	  exports.match = function(subject, subject_lw, prepQuery, offset) {
	    var DIAGONAL, LEFT, STOP, UP, acro_score, align, backtrack, csc_diag, csc_row, csc_score, i, j, m, matches, move, n, pos, query, query_lw, score, score_diag, score_row, score_up, si_lw, start, trace;
	    if (offset == null) {
	      offset = 0;
	    }
	    query = prepQuery.query;
	    query_lw = prepQuery.query_lw;
	    m = subject.length;
	    n = query.length;
	    acro_score = scorer.scoreAcronyms(subject, subject_lw, query, query_lw).score;
	    score_row = new Array(n);
	    csc_row = new Array(n);
	    STOP = 0;
	    UP = 1;
	    LEFT = 2;
	    DIAGONAL = 3;
	    trace = new Array(m * n);
	    pos = -1;
	    j = -1;
	    while (++j < n) {
	      score_row[j] = 0;
	      csc_row[j] = 0;
	    }
	    i = -1;
	    while (++i < m) {
	      score = 0;
	      score_up = 0;
	      csc_diag = 0;
	      si_lw = subject_lw[i];
	      j = -1;
	      while (++j < n) {
	        csc_score = 0;
	        align = 0;
	        score_diag = score_up;
	        if (query_lw[j] === si_lw) {
	          start = scorer.isWordStart(i, subject, subject_lw);
	          csc_score = csc_diag > 0 ? csc_diag : scorer.scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
	          align = score_diag + scorer.scoreCharacter(i, j, start, acro_score, csc_score);
	        }
	        score_up = score_row[j];
	        csc_diag = csc_row[j];
	        if (score > score_up) {
	          move = LEFT;
	        } else {
	          score = score_up;
	          move = UP;
	        }
	        if (align > score) {
	          score = align;
	          move = DIAGONAL;
	        } else {
	          csc_score = 0;
	        }
	        score_row[j] = score;
	        csc_row[j] = csc_score;
	        trace[++pos] = score > 0 ? move : STOP;
	      }
	    }
	    i = m - 1;
	    j = n - 1;
	    pos = i * n + j;
	    backtrack = true;
	    matches = [];
	    while (backtrack && i >= 0 && j >= 0) {
	      switch (trace[pos]) {
	        case UP:
	          i--;
	          pos -= n;
	          break;
	        case LEFT:
	          j--;
	          pos--;
	          break;
	        case DIAGONAL:
	          matches.push(i + offset);
	          j--;
	          i--;
	          pos -= n + 1;
	          break;
	        default:
	          backtrack = false;
	      }
	    }
	    matches.reverse();
	    return matches;
	  };
	
	}).call(this);


/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_19__;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(9);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var client_1 = __webpack_require__(7);
	// tslint:disable-next-line:max-line-length
	exports.NavMenuItem = function (props) {
	    var item = props.item;
	    var classes = classNames("docs-menu-item", "docs-menu-item-" + (client_1.isPageNode(item) ? "page" : "heading"), "depth-" + item.level, props.className);
	    var itemClasses = classNames(core_1.Classes.MENU_ITEM, (_a = {},
	        _a[core_1.Classes.ACTIVE] = props.isActive,
	        _a[core_1.Classes.INTENT_PRIMARY] = props.isActive,
	        _a));
	    var handleClick = function () { return props.onClick(item.route); };
	    return (React.createElement("li", { className: classes, key: item.route },
	        React.createElement("a", { className: itemClasses, href: "#" + item.route, onClick: handleClick }, item.title),
	        props.children));
	    var _a;
	};
	exports.NavMenuItem.displayName = "Docs.NavMenuItem";
	exports.NavMenu = function (props) {
	    var menu = props.items.map(function (section) {
	        var isActive = props.activeSectionId === section.route;
	        var isExpanded = isActive || isParentOfRoute(section.route, props.activeSectionId);
	        // active section gets selected styles, expanded section shows its children
	        var classes = classNames({ "docs-nav-expanded": isExpanded });
	        var childrenMenu = client_1.isPageNode(section)
	            ? React.createElement(exports.NavMenu, tslib_1.__assign({}, props, { items: section.children }))
	            : undefined;
	        return (React.createElement(exports.NavMenuItem, { className: classes, key: section.route, item: section, isActive: isActive, onClick: props.onItemClick }, childrenMenu));
	    });
	    var classes = classNames("docs-nav-menu", "pt-list-unstyled", props.className);
	    return React.createElement("ul", { className: classes }, menu);
	};
	exports.NavMenu.displayName = "Docs.NavMenu";
	function isParentOfRoute(parent, route) {
	    return route.indexOf(parent + "/") === 0 || route.indexOf(parent + ".") === 0;
	}
	
	//# sourceMappingURL=navMenu.js.map


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(5);
	var block_1 = __webpack_require__(22);
	exports.Page = function (_a) {
	    var tagRenderers = _a.tagRenderers, page = _a.page;
	    var pageContents = block_1.renderContentsBlock(page.contents, tagRenderers, page);
	    return React.createElement("div", { className: "docs-page", "data-page-id": page.reference }, pageContents);
	};
	
	//# sourceMappingURL=page.js.map


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(5);
	function renderContentsBlock(contents, tagRenderers, page) {
	    return contents.map(function (node, i) {
	        if (typeof node === "string") {
	            return React.createElement("div", { className: "docs-section pt-running-text", dangerouslySetInnerHTML: { __html: node }, key: i });
	        }
	        try {
	            var renderer = tagRenderers[node.tag];
	            if (renderer === undefined) {
	                throw new Error("Unknown @tag: " + node.tag);
	            }
	            return renderer(node, i, tagRenderers, page);
	        }
	        catch (ex) {
	            console.error(ex.message);
	            return React.createElement("h3", null,
	                React.createElement("code", null, ex.message));
	        }
	    });
	}
	exports.renderContentsBlock = renderContentsBlock;
	
	//# sourceMappingURL=block.js.map


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(__webpack_require__(24));
	__export(__webpack_require__(10));
	
	//# sourceMappingURL=index.js.map


/***/ },
/* 24 */
/***/ function(module, exports) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var PropsStore = (function () {
	    function PropsStore(props) {
	        var _this = this;
	        this.props = props;
	        this.getInterface = function (name) {
	            return _this.props[name];
	        };
	        this.getProps = function (entry) {
	            if (entry == null) {
	                return [];
	            }
	            else if (entry.extends == null) {
	                return entry.properties;
	            }
	            else {
	                // dirty deduplication for overridden/inherited props
	                var props_1 = {};
	                entry.extends.map(_this.getInheritedProps).forEach(function (inherited) {
	                    inherited.forEach(function (prop) { return props_1[prop.name] = prop; });
	                });
	                entry.properties.forEach(function (prop) { return props_1[prop.name] = prop; });
	                // return a sorted array of unique props
	                return Object.keys(props_1).sort().map(function (n) { return props_1[n]; });
	            }
	        };
	        this.getInheritedProps = function (name) {
	            return _this.getProps(_this.getInterface(name)).map(function (p) {
	                p.inheritedFrom = name;
	                return p;
	            });
	        };
	    }
	    return PropsStore;
	}());
	exports.PropsStore = PropsStore;
	
	//# sourceMappingURL=propsStore.js.map


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(__webpack_require__(26));
	__export(__webpack_require__(28));
	__export(__webpack_require__(29));
	__export(__webpack_require__(30));
	__export(__webpack_require__(32));
	__export(__webpack_require__(33));
	__export(__webpack_require__(34));
	
	//# sourceMappingURL=index.js.map


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var React = __webpack_require__(5);
	var modifierTable_1 = __webpack_require__(27);
	var MODIFIER_PLACEHOLDER = /\{\{([\.\:]?)modifier\}\}/g;
	var DEFAULT_MODIFIER = {
	    documentation: "Default",
	    name: "default",
	};
	var CssExample = function (_a) {
	    var markup = _a.markup, markupHtml = _a.markupHtml, modifiers = _a.modifiers, reference = _a.reference;
	    return (React.createElement("div", null,
	        modifiers.length > 0 ? React.createElement(modifierTable_1.ModifierTable, { modifiers: modifiers }) : undefined,
	        React.createElement("div", { className: "docs-example-wrapper", "data-reference": reference },
	            renderMarkupForModifier(markup, DEFAULT_MODIFIER),
	            modifiers.map(function (mod) { return renderMarkupForModifier(markup, mod); })),
	        React.createElement("div", { className: "docs-markup", dangerouslySetInnerHTML: { __html: markupHtml } })));
	};
	function renderMarkupForModifier(markup, modifier) {
	    var name = modifier.name;
	    var html = markup.replace(MODIFIER_PLACEHOLDER, function (_, prefix) {
	        if (prefix && name.charAt(0) === prefix) {
	            return name.slice(1);
	        }
	        else if (!prefix) {
	            return name;
	        }
	        else {
	            return "";
	        }
	    });
	    return (React.createElement("div", { className: "docs-example", "data-modifier": modifier.name, key: modifier.name },
	        React.createElement("code", null, modifier.name),
	        React.createElement("div", { dangerouslySetInnerHTML: { __html: html } })));
	}
	var CssTagRenderer = (function () {
	    function CssTagRenderer(docs) {
	        var _this = this;
	        this.docs = docs;
	        this.render = function (_a, key) {
	            var reference = _a.value;
	            var example = _this.docs.css[reference];
	            if (example === undefined || example.reference === undefined) {
	                throw new Error("Unknown @css reference: " + reference);
	            }
	            return React.createElement(CssExample, tslib_1.__assign({}, example, { key: key }));
	        };
	    }
	    return CssTagRenderer;
	}());
	exports.CssTagRenderer = CssTagRenderer;
	
	//# sourceMappingURL=css.js.map


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(5);
	function renderModifier(modifier, index) {
	    return (React.createElement("tr", { key: index },
	        React.createElement("td", { "data-modifier": modifier.name },
	            React.createElement("code", null, modifier.name)),
	        React.createElement("td", { dangerouslySetInnerHTML: { __html: modifier.documentation } })));
	}
	exports.ModifierTable = function (_a) {
	    var modifiers = _a.modifiers;
	    return (React.createElement("div", { className: "docs-modifiers" },
	        React.createElement("table", { className: "pt-table" },
	            React.createElement("thead", null,
	                React.createElement("tr", null,
	                    React.createElement("th", null, "Modifier"),
	                    React.createElement("th", null, "Description"))),
	            React.createElement("tbody", null, modifiers.map(renderModifier)))));
	};
	
	//# sourceMappingURL=modifierTable.js.map


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tags = __webpack_require__(25);
	function createDefaultRenderers(docs) {
	    var css = new tags.CssTagRenderer(docs);
	    var heading = new tags.HeadingTagRenderer();
	    var iface = new tags.InterfaceTagRenderer(docs);
	    var page = new tags.PageTagRenderer();
	    return {
	        css: css.render,
	        heading: heading.render,
	        interface: iface.render,
	        page: page.render,
	    };
	}
	exports.createDefaultRenderers = createDefaultRenderers;
	
	//# sourceMappingURL=defaults.js.map


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var React = __webpack_require__(5);
	var Heading = function (_a) {
	    var level = _a.level, route = _a.route, value = _a.value;
	    return (
	    // use createElement so we can dynamically choose tag based on depth
	    React.createElement("h" + level, { className: "docs-title" }, React.createElement("a", { className: "docs-anchor", key: "anchor", name: route }), React.createElement("a", { className: "docs-anchor-link", href: "#" + route, key: "link" },
	        React.createElement("span", { className: "pt-icon-standard pt-icon-link" })), value));
	};
	Heading.displayName = "Docs.Heading";
	var HeadingTagRenderer = (function () {
	    function HeadingTagRenderer() {
	        this.render = function (heading, key) { return React.createElement(Heading, tslib_1.__assign({ key: key }, heading)); };
	    }
	    return HeadingTagRenderer;
	}());
	exports.HeadingTagRenderer = HeadingTagRenderer;
	
	//# sourceMappingURL=heading.js.map


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(5);
	var propsStore_1 = __webpack_require__(24);
	var interfaceTable_1 = __webpack_require__(31);
	var InterfaceTagRenderer = (function () {
	    function InterfaceTagRenderer(docs) {
	        var _this = this;
	        this.render = function (_a, key, tagRenderers) {
	            var name = _a.value;
	            var iface = _this.propsStore.getInterface(name);
	            var props = _this.propsStore.getProps(iface);
	            return React.createElement(interfaceTable_1.InterfaceTable, { key: key, iface: iface, props: props, tagRenderers: tagRenderers });
	        };
	        this.propsStore = new propsStore_1.PropsStore(docs.ts);
	    }
	    return InterfaceTagRenderer;
	}());
	exports.InterfaceTagRenderer = InterfaceTagRenderer;
	
	//# sourceMappingURL=interface.js.map


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(9);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var block_1 = __webpack_require__(22);
	// HACKHACK support `code` blocks until we get real markdown parsing in ts-quick-docs
	function dirtyMarkdown(text) {
	    return { __html: text.replace("<", "&lt;")
	            .replace(/```([^`]+)```/g, function (_, code) { return "<pre>" + code + "</pre>"; })
	            .replace(/`([^`]+)`/g, function (_, code) { return "<code>" + code + "</code>"; }) };
	}
	function propTag(intent, title) {
	    var children = [];
	    for (var _i = 2; _i < arguments.length; _i++) {
	        children[_i - 2] = arguments[_i];
	    }
	    return (React.createElement(core_1.Tag, { key: title, className: core_1.Classes.MINIMAL, intent: intent },
	        title,
	        children));
	}
	var renderPropRow = function (prop) {
	    var documentation = prop.documentation, inheritedFrom = prop.inheritedFrom, name = prop.name, optional = prop.optional;
	    var _a = prop.tags, defaultValue = _a.default, deprecated = _a.deprecated, internal = _a.internal;
	    if (internal) {
	        return undefined;
	    }
	    var classes = classNames("docs-prop-name", {
	        "docs-prop-is-deprecated": deprecated != null,
	        "docs-prop-is-internal": internal,
	        "docs-prop-is-required": !optional,
	    });
	    var tags = [];
	    if (!optional) {
	        tags.push(propTag(core_1.Intent.SUCCESS, "Required"));
	    }
	    if (deprecated) {
	        var maybeMessage = typeof deprecated === "string"
	            ? React.createElement("span", { dangerouslySetInnerHTML: dirtyMarkdown(": " + deprecated) })
	            : "";
	        tags.push(propTag(core_1.Intent.DANGER, "Deprecated", maybeMessage));
	    }
	    if (inheritedFrom != null) {
	        tags.push(propTag(core_1.Intent.NONE, "Inherited", " from ", React.createElement("code", { key: "__code" }, inheritedFrom)));
	    }
	    var formattedType = prop.type.replace(/\b(JSX\.)?Element\b/, "JSX.Element");
	    // TODO: this ignores tags in prop docs, but that's kind of OK cuz they all get processed
	    // into prop.tags by the TS compiler.
	    var html = documentation.contents.reduce(function (a, b) { return typeof b === "string" ? a + b : a; }, "");
	    return (React.createElement("tr", { key: name },
	        React.createElement("td", { className: classes },
	            React.createElement("code", null, name)),
	        React.createElement("td", { className: "docs-prop-details" },
	            React.createElement("code", { className: "docs-prop-type" },
	                React.createElement("strong", null, formattedType),
	                React.createElement("em", { className: "docs-prop-default pt-text-muted" }, defaultValue)),
	            React.createElement("div", { className: "docs-prop-description", dangerouslySetInnerHTML: { __html: html } }),
	            React.createElement("p", { className: "docs-prop-tags" }, tags))));
	};
	exports.InterfaceTable = function (_a) {
	    var iface = _a.iface, props = _a.props, tagRenderers = _a.tagRenderers;
	    return (React.createElement("div", { className: "docs-modifiers" },
	        React.createElement("div", { className: "docs-interface-name" }, iface.name),
	        block_1.renderContentsBlock(iface.documentation.contents, tagRenderers),
	        React.createElement("table", { className: "pt-table" },
	            React.createElement("thead", null,
	                React.createElement("tr", null,
	                    React.createElement("th", null, "Prop"),
	                    React.createElement("th", null, "Description"))),
	            React.createElement("tbody", null, props.map(renderPropRow)))));
	};
	exports.InterfaceTable.displayName = "Docs.InterfaceTable";
	
	//# sourceMappingURL=interfaceTable.js.map


/***/ },
/* 32 */
/***/ function(module, exports) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var PageTagRenderer = (function () {
	    function PageTagRenderer() {
	        this.render = function () { return undefined; };
	    }
	    return PageTagRenderer;
	}());
	exports.PageTagRenderer = PageTagRenderer;
	
	//# sourceMappingURL=page.js.map


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(5);
	;
	var ReactDocsTagRenderer = (function () {
	    function ReactDocsTagRenderer(docs) {
	        var _this = this;
	        this.docs = docs;
	        /**
	         * Given the name of a component, like `"ColorSchemes"`, attempts to resolve
	         * it to an actual component class in the given map, or in the default map which contains
	         * valid docs components from this package. Provide a custom map to inject your own components.
	         */
	        this.render = function (_a, key) {
	            var componentName = _a.value;
	            if (componentName == null) {
	                return undefined;
	            }
	            var docsComponent = _this.docs[componentName];
	            if (docsComponent == null) {
	                throw new Error("Unknown @reactDocs component: " + componentName);
	            }
	            return React.createElement(docsComponent, { key: key });
	        };
	    }
	    return ReactDocsTagRenderer;
	}());
	exports.ReactDocsTagRenderer = ReactDocsTagRenderer;
	
	//# sourceMappingURL=reactDocs.js.map


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(5);
	;
	exports.ReactExample = function (props) { return (React.createElement("div", { className: "docs-example-wrapper" },
	    props.example.render({ id: props.name }),
	    React.createElement("a", { className: "view-example-source", href: props.example.sourceUrl, target: "_blank" },
	        React.createElement("span", { className: "pt-icon-standard pt-icon-code" }, "\u00A0"),
	        "View source on GitHub"))); };
	exports.ReactExample.displayName = "Docs.ReactExample";
	var ReactExampleTagRenderer = (function () {
	    function ReactExampleTagRenderer(examples) {
	        var _this = this;
	        this.examples = examples;
	        /**
	         * Given the name of an example component, like `"AlertExample"`, attempts to resolve
	         * it to an actual example component exported by one of the packages. Also returns
	         * the URL of the source code on GitHub.
	         */
	        this.render = function (_a, key) {
	            var exampleName = _a.value;
	            if (exampleName == null) {
	                return undefined;
	            }
	            var example = _this.examples[exampleName];
	            if (example == null) {
	                throw new Error("Unknown @example component: " + exampleName);
	            }
	            return React.createElement(exports.ReactExample, { example: example, key: key, name: exampleName });
	        };
	    }
	    return ReactExampleTagRenderer;
	}());
	exports.ReactExampleTagRenderer = ReactExampleTagRenderer;
	
	//# sourceMappingURL=reactExample.js.map


/***/ }
/******/ ])
});
;
//# sourceMappingURL=docs.bundle.js.map