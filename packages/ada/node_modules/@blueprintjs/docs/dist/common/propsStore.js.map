{"version":3,"sources":["../src/common/propsStore.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;;AAQH;IACI,oBAAoB,KAA4C;QAAhE,iBAAoE;QAAhD,UAAK,GAAL,KAAK,CAAuC;QAEzD,iBAAY,GAAG,UAAC,IAAY;YAC/B,MAAM,CAAC,KAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC5B,CAAC,CAAA;QAEM,aAAQ,GAAG,UAAC,KAAwB;YACvC,EAAE,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC;gBAChB,MAAM,CAAC,EAAE,CAAC;YACd,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,IAAI,IAAI,CAAC,CAAC,CAAC;gBAC/B,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC;YAC5B,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,qDAAqD;gBACrD,IAAM,OAAK,GAAuC,EAAE,CAAC;gBACrD,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,KAAI,CAAC,iBAAiB,CAAC,CAAC,OAAO,CAAC,UAAC,SAAS;oBACxD,SAAS,CAAC,OAAO,CAAC,UAAC,IAAI,IAAK,OAAA,OAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,EAAvB,CAAuB,CAAC,CAAC;gBACzD,CAAC,CAAC,CAAC;gBACH,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,UAAC,IAAI,IAAK,OAAA,OAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,EAAvB,CAAuB,CAAC,CAAC;gBAC5D,wCAAwC;gBACxC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAK,CAAC,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,OAAK,CAAC,CAAC,CAAC,EAAR,CAAQ,CAAC,CAAC;YAC1D,CAAC;QACL,CAAC,CAAA;QAEO,sBAAiB,GAAG,UAAC,IAAY;YACrC,MAAM,CAAC,KAAI,CAAC,QAAQ,CAAC,KAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,UAAC,CAA0B;gBACzE,CAAC,CAAC,aAAa,GAAG,IAAI,CAAC;gBACvB,MAAM,CAAC,CAAC,CAAC;YACb,CAAC,CAAC,CAAC;QACP,CAAC,CAAA;IA5BkE,CAAC;IA6BxE,iBAAC;AAAD,CA9BA,AA8BC,IAAA;AA9BY,gCAAU","file":"common/propsStore.js","sourcesContent":["/*\n * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport { ITsInterfaceEntry, ITsPropertyEntry } from \"documentalist/dist/client\";\n\nexport interface IInheritedPropertyEntry extends ITsPropertyEntry {\n    inheritedFrom?: string;\n}\n\nexport class PropsStore {\n    constructor(private props: { [name: string]: ITsInterfaceEntry }) {}\n\n    public getInterface = (name: string) => {\n        return this.props[name];\n    }\n\n    public getProps = (entry: ITsInterfaceEntry): IInheritedPropertyEntry[] => {\n        if (entry == null) {\n            return [];\n        } else if (entry.extends == null) {\n            return entry.properties;\n        } else {\n            // dirty deduplication for overridden/inherited props\n            const props: {[name: string]: ITsPropertyEntry} = {};\n            entry.extends.map(this.getInheritedProps).forEach((inherited) => {\n                inherited.forEach((prop) => props[prop.name] = prop);\n            });\n            entry.properties.forEach((prop) => props[prop.name] = prop);\n            // return a sorted array of unique props\n            return Object.keys(props).sort().map((n) => props[n]);\n        }\n    }\n\n    private getInheritedProps = (name: string) => {\n        return this.getProps(this.getInterface(name)).map((p: IInheritedPropertyEntry) => {\n            p.inheritedFrom = name;\n            return p;\n        });\n    }\n}\n"]}