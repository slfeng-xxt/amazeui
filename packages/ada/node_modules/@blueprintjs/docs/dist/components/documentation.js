/*
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var classNames = require("classnames");
var client_1 = require("documentalist/dist/client");
var React = require("react");
var core_1 = require("@blueprintjs/core");
var utils_1 = require("../common/utils");
var navigator_1 = require("./navigator");
var navMenu_1 = require("./navMenu");
var page_1 = require("./page");
var Documentation = (function (_super) {
    tslib_1.__extends(Documentation, _super);
    function Documentation(props) {
        var _this = _super.call(this, props) || this;
        _this.refHandlers = {
            content: function (ref) { return _this.contentElement = ref; },
            nav: function (ref) { return _this.navElement = ref; },
        };
        _this.handleNavigation = function (activeSectionId) {
            // only update state if this section reference is valid
            var activePageId = _this.routeToPage[activeSectionId];
            if (activeSectionId !== undefined && activePageId !== undefined) {
                _this.setState({ activePageId: activePageId, activeSectionId: activeSectionId });
            }
        };
        _this.handleNextSection = function () { return _this.shiftSection(1); };
        _this.handlePreviousSection = function () { return _this.shiftSection(-1); };
        _this.handleScroll = function () {
            var activeSectionId = getScrolledReference(100, _this.contentElement);
            if (activeSectionId == null) {
                return;
            }
            // use the longer (deeper) name to avoid jumping up between sections
            _this.setState(tslib_1.__assign({}, _this.state, { activeSectionId: activeSectionId }));
        };
        _this.state = {
            activePageId: props.defaultPageId,
            activeSectionId: props.defaultPageId,
        };
        // build up static map of all references to their page, for navigation / routing
        _this.routeToPage = {};
        utils_1.eachLayoutNode(_this.props.docs.nav, function (node, parents) {
            var reference = (client_1.isPageNode(node) ? node : parents[0]).reference;
            _this.routeToPage[node.route] = reference;
        });
        return _this;
    }
    Documentation.prototype.render = function () {
        var _a = this.state, activePageId = _a.activePageId, activeSectionId = _a.activeSectionId;
        var _b = this.props.docs, nav = _b.nav, pages = _b.pages;
        return (React.createElement("div", { className: classNames("docs-root", this.props.className) },
            React.createElement("div", { className: "docs-app" },
                React.createElement("div", { className: "pt-navbar docs-navbar docs-flex-row" },
                    React.createElement("div", { className: "pt-navbar-group" }, this.props.navbarLeft),
                    React.createElement("div", { className: "pt-navbar-group" },
                        React.createElement(navigator_1.Navigator, { items: nav, onNavigate: this.handleNavigation })),
                    React.createElement("div", { className: "pt-navbar-group" }, this.props.navbarRight)),
                React.createElement("div", { className: "docs-nav", ref: this.refHandlers.nav },
                    React.createElement(navMenu_1.NavMenu, { items: nav, activePageId: activePageId, activeSectionId: activeSectionId, onItemClick: this.handleNavigation })),
                React.createElement("article", { className: "docs-content", ref: this.refHandlers.content, role: "main" },
                    React.createElement(page_1.Page, { page: pages[activePageId], tagRenderers: this.props.tagRenderers })))));
    };
    Documentation.prototype.renderHotkeys = function () {
        return (React.createElement(core_1.Hotkeys, null,
            React.createElement(core_1.Hotkey, { global: true, combo: "[", label: "Previous section", onKeyDown: this.handlePreviousSection }),
            React.createElement(core_1.Hotkey, { global: true, combo: "]", label: "Next section", onKeyDown: this.handleNextSection })));
    };
    Documentation.prototype.componentWillMount = function () {
        this.updateHash();
    };
    Documentation.prototype.componentDidMount = function () {
        var _this = this;
        // hooray! so you don't have to!
        core_1.FocusStyleManager.onlyShowFocusOnTabs();
        this.scrollToActiveSection();
        this.maybeScrollToActivePageMenuItem();
        core_1.Utils.safeInvoke(this.props.onComponentUpdate, this.state.activePageId);
        // whoa handling future history...
        window.addEventListener("hashchange", function () {
            if (location.hostname.indexOf("blueprint") !== -1) {
                // captures a pageview for new location hashes that are dynamically rendered without a full page request
                window.ga("send", "pageview", { page: location.pathname + location.search + location.hash });
            }
            // Don't call componentWillMount since the HotkeysTarget decorator will be invoked on every hashchange.
            _this.updateHash();
        });
        document.addEventListener("scroll", this.handleScroll);
    };
    Documentation.prototype.componentWillUnmount = function () {
        window.removeEventListener("hashchange");
        document.removeEventListener("scroll", this.handleScroll);
    };
    Documentation.prototype.componentDidUpdate = function (_prevProps, prevState) {
        var activePageId = this.state.activePageId;
        // only scroll to heading when switching pages, but always check if nav item needs scrolling.
        if (prevState.activePageId !== activePageId) {
            this.scrollToActiveSection();
            this.maybeScrollToActivePageMenuItem();
        }
        core_1.Utils.safeInvoke(this.props.onComponentUpdate, activePageId);
    };
    Documentation.prototype.updateHash = function () {
        // update state based on current hash location
        this.handleNavigation(location.hash.slice(1));
    };
    Documentation.prototype.maybeScrollToActivePageMenuItem = function () {
        var activeSectionId = this.state.activeSectionId;
        // only scroll nav menu if active item is not visible in viewport.
        // using activeSectionId so you can see the page title in nav (may not be visible in document).
        var navMenuElement = this.navElement
            .query("a[href=\"#" + activeSectionId + "\"]").closest(".docs-menu-item-page");
        var innerBounds = navMenuElement.getBoundingClientRect();
        var outerBounds = this.navElement.getBoundingClientRect();
        if (innerBounds.top < outerBounds.top || innerBounds.bottom > outerBounds.bottom) {
            navMenuElement.scrollIntoView();
        }
    };
    Documentation.prototype.scrollToActiveSection = function () {
        scrollToReference(this.state.activeSectionId, this.contentElement);
    };
    Documentation.prototype.shiftSection = function (direction) {
        // use the current hash instead of `this.state.activeSectionId` to avoid cases where the
        // active section cannot actually be selected in the nav (often a short one at the end).
        var currentSectionId = location.hash.slice(1);
        // this map is built by an in-order traversal so the keys are actually sorted correctly!
        var sections = Object.keys(this.routeToPage);
        var index = sections.indexOf(currentSectionId);
        var newIndex = index === -1 ? 0 : (index + direction + sections.length) % sections.length;
        // updating hash triggers event listener which sets new state.
        location.hash = sections[newIndex];
    };
    return Documentation;
}(React.PureComponent));
Documentation.defaultProps = {
    navbarLeft: "Documentation",
};
Documentation = tslib_1.__decorate([
    core_1.HotkeysTarget
], Documentation);
exports.Documentation = Documentation;
/** Shorthand for element.query() + cast to HTMLElement */
function queryHTMLElement(parent, selector) {
    return parent.query(selector);
}
/**
 * Returns the reference of the closest section within `offset` pixels of the top of the viewport.
 */
function getScrolledReference(offset, container, scrollParent) {
    if (scrollParent === void 0) { scrollParent = document.body; }
    var headings = container.queryAll(".docs-title");
    while (headings.length > 0) {
        // iterating in reverse order (popping from end / bottom of page)
        // so the first element below the threshold is the one we want.
        var element = headings.pop();
        if (element.offsetTop < scrollParent.scrollTop + offset) {
            // relying on DOM structure to get reference
            return element.query("[name]").getAttribute("name");
        }
    }
    return undefined;
}
/**
 * Scroll the scrollParent such that the reference heading appears at the top of the viewport.
 */
function scrollToReference(reference, container, scrollParent) {
    if (scrollParent === void 0) { scrollParent = document.body; }
    var headingAnchor = queryHTMLElement(container, "a[name=\"" + reference + "\"]");
    if (headingAnchor == null || headingAnchor.parentElement == null) {
        return;
    }
    var scrollOffset = headingAnchor.parentElement.offsetTop + headingAnchor.offsetTop;
    scrollParent.scrollTop = scrollOffset;
}

//# sourceMappingURL=documentation.js.map
