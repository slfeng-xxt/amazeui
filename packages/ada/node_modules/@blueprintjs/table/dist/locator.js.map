{"version":3,"sources":["../src/locator.ts"],"names":[],"mappings":"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","file":"locator.js","sourcesContent":["/**\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport * as Classes from \"./common/classes\";\nimport { Grid } from \"./common/grid\";\nimport { Rect } from \"./common/rect\";\nimport { Utils } from \"./common/utils\";\n\nexport interface ILocator {\n    /**\n     * Returns the width that a column must be to contain all the content of\n     * its cells without truncating or wrapping.\n     */\n    getWidestVisibleCellInColumn: (columnIndex: number) => number;\n\n    /**\n     * Locates a column's index given the client X coordinate. Returns -1 if\n     * the coordinate is not over a column.\n     */\n    convertPointToColumn: (clientX: number) => number;\n\n    /**\n     * Locates a row's index given the client Y coordinate. Returns -1 if\n     * the coordinate is not over a row.\n     */\n    convertPointToRow: (clientY: number) => number;\n\n    /**\n     * Locates a cell's row and column index given the client X\n     * coordinate. Returns -1 if the coordinate is not over a table cell.\n     */\n    convertPointToCell: (clientX: number, clientY: number) => {col: number, row: number};\n}\n\nexport class Locator implements ILocator {\n    private static CELL_HORIZONTAL_PADDING = 10;\n\n    public constructor(\n        private tableElement: HTMLElement,\n        private bodyElement: HTMLElement,\n        private grid: Grid,\n    ) {\n    }\n\n    public setGrid(grid: Grid) {\n        this.grid = grid;\n    }\n\n    public getViewportRect() {\n        return new Rect(\n            this.bodyElement.scrollLeft,\n            this.bodyElement.scrollTop,\n            this.bodyElement.clientWidth,\n            this.bodyElement.clientHeight,\n        );\n    }\n\n    public getWidestVisibleCellInColumn(columnIndex: number): number {\n        const cellClasses = [\n            `.${Classes.columnCellIndexClass(columnIndex)}`,\n            `.${Classes.TABLE_COLUMN_NAME}`,\n        ];\n        const cells = this.tableElement.querySelectorAll(cellClasses.join(\", \"));\n        let max = 0;\n        for (let i = 0; i < cells.length; i++) {\n            const contentWidth = Utils.measureElementTextContent(cells.item(i)).width;\n            const cellWidth = Math.ceil(contentWidth) + Locator.CELL_HORIZONTAL_PADDING * 2;\n            if (cellWidth > max) {\n                max = cellWidth;\n            }\n        }\n        return max;\n    }\n\n    public convertPointToColumn(clientX: number): number {\n        const tableRect = this.getTableRect();\n        if (!tableRect.containsX(clientX)) {\n            return -1;\n        }\n        return Utils.binarySearch(clientX, this.grid.numCols - 1, this.convertCellIndexToClientX);\n    }\n\n    public convertPointToRow(clientY: number): number {\n        const tableRect = this.getTableRect();\n\n        if (!tableRect.containsY(clientY)) {\n            return -1;\n        }\n        return Utils.binarySearch(clientY, this.grid.numRows - 1, this.convertCellIndexToClientY);\n    }\n\n    public convertPointToCell(clientX: number, clientY: number) {\n        const col = Utils.binarySearch(clientX, this.grid.numCols - 1, this.convertCellIndexToClientX);\n        const row = Utils.binarySearch(clientY, this.grid.numRows - 1, this.convertCellIndexToClientY);\n        return {col, row};\n    }\n\n    private getTableRect() {\n        return Rect.wrap(this.tableElement.getBoundingClientRect());\n    }\n\n    private getBodyRect() {\n        return this.unscrollElementRect(this.bodyElement);\n    }\n\n    /**\n     * Subtracts the scroll offset from the element's bounding client rect.\n     */\n    private unscrollElementRect(element: HTMLElement) {\n        const rect = Rect.wrap(element.getBoundingClientRect());\n        rect.left -= element.scrollLeft;\n        rect.top -= element.scrollTop;\n        return rect;\n    }\n\n    private convertCellIndexToClientX = (index: number) => {\n        const bodyRect = this.getBodyRect();\n        return bodyRect.left + this.grid.getCumulativeWidthAt(index);\n    }\n\n    private convertCellIndexToClientY = (index: number) => {\n        const bodyRect = this.getBodyRect();\n        return bodyRect.top + this.grid.getCumulativeHeightAt(index);\n    }\n}\n"]}