/**
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var classNames = require("classnames");
var PureRender = require("pure-render-decorator");
var React = require("react");
var Classes = require("../common/classes");
var index_1 = require("../common/index");
var resizable_1 = require("../interactions/resizable");
var resizeHandle_1 = require("../interactions/resizeHandle");
var selectable_1 = require("../interactions/selectable");
var regions_1 = require("../regions");
var columnHeaderCell_1 = require("./columnHeaderCell");
var ColumnHeader = (function (_super) {
    tslib_1.__extends(ColumnHeader, _super);
    function ColumnHeader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.renderGhostCell = function (columnIndex, extremaClasses) {
            var _a = _this.props, grid = _a.grid, loading = _a.loading;
            var rect = grid.getGhostCellRect(0, columnIndex);
            var style = {
                flexBasis: rect.width + "px",
                width: rect.width + "px",
            };
            return (React.createElement(columnHeaderCell_1.ColumnHeaderCell, { key: Classes.columnIndexClass(columnIndex), className: classNames(extremaClasses), loading: loading, style: style }));
        };
        _this.renderCell = function (columnIndex, extremaClasses) {
            var _a = _this.props, allowMultipleSelection = _a.allowMultipleSelection, cellRenderer = _a.cellRenderer, grid = _a.grid, isResizable = _a.isResizable, loading = _a.loading, maxColumnWidth = _a.maxColumnWidth, minColumnWidth = _a.minColumnWidth, onFocus = _a.onFocus, onColumnWidthChanged = _a.onColumnWidthChanged, onLayoutLock = _a.onLayoutLock, onResizeGuide = _a.onResizeGuide, onSelection = _a.onSelection, selectedRegions = _a.selectedRegions, selectedRegionTransform = _a.selectedRegionTransform;
            var rect = grid.getColumnRect(columnIndex);
            var handleSizeChanged = function (size) {
                onResizeGuide([rect.left + size + 1]);
            };
            var handleResizeEnd = function (size) {
                onResizeGuide(null);
                onColumnWidthChanged(columnIndex, size);
            };
            var handleDoubleClick = function () {
                var width = _this.props.locator.getWidestVisibleCellInColumn(columnIndex);
                var clampedWidth = index_1.Utils.clamp(width, minColumnWidth, maxColumnWidth);
                onResizeGuide(null);
                onColumnWidthChanged(columnIndex, clampedWidth);
            };
            var cell = cellRenderer(columnIndex);
            var className = classNames(cell.props.className, extremaClasses, (_b = {},
                _b[Classes.TABLE_DRAGGABLE] = (onSelection != null),
                _b));
            var cellLoading = cell.props.loading != null ? cell.props.loading : loading;
            var isColumnSelected = regions_1.Regions.hasFullColumn(selectedRegions, columnIndex);
            var cellProps = { className: className, isColumnSelected: isColumnSelected, loading: cellLoading };
            return (React.createElement(selectable_1.DragSelectable, { allowMultipleSelection: allowMultipleSelection, key: Classes.columnIndexClass(columnIndex), locateClick: _this.locateClick, locateDrag: _this.locateDrag, onFocus: onFocus, onSelection: onSelection, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform },
                React.createElement(resizable_1.Resizable, { isResizable: isResizable, maxSize: maxColumnWidth, minSize: minColumnWidth, onDoubleClick: handleDoubleClick, onLayoutLock: onLayoutLock, onResizeEnd: handleResizeEnd, onSizeChanged: handleSizeChanged, orientation: resizeHandle_1.Orientation.VERTICAL, size: rect.width }, React.cloneElement(cell, cellProps))));
            var _b;
        };
        _this.locateClick = function (event) {
            // Abort selection unless the mouse actually hit a table header. This allows
            // users to supply interactive components in their renderHeader methods.
            if (!columnHeaderCell_1.ColumnHeaderCell.isHeaderMouseTarget(event.target)) {
                return null;
            }
            var col = _this.props.locator.convertPointToColumn(event.clientX);
            return regions_1.Regions.column(col);
        };
        _this.locateDrag = function (_event, coords) {
            var colStart = _this.props.locator.convertPointToColumn(coords.activation[0]);
            var colEnd = _this.props.locator.convertPointToColumn(coords.current[0]);
            return regions_1.Regions.column(colStart, colEnd);
        };
        return _this;
    }
    ColumnHeader.prototype.render = function () {
        var _a = this.props, grid = _a.grid, viewportRect = _a.viewportRect, columnIndexStart = _a.columnIndexStart, columnIndexEnd = _a.columnIndexEnd;
        var cells = [];
        for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {
            var extremaClasses = grid.getExtremaClasses(0, columnIndex, 1, columnIndexEnd);
            var renderer = grid.isGhostIndex(-1, columnIndex) ? this.renderGhostCell : this.renderCell;
            cells.push(renderer(columnIndex, extremaClasses));
        }
        // always set width so that the layout can push out the element unless it overflows.
        var style = {
            width: grid.getRect().width + "px",
        };
        // use CSS translation to offset the cells
        if (viewportRect != null) {
            style.transform = "translate3d(" + (grid.getColumnRect(columnIndexStart).left - viewportRect.left) + "px, 0, 0)";
        }
        var classes = classNames(Classes.TABLE_THEAD, Classes.TABLE_COLUMN_HEADER_TR, (_b = {},
            _b[Classes.TABLE_DRAGGABLE] = (this.props.onSelection != null),
            _b));
        return React.createElement("div", { style: style, className: classes }, cells);
        var _b;
    };
    return ColumnHeader;
}(React.Component));
ColumnHeader.defaultProps = {
    isResizable: true,
    loading: false,
};
ColumnHeader = tslib_1.__decorate([
    PureRender
], ColumnHeader);
exports.ColumnHeader = ColumnHeader;

//# sourceMappingURL=columnHeader.js.map
