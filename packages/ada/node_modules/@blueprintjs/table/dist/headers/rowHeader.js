/**
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var classNames = require("classnames");
var PureRender = require("pure-render-decorator");
var React = require("react");
var Classes = require("../common/classes");
var roundSize_1 = require("../common/roundSize");
var resizable_1 = require("../interactions/resizable");
var resizeHandle_1 = require("../interactions/resizeHandle");
var selectable_1 = require("../interactions/selectable");
var regions_1 = require("../regions");
var rowHeaderCell_1 = require("./rowHeaderCell");
var RowHeader = (function (_super) {
    tslib_1.__extends(RowHeader, _super);
    function RowHeader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.renderGhostCell = function (rowIndex, extremaClasses) {
            var _a = _this.props, grid = _a.grid, loading = _a.loading;
            var rect = grid.getGhostCellRect(rowIndex, 0);
            var style = {
                height: rect.height + "px",
            };
            return (React.createElement(rowHeaderCell_1.RowHeaderCell, { key: Classes.rowIndexClass(rowIndex), className: classNames(extremaClasses), loading: loading, style: style }));
        };
        _this.renderCell = function (rowIndex, extremaClasses) {
            var _a = _this.props, allowMultipleSelection = _a.allowMultipleSelection, grid = _a.grid, isResizable = _a.isResizable, loading = _a.loading, maxRowHeight = _a.maxRowHeight, minRowHeight = _a.minRowHeight, onFocus = _a.onFocus, onLayoutLock = _a.onLayoutLock, onResizeGuide = _a.onResizeGuide, onRowHeightChanged = _a.onRowHeightChanged, onSelection = _a.onSelection, renderRowHeader = _a.renderRowHeader, selectedRegions = _a.selectedRegions, selectedRegionTransform = _a.selectedRegionTransform;
            var rect = grid.getRowRect(rowIndex);
            var handleSizeChanged = function (size) {
                onResizeGuide([rect.top + size + 1]);
            };
            var handleResizeEnd = function (size) {
                onResizeGuide(null);
                onRowHeightChanged(rowIndex, size);
            };
            var cell = renderRowHeader(rowIndex);
            var className = classNames(cell.props.className, extremaClasses, (_b = {},
                _b[Classes.TABLE_DRAGGABLE] = onSelection != null,
                _b));
            var cellLoading = cell.props.loading != null ? cell.props.loading : loading;
            var isRowSelected = regions_1.Regions.hasFullRow(selectedRegions, rowIndex);
            var cellProps = { className: className, isRowSelected: isRowSelected, loading: cellLoading };
            return (React.createElement(selectable_1.DragSelectable, { allowMultipleSelection: allowMultipleSelection, key: Classes.rowIndexClass(rowIndex), locateClick: _this.locateClick, locateDrag: _this.locateDrag, onFocus: onFocus, onSelection: onSelection, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform },
                React.createElement(resizable_1.Resizable, { isResizable: isResizable, maxSize: maxRowHeight, minSize: minRowHeight, onLayoutLock: onLayoutLock, onResizeEnd: handleResizeEnd, onSizeChanged: handleSizeChanged, orientation: resizeHandle_1.Orientation.HORIZONTAL, size: rect.height }, React.cloneElement(cell, cellProps))));
            var _b;
        };
        _this.locateClick = function (event) {
            var row = _this.props.locator.convertPointToRow(event.clientY);
            return regions_1.Regions.row(row);
        };
        _this.locateDrag = function (_event, coords) {
            var rowStart = _this.props.locator.convertPointToRow(coords.activation[1]);
            var rowEnd = _this.props.locator.convertPointToRow(coords.current[1]);
            return regions_1.Regions.row(rowStart, rowEnd);
        };
        return _this;
    }
    RowHeader.prototype.render = function () {
        var _a = this.props, grid = _a.grid, rowIndexEnd = _a.rowIndexEnd, rowIndexStart = _a.rowIndexStart, viewportRect = _a.viewportRect;
        var cells = [];
        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {
            var extremaClasses = grid.getExtremaClasses(rowIndex, 0, rowIndexEnd, 1);
            var renderer = grid.isGhostIndex(rowIndex, -1) ? this.renderGhostCell : this.renderCell;
            cells.push(renderer(rowIndex, extremaClasses));
        }
        // always set height so that the layout can push out the element unless it overflows.
        var style = {
            height: grid.getRect().height + "px",
        };
        // use CSS translation to offset the cells
        if (viewportRect != null) {
            style.transform = "translate3d(0, " + (grid.getRowRect(rowIndexStart).top - viewportRect.top) + "px, 0)";
        }
        return (React.createElement(roundSize_1.RoundSize, null,
            React.createElement("div", { style: style }, cells)));
    };
    return RowHeader;
}(React.Component));
RowHeader.defaultProps = {
    isResizable: false,
    loading: false,
    renderRowHeader: renderDefaultRowHeader,
};
RowHeader = tslib_1.__decorate([
    PureRender
], RowHeader);
exports.RowHeader = RowHeader;
/**
 * A default implementation of `IRowHeaderRenderer` that displays 1-indexed
 * numbers for each row.
 */
function renderDefaultRowHeader(rowIndex) {
    return React.createElement(rowHeaderCell_1.RowHeaderCell, { name: "" + (rowIndex + 1) });
}
exports.renderDefaultRowHeader = renderDefaultRowHeader;

//# sourceMappingURL=rowHeader.js.map
