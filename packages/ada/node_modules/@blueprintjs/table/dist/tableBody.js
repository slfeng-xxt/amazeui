/**
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var classNames = require("classnames");
var React = require("react");
var cell_1 = require("./cell/cell");
var Classes = require("./common/classes");
var contextMenuTargetWrapper_1 = require("./common/contextMenuTargetWrapper");
var rect_1 = require("./common/rect");
var utils_1 = require("./common/utils");
var menus_1 = require("./interactions/menus");
var selectable_1 = require("./interactions/selectable");
var regions_1 = require("./regions");
/**
 * For perf, we want to ignore changes to the `ISelectableProps` part of the
 * `ITableBodyProps` since those are only used when a context menu is launched.
 */
var UPDATE_PROPS_KEYS = [
    "grid",
    "locator",
    "viewportRect",
    "cellRenderer",
    "rowIndexStart",
    "rowIndexEnd",
    "columnIndexStart",
    "columnIndexEnd",
    "selectedRegions",
];
var TableBody = (function (_super) {
    tslib_1.__extends(TableBody, _super);
    function TableBody() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.renderContextMenu = function (e) {
            var _a = _this.props, selectedRegions = _a.selectedRegions, renderBodyContextMenu = _a.renderBodyContextMenu, grid = _a.grid;
            if (renderBodyContextMenu == null) {
                return undefined;
            }
            var target = _this.locateClick(e.nativeEvent);
            return renderBodyContextMenu(new menus_1.MenuContext(target, selectedRegions, grid.numRows, grid.numCols));
        };
        _this.renderCell = function (rowIndex, columnIndex, extremaClasses, isGhost) {
            var _a = _this.props, cellRenderer = _a.cellRenderer, loading = _a.loading, grid = _a.grid;
            var baseCell = isGhost ? cell_1.emptyCellRenderer() : cellRenderer(rowIndex, columnIndex);
            var className = classNames(TableBody.cellClassNames(rowIndex, columnIndex), extremaClasses, (_b = {},
                _b[Classes.TABLE_CELL_GHOST] = isGhost,
                _b[Classes.TABLE_CELL_LEDGER_ODD] = (rowIndex % 2) === 1,
                _b[Classes.TABLE_CELL_LEDGER_EVEN] = (rowIndex % 2) === 0,
                _b), baseCell.props.className);
            var key = TableBody.cellReactKey(rowIndex, columnIndex);
            var rect = isGhost ? grid.getGhostCellRect(rowIndex, columnIndex) : grid.getCellRect(rowIndex, columnIndex);
            var cellLoading = baseCell.props.loading != null ? baseCell.props.loading : loading;
            var style = tslib_1.__assign({}, baseCell.props.style, rect_1.Rect.style(rect));
            return React.cloneElement(baseCell, { className: className, key: key, loading: cellLoading, style: style });
            var _b;
        };
        _this.locateClick = function (event) {
            var _a = _this.props.locator.convertPointToCell(event.clientX, event.clientY), col = _a.col, row = _a.row;
            return regions_1.Regions.cell(row, col);
        };
        _this.locateDrag = function (_event, coords) {
            var start = _this.props.locator.convertPointToCell(coords.activation[0], coords.activation[1]);
            var end = _this.props.locator.convertPointToCell(coords.current[0], coords.current[1]);
            return regions_1.Regions.cell(start.row, start.col, end.row, end.col);
        };
        return _this;
    }
    /**
     * Returns the array of class names that must be applied to each table
     * cell so that we can locate any cell based on its coordinate.
     */
    TableBody.cellClassNames = function (rowIndex, columnIndex) {
        return [
            Classes.rowCellIndexClass(rowIndex),
            Classes.columnCellIndexClass(columnIndex),
        ];
    };
    TableBody.cellReactKey = function (rowIndex, columnIndex) {
        return "cell-" + rowIndex + "-" + columnIndex;
    };
    TableBody.prototype.shouldComponentUpdate = function (nextProps) {
        var shallowEqual = utils_1.Utils.shallowCompareKeys(this.props, nextProps, UPDATE_PROPS_KEYS);
        return !shallowEqual;
    };
    TableBody.prototype.render = function () {
        var _a = this.props, allowMultipleSelection = _a.allowMultipleSelection, columnIndexEnd = _a.columnIndexEnd, columnIndexStart = _a.columnIndexStart, grid = _a.grid, onFocus = _a.onFocus, onSelection = _a.onSelection, rowIndexEnd = _a.rowIndexEnd, rowIndexStart = _a.rowIndexStart, selectedRegions = _a.selectedRegions, selectedRegionTransform = _a.selectedRegionTransform;
        var style = grid.getRect().sizeStyle();
        var cells = [];
        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {
            for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {
                var extremaClasses = grid.getExtremaClasses(rowIndex, columnIndex, rowIndexEnd, columnIndexEnd);
                var isGhost = grid.isGhostIndex(rowIndex, columnIndex);
                cells.push(this.renderCell(rowIndex, columnIndex, extremaClasses, isGhost));
            }
        }
        return (React.createElement(selectable_1.DragSelectable, { allowMultipleSelection: allowMultipleSelection, locateClick: this.locateClick, locateDrag: this.locateDrag, onFocus: onFocus, onSelection: onSelection, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform },
            React.createElement(contextMenuTargetWrapper_1.ContextMenuTargetWrapper, { className: classNames(Classes.TABLE_BODY_VIRTUAL_CLIENT, Classes.TABLE_CELL_CLIENT), renderContextMenu: this.renderContextMenu, style: style }, cells)));
    };
    return TableBody;
}(React.Component));
TableBody.defaultProps = {
    loading: false,
};
exports.TableBody = TableBody;

//# sourceMappingURL=tableBody.js.map
