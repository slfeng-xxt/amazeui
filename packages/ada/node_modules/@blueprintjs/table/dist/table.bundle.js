(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("window"), require("classNames"), require("React"), require("Blueprint.Core"), require("ReactDOM"));
	else if(typeof define === 'function' && define.amd)
		define(["window", "classNames", "React", "Blueprint.Core", "ReactDOM"], factory);
	else if(typeof exports === 'object')
		exports["Table"] = factory(require("window"), require("classNames"), require("React"), require("Blueprint.Core"), require("ReactDOM"));
	else
		root["Blueprint"] = root["Blueprint"] || {}, root["Blueprint"]["Table"] = factory(root["window"], root["classNames"], root["React"], root["Blueprint.Core"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_9__, __WEBPACK_EXTERNAL_MODULE_11__, __WEBPACK_EXTERNAL_MODULE_14__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	__webpack_require__(1);
	var cell_1 = __webpack_require__(2);
	exports.Cell = cell_1.Cell;
	var editableCell_1 = __webpack_require__(13);
	exports.EditableCell = editableCell_1.EditableCell;
	var jsonFormat_1 = __webpack_require__(18);
	exports.JSONFormat = jsonFormat_1.JSONFormat;
	var truncatedFormat_1 = __webpack_require__(19);
	exports.TruncatedPopoverMode = truncatedFormat_1.TruncatedPopoverMode;
	exports.TruncatedFormat = truncatedFormat_1.TruncatedFormat;
	var column_1 = __webpack_require__(20);
	exports.Column = column_1.Column;
	var index_1 = __webpack_require__(21);
	exports.Clipboard = index_1.Clipboard;
	exports.Grid = index_1.Grid;
	exports.Rect = index_1.Rect;
	exports.Utils = index_1.Utils;
	var draggable_1 = __webpack_require__(15);
	exports.Draggable = draggable_1.Draggable;
	var menus_1 = __webpack_require__(27);
	exports.CopyCellsMenuItem = menus_1.CopyCellsMenuItem;
	var resizeHandle_1 = __webpack_require__(30);
	exports.Orientation = resizeHandle_1.Orientation;
	exports.ResizeHandle = resizeHandle_1.ResizeHandle;
	var selectable_1 = __webpack_require__(31);
	exports.DragSelectable = selectable_1.DragSelectable;
	var columnHeaderCell_1 = __webpack_require__(32);
	exports.ColumnHeaderCell = columnHeaderCell_1.ColumnHeaderCell;
	exports.HorizontalCellDivider = columnHeaderCell_1.HorizontalCellDivider;
	var rowHeaderCell_1 = __webpack_require__(33);
	exports.RowHeaderCell = rowHeaderCell_1.RowHeaderCell;
	var editableName_1 = __webpack_require__(34);
	exports.EditableName = editableName_1.EditableName;
	var regions_1 = __webpack_require__(24);
	exports.ColumnLoadingOption = regions_1.ColumnLoadingOption;
	exports.RegionCardinality = regions_1.RegionCardinality;
	exports.Regions = regions_1.Regions;
	exports.RowLoadingOption = regions_1.RowLoadingOption;
	exports.SelectionModes = regions_1.SelectionModes;
	exports.TableLoadingOption = regions_1.TableLoadingOption;
	var table_1 = __webpack_require__(35);
	exports.Table = table_1.Table;
	
	//# sourceMappingURL=index.js.map


/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var PureRender = __webpack_require__(5);
	var React = __webpack_require__(9);
	var Classes = __webpack_require__(10);
	var core_1 = __webpack_require__(11);
	var loadableContent_1 = __webpack_require__(12);
	exports.emptyCellRenderer = function () { return React.createElement(Cell, null); };
	var Cell = (function (_super) {
	    tslib_1.__extends(Cell, _super);
	    function Cell() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Cell.prototype.render = function () {
	        var _a = this.props, style = _a.style, intent = _a.intent, interactive = _a.interactive, loading = _a.loading, tooltip = _a.tooltip, truncated = _a.truncated, className = _a.className, wrapText = _a.wrapText;
	        var classes = classNames(Classes.TABLE_CELL, core_1.Classes.intentClass(intent), (_b = {},
	            _b[Classes.TABLE_CELL_INTERACTIVE] = interactive,
	            _b[core_1.Classes.LOADING] = loading,
	            _b[Classes.TABLE_TRUNCATED_CELL] = truncated,
	            _b), className);
	        var textClasses = classNames((_c = {},
	            _c[Classes.TABLE_TRUNCATED_TEXT] = truncated,
	            _c[Classes.TABLE_NO_WRAP_TEXT] = !wrapText,
	            _c));
	        var content = React.createElement("div", { className: textClasses }, this.props.children);
	        return (React.createElement("div", { className: classes, style: style, title: tooltip },
	            React.createElement(loadableContent_1.LoadableContent, { loading: loading, variableLength: true }, content)));
	        var _b, _c;
	    };
	    return Cell;
	}(React.Component));
	Cell.defaultProps = {
	    truncated: true,
	    wrapText: false,
	};
	Cell = tslib_1.__decorate([
	    PureRender
	], Cell);
	exports.Cell = Cell;
	
	//# sourceMappingURL=cell.js.map


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0
	
	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.
	
	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global global, define, System, Reflect, Promise */
	var __extends;
	var __assign;
	var __rest;
	var __decorate;
	var __param;
	var __metadata;
	var __awaiter;
	var __generator;
	(function (factory) {
	    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (exports) { factory(createExporter(root, createExporter(exports))); }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    else if (typeof module === "object" && typeof module.exports === "object") {
	        factory(createExporter(root, createExporter(module.exports)));
	    }
	    else {
	        factory(createExporter(root));
	    }
	    function createExporter(exports, previous) {
	        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
	    }
	})
	(function (exporter) {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	
	    __extends = function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	
	    __assign = Object.assign || function (t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	
	    __rest = function (s, e) {
	        var t = {};
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	            t[p] = s[p];
	        if (s != null && typeof Object.getOwnPropertySymbols === "function")
	            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
	                t[p[i]] = s[p[i]];
	        return t;
	    };
	
	    __decorate = function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	
	    __param = function (paramIndex, decorator) {
	        return function (target, key) { decorator(target, key, paramIndex); }
	    };
	
	    __metadata = function (metadataKey, metadataValue) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
	    };
	
	    __awaiter = function (thisArg, _arguments, P, generator) {
	        return new (P || (P = Promise))(function (resolve, reject) {
	            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	            step((generator = generator.apply(thisArg, _arguments || [])).next());
	        });
	    };
	
	    __generator = function (thisArg, body) {
	        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
	        return { next: verb(0), "throw": verb(1), "return": verb(2) };
	        function verb(n) { return function (v) { return step([n, v]); }; }
	        function step(op) {
	            if (f) throw new TypeError("Generator is already executing.");
	            while (_) try {
	                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
	                if (y = 0, t) op = [0, t.value];
	                switch (op[0]) {
	                    case 0: case 1: t = op; break;
	                    case 4: _.label++; return { value: op[1], done: false };
	                    case 5: _.label++; y = op[1]; op = [0]; continue;
	                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                    default:
	                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                        if (t[2]) _.ops.pop();
	                        _.trys.pop(); continue;
	                }
	                op = body.call(thisArg, _);
	            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	        }
	    };
	
	    exporter("__extends", __extends);
	    exporter("__assign", __assign);
	    exporter("__rest", __rest);
	    exporter("__decorate", __decorate);
	    exporter("__param", __param);
	    exporter("__metadata", __metadata);
	    exporter("__awaiter", __awaiter);
	    exporter("__generator", __generator);
	});
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @author Félix Girault <felix.girault@gmail.com>
	 * @license MIT
	 */
	'use strict';
	
	var warning = __webpack_require__(6);
	var shallowEqual = __webpack_require__(8);
	
	
	
	/**
	 * Tells if a component should update given it's next props
	 * and state.
	 *
	 * @param object nextProps Next props.
	 * @param object nextState Next state.
	 */
	function shouldComponentUpdate(nextProps, nextState) {
	  return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
	}
	
	/**
	 * Returns a text description of the component that can be
	 * used to identify it in error messages.
	 *
	 * @see https://github.com/facebook/react/blob/v15.4.0-rc.3/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js#L1143
	 * @param {function} component The component.
	 * @return {string} The name of the component.
	 */
	function getComponentName(component) {
	  var constructor = component.prototype && component.prototype.constructor;
	
	  return (
	    component.displayName
	    || (constructor && constructor.displayName)
	    || component.name
	    || (constructor && constructor.name)
	    || 'a component'
	  );
	}
	
	/**
	 * Makes the given component "pure".
	 *
	 * @param object component Component.
	 */
	function pureRenderDecorator(component) {
	  if (component.prototype.shouldComponentUpdate !== undefined) {
	    // We're not using the condition mecanism of warning()
	    // here to avoid useless calls to getComponentName().
	    warning(
	      false,
	      'Cannot decorate `%s` with @pureRenderDecorator, '
	      + 'because it already implements `shouldComponentUpdate().',
	      getComponentName(component)
	    )
	  }
	
	  component.prototype.shouldComponentUpdate = shouldComponentUpdate;
	  return component;
	}
	
	
	
	module.exports = pureRenderDecorator;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(7);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (false) {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };
	
	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }
	
	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }
	
	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }
	
	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}
	
	module.exports = warning;

/***/ },
/* 7 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 8 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Added the nonzero y check to make Flow happy, but it is redundant
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ },
/* 10 */
/***/ function(module, exports) {

	/*
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TABLE_BODY = "bp-table-body";
	exports.TABLE_BODY_SCROLL_CLIENT = "bp-table-body-scroll-client";
	exports.TABLE_BODY_VIRTUAL_CLIENT = "bp-table-body-virtual-client";
	exports.TABLE_BOTTOM_CONTAINER = "bp-table-bottom-container";
	exports.TABLE_CELL = "bp-table-cell";
	exports.TABLE_CELL_CLIENT = "bp-table-cell-client";
	exports.TABLE_CELL_GHOST = "bp-table-cell-ghost";
	exports.TABLE_CELL_INTERACTIVE = "bp-table-cell-interactive";
	exports.TABLE_CELL_LEDGER_EVEN = "bp-table-cell-ledger-even";
	exports.TABLE_CELL_LEDGER_ODD = "bp-table-cell-ledger-odd";
	exports.TABLE_COLUMN_HEADER_TR = "bp-table-column-header-tr";
	exports.TABLE_COLUMN_HEADERS = "bp-table-column-headers";
	exports.TABLE_COLUMN_NAME = "bp-table-column-name";
	exports.TABLE_COLUMN_NAME_TEXT = "bp-table-column-name-text";
	exports.TABLE_CONTAINER = "bp-table-container";
	exports.TABLE_DRAGGABLE = "bp-table-draggable";
	exports.TABLE_DRAGGING = "bp-table-dragging";
	exports.TABLE_EDITABLE_NAME = "bp-table-editable-name";
	exports.TABLE_FOCUS_REGION = "bp-table-focus-region";
	exports.TABLE_HEADER = "bp-table-header";
	exports.TABLE_HEADER_ACTIVE = "bp-table-header-active";
	exports.TABLE_HEADER_CONTENT = "bp-table-header-content";
	exports.TABLE_HEADER_SELECTED = "bp-table-header-selected";
	exports.TABLE_HORIZONTAL_CELL_DIVIDER = "bp-table-horizontal-cell-divider";
	exports.TABLE_HORIZONTAL_GUIDE = "bp-table-horizontal-guide";
	exports.TABLE_INTERACTION_BAR = "bp-table-interaction-bar";
	exports.TABLE_LAST_IN_COLUMN = "bp-table-last-in-column";
	exports.TABLE_LAST_IN_ROW = "bp-table-last-in-row";
	exports.TABLE_MENU = "bp-table-menu";
	exports.TABLE_NO_HORIZONTAL_SCROLL = "bp-table-no-horizontal-scroll";
	exports.TABLE_NO_LAYOUT = "bp-table-no-layout";
	exports.TABLE_NO_VERTICAL_SCROLL = "bp-table-no-vertical-scroll";
	exports.TABLE_NO_WRAP_TEXT = "bp-table-no-wrap-text";
	exports.TABLE_NULL = "bp-table-null";
	exports.TABLE_OVERLAY = "bp-table-overlay";
	exports.TABLE_OVERLAY_LAYER = "bp-table-overlay-layer";
	exports.TABLE_POPOVER_WHITESPACE_NORMAL = "bp-table-popover-whitespace-normal";
	exports.TABLE_POPOVER_WHITESPACE_PRE = "bp-table-popover-whitespace-pre";
	exports.TABLE_REGION = "bp-table-region";
	exports.TABLE_RESIZE_GUIDES = "bp-table-resize-guides";
	exports.TABLE_RESIZE_HANDLE = "bp-table-resize-handle";
	exports.TABLE_RESIZE_HANDLE_TARGET = "bp-table-resize-handle-target";
	exports.TABLE_RESIZE_HORIZONTAL = "bp-table-resize-horizontal";
	exports.TABLE_RESIZE_SENSOR = "bp-table-resize-sensor";
	exports.TABLE_RESIZE_SENSOR_EXPAND = "bp-table-resize-sensor-expand";
	exports.TABLE_RESIZE_SENSOR_SHRINK = "bp-table-resize-sensor-shrink";
	exports.TABLE_RESIZE_VERTICAL = "bp-table-resize-vertical";
	exports.TABLE_ROUNDED_LAYOUT = "bp-table-rounded-layout";
	exports.TABLE_ROW_HEADERS = "bp-table-row-headers";
	exports.TABLE_ROW_NAME = "bp-table-row-name";
	exports.TABLE_ROW_NAME_TEXT = "bp-table-row-name-text";
	exports.TABLE_SELECTION_ENABLED = "bp-table-selection-enabled";
	exports.TABLE_SELECTION_REGION = "bp-table-selection-region";
	exports.TABLE_TH_MENU = "bp-table-th-menu";
	exports.TABLE_TH_MENU_CONTAINER = "bp-table-th-menu-container";
	exports.TABLE_TH_MENU_CONTAINER_BACKGROUND = "bp-table-th-menu-container-background";
	exports.TABLE_THEAD = "bp-table-thead";
	exports.TABLE_TOP_CONTAINER = "bp-table-top-container";
	exports.TABLE_TRUNCATED_CELL = "bp-table-truncated-cell";
	exports.TABLE_TRUNCATED_FORMAT = "bp-table-truncated-format";
	exports.TABLE_TRUNCATED_POPOVER = "bp-table-truncated-popover";
	exports.TABLE_TRUNCATED_POPOVER_TARGET = "bp-table-truncated-popover-target";
	exports.TABLE_TRUNCATED_TEXT = "bp-table-truncated-text";
	exports.TABLE_TRUNCATED_VALUE = "bp-table-truncated-value";
	exports.TABLE_VERTICAL_GUIDE = "bp-table-vertical-guide";
	/** Common code for row and column index class generator functions, since they're essentially the same. */
	function dimensionIndexClass(classPrefix, index) {
	    if (index == null) {
	        return undefined;
	    }
	    if (typeof index === "number") {
	        return "" + classPrefix + index;
	    }
	    return index.indexOf(classPrefix) === 0 ? index : "" + classPrefix + index;
	}
	/** Return CSS class for table colummn index, whether or not 'bp-table-col-' prefix is included. */
	function columnIndexClass(columnIndex) {
	    return dimensionIndexClass("bp-table-col-", columnIndex);
	}
	exports.columnIndexClass = columnIndexClass;
	/** Return CSS class for table row index, whether or not 'bp-table-row-' prefix is included. */
	function rowIndexClass(rowIndex) {
	    return dimensionIndexClass("bp-table-row-", rowIndex);
	}
	exports.rowIndexClass = rowIndexClass;
	/** Return CSS class for table colummn cell index, whether or not 'bp-table-cell-col-' prefix is included. */
	function columnCellIndexClass(columnIndex) {
	    return dimensionIndexClass("bp-table-cell-col-", columnIndex);
	}
	exports.columnCellIndexClass = columnCellIndexClass;
	/** Return CSS class for table row cell index, whether or not 'bp-table-cell-row-' prefix is included. */
	function rowCellIndexClass(rowIndex) {
	    return dimensionIndexClass("bp-table-cell-row-", rowIndex);
	}
	exports.rowCellIndexClass = rowCellIndexClass;
	
	//# sourceMappingURL=classes.js.map


/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = Blueprint.Core;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var React = __webpack_require__(9);
	var core_1 = __webpack_require__(11);
	// This class expects a single, non-string child.
	var LoadableContent = (function (_super) {
	    tslib_1.__extends(LoadableContent, _super);
	    function LoadableContent(props) {
	        var _this = _super.call(this, props) || this;
	        _this.style = _this.calculateStyle(props.variableLength);
	        return _this;
	    }
	    LoadableContent.prototype.componentWillReceiveProps = function (nextProps) {
	        if (!this.props.loading && nextProps.loading || this.props.variableLength !== nextProps.variableLength) {
	            this.style = this.calculateStyle(nextProps.variableLength);
	        }
	    };
	    LoadableContent.prototype.render = function () {
	        if (this.props.loading) {
	            return React.createElement("div", { className: core_1.Classes.SKELETON, style: this.style });
	        }
	        return React.Children.only(this.props.children);
	    };
	    LoadableContent.prototype.calculateStyle = function (variableLength) {
	        var skeletonLength = variableLength ? 75 - Math.floor(Math.random() * 11) * 5 : 100;
	        return { width: skeletonLength + "%" };
	    };
	    return LoadableContent;
	}(React.Component));
	exports.LoadableContent = LoadableContent;
	
	//# sourceMappingURL=loadableContent.js.map


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var PureRender = __webpack_require__(5);
	var React = __webpack_require__(9);
	var ReactDOM = __webpack_require__(14);
	var core_1 = __webpack_require__(11);
	var Classes = __webpack_require__(10);
	var draggable_1 = __webpack_require__(15);
	var cell_1 = __webpack_require__(2);
	var EditableCell = (function (_super) {
	    tslib_1.__extends(EditableCell, _super);
	    function EditableCell() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.state = {
	            isEditing: false,
	        };
	        _this.handleEdit = function () {
	            _this.setState({ isEditing: true });
	        };
	        _this.handleCancel = function (value) {
	            _this.setState({ isEditing: false });
	            core_1.Utils.safeInvoke(_this.props.onCancel, value);
	        };
	        _this.handleConfirm = function (value) {
	            _this.setState({ isEditing: false });
	            core_1.Utils.safeInvoke(_this.props.onConfirm, value);
	        };
	        _this.handleCellActivate = function (_event) {
	            // Cancel edit of active cell when clicking away
	            if (!_this.state.isEditing && document.activeElement instanceof HTMLElement && document.activeElement.blur) {
	                document.activeElement.blur();
	            }
	            return true;
	        };
	        _this.handleCellDoubleClick = function (_event) {
	            var cellElement = ReactDOM.findDOMNode(_this);
	            if (cellElement == null) {
	                return;
	            }
	            var focusable = cellElement.querySelector(".pt-editable-text");
	            if (focusable.focus != null) {
	                focusable.focus();
	            }
	        };
	        return _this;
	    }
	    EditableCell.prototype.render = function () {
	        var _a = this.props, intent = _a.intent, onChange = _a.onChange, value = _a.value;
	        var isEditing = this.state.isEditing;
	        var interactive = this.props.interactive || isEditing;
	        return (React.createElement(cell_1.Cell, tslib_1.__assign({}, this.props, { truncated: false, interactive: interactive }),
	            React.createElement(draggable_1.Draggable, { onActivate: this.handleCellActivate, onDoubleClick: this.handleCellDoubleClick, preventDefault: !interactive, stopPropagation: interactive },
	                React.createElement(core_1.EditableText, { className: Classes.TABLE_EDITABLE_NAME, defaultValue: value, intent: intent, minWidth: null, onCancel: this.handleCancel, onChange: onChange, onConfirm: this.handleConfirm, onEdit: this.handleEdit, placeholder: "", selectAllOnFocus: true }))));
	    };
	    return EditableCell;
	}(React.Component));
	EditableCell = tslib_1.__decorate([
	    PureRender
	], EditableCell);
	exports.EditableCell = EditableCell;
	
	//# sourceMappingURL=editableCell.js.map


/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_14__;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var PureRender = __webpack_require__(5);
	var React = __webpack_require__(9);
	var ReactDOM = __webpack_require__(14);
	var utils_1 = __webpack_require__(16);
	var dragEvents_1 = __webpack_require__(17);
	var REATTACH_PROPS_KEYS = [
	    "stopPropagation",
	    "preventDefault",
	];
	/**
	 * This component provides a simple interface for combined drag and/or click
	 * events.
	 *
	 * Since the mouse interactions for drag and click are overloaded, here are
	 * the events that will fire in these cases:
	 *
	 * A Click Interaction
	 * 1. The user presses down on the render element, triggering the onActivate
	 *    callback.
	 * 2. The user releases the mouse button without moving it, triggering the
	 *    onClick callback.
	 *
	 * A Drag Interaction
	 * 1. The user presses down on the render element, triggering the onActivate
	 *    callback.
	 * 2. The user moves the mouse, triggering the onDragMove callback.
	 * 3. The user moves the mouse, triggering the onDragMove callback.
	 * 4. The user moves the mouse, triggering the onDragMove callback.
	 * 5. The user releases the mouse button, triggering a final onDragMove
	 *    callback as well as an onDragEnd callback.
	 *
	 * If `false` is returned from the onActivate callback, no further events
	 * will be fired until the next activation.
	 */
	var Draggable = (function (_super) {
	    tslib_1.__extends(Draggable, _super);
	    function Draggable() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Draggable.prototype.render = function () {
	        return React.Children.only(this.props.children);
	    };
	    Draggable.prototype.componentWillReceiveProps = function (nextProps) {
	        if (this.events && !utils_1.Utils.shallowCompareKeys(this.props, nextProps, REATTACH_PROPS_KEYS)) {
	            this.events.attach(ReactDOM.findDOMNode(this), nextProps);
	        }
	    };
	    Draggable.prototype.componentDidMount = function () {
	        this.events = new dragEvents_1.DragEvents();
	        this.events.attach(ReactDOM.findDOMNode(this), this.props);
	    };
	    Draggable.prototype.componentWillUnmount = function () {
	        this.events.detach();
	        delete this.events;
	    };
	    return Draggable;
	}(React.Component));
	Draggable.defaultProps = {
	    preventDefault: true,
	    stopPropagation: false,
	};
	Draggable = tslib_1.__decorate([
	    PureRender
	], Draggable);
	exports.Draggable = Draggable;
	
	//# sourceMappingURL=draggable.js.map


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(9);
	;
	// tslint:enable
	/**
	 * Since Firefox doesn't provide a computed "font" property, we manually
	 * construct it using the ordered properties that can be specifed in CSS.
	 */
	var CSS_FONT_PROPERTIES = [
	    "font-style",
	    "font-variant",
	    "font-weight",
	    "font-size",
	    "font-family",
	];
	exports.Utils = {
	    /**
	     * Returns a clone of the ReactElement with a className that includes the
	     * element's original className and any other classes passed in with variadic
	     * arguments matching the `classNames` api.
	     */
	    assignClasses: function (elem) {
	        var extendedClasses = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            extendedClasses[_i - 1] = arguments[_i];
	        }
	        var classes = classNames.apply(void 0, [elem.props.className].concat(extendedClasses));
	        return React.cloneElement(elem, { className: classes });
	    },
	    /**
	     * Invokes the callback `n` times, collecting the results in an array, which
	     * is the return value. Similar to _.times
	     */
	    times: function (n, callback) {
	        return Array.apply(null, Array(n)).map(function (_none, index) { return callback(index); });
	    },
	    /**
	     * Takes an array of numbers, returns an array of numbers of the same length in which each
	     * value is the sum of current and previous values in the input array.
	     *
	     * Example input:  [10, 20, 50]
	     *         output: [10, 30, 80]
	     */
	    accumulate: function (numbers) {
	        var result = [];
	        var sum = 0;
	        for (var _i = 0, numbers_1 = numbers; _i < numbers_1.length; _i++) {
	            var num = numbers_1[_i];
	            sum += num;
	            result.push(sum);
	        }
	        return result;
	    },
	    /**
	     * Returns traditional spreadsheet-style column names
	     * e.g. (A, B, ..., Z, AA, AB, ..., ZZ, AAA, AAB, ...).
	     *
	     * Note that this isn't technically mathematically equivalent to base 26 since
	     * there is no zero element.
	     */
	    toBase26Alpha: function (num) {
	        var str = "";
	        while (true) {
	            var letter = num % 26;
	            str = String.fromCharCode(65 + letter) + str;
	            num = num - letter;
	            if (num <= 0) {
	                return str;
	            }
	            num = (num / 26) - 1;
	        }
	    },
	    /**
	     * Performs the binary search algorithm to find the index of the `value`
	     * parameter in a sorted list of numbers. If `value` is not in the list, the
	     * index where `value` can be inserted to maintain the sort is returned.
	     *
	     * Unlike a typical binary search implementation, we use a `lookup`
	     * callback to access the sorted list of numbers instead of an array. This
	     * avoids additional storage overhead.
	     *
	     * We use this to, for example, find the index of a row/col given its client
	     * coordinate.
	     *
	     * Adapted from lodash https://github.com/lodash/lodash/blob/4.11.2/lodash.js#L3579
	     *
	     * @param value - the query value
	     * @param high - the length of the sorted list of numbers
	     * @param lookup - returns the number from the list at the supplied index
	     */
	    binarySearch: function (value, high, lookup) {
	        var low = 0;
	        while (low < high) {
	            var mid = Math.floor((low + high) / 2.0);
	            var computed = lookup(mid);
	            if (computed < value) {
	                low = mid + 1;
	            }
	            else {
	                high = mid;
	            }
	        }
	        return high;
	    },
	    /**
	     * Returns a copy of the array that will have a length of the supplied parameter.
	     * If the array is too long, it will be truncated. If it is too short, it will be
	     * filled with the suppleid `fillValue` argument.
	     *
	     * @param array - the `Array` to copy and adjust
	     * @param length - the target length of the array
	     * @param fillValue - the value to add to the array if it is too short
	     */
	    arrayOfLength: function (array, length, fillValue) {
	        if (array.length > length) {
	            return array.slice(0, length);
	        }
	        array = array.slice();
	        while (array.length < length) {
	            array.push(fillValue);
	        }
	        return array;
	    },
	    /**
	     * Takes in one full array of values and one sparse array of the same
	     * length and type. Returns a copy of the `defaults` array, where each
	     * value is replaced with the corresponding non-null value at the same
	     * index in `sparseOverrides`.
	     *
	     * @param defaults - the full array of default values
	     * @param sparseOverrides - the sparse array of override values
	     */
	    assignSparseValues: function (defaults, sparseOverrides) {
	        if (sparseOverrides == null || defaults.length !== sparseOverrides.length) {
	            return defaults;
	        }
	        defaults = defaults.slice();
	        for (var i = 0; i < defaults.length; i++) {
	            var override = sparseOverrides[i];
	            if (override != null) {
	                defaults[i] = override;
	            }
	        }
	        return defaults;
	    },
	    /**
	     * Measures the bounds of supplied element's textContent.
	     *
	     * We use the computed font from the supplied element and a non-DOM canvas
	     * context to measure the text.
	     *
	     * Returns a `TextMetrics` object.
	     */
	    measureElementTextContent: function (element) {
	        var context = document.createElement("canvas").getContext("2d");
	        var style = getComputedStyle(element, null);
	        context.font = CSS_FONT_PROPERTIES.map(function (prop) { return style.getPropertyValue(prop); }).join(" ");
	        return context.measureText(element.textContent);
	    },
	    /**
	     * Given a number, returns a value that is clamped within a
	     * minimum/maximum bounded range. The minimum and maximum are optional. If
	     * either is missing, that extrema limit is not applied.
	     *
	     * Assumes max >= min.
	     */
	    clamp: function (value, min, max) {
	        if (min != null && value < min) {
	            value = min;
	        }
	        if (max != null && value > max) {
	            value = max;
	        }
	        return value;
	    },
	    /**
	     * Partial shallow comparison between objects using the given list of keys.
	     */
	    shallowCompareKeys: function (objA, objB, keys) {
	        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
	            var key = keys_1[_i];
	            if (objA[key] !== objB[key]) {
	                return false;
	            }
	        }
	        return true;
	    },
	};
	
	//# sourceMappingURL=utils.js.map


/***/ },
/* 17 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var DragEvents = (function () {
	    function DragEvents() {
	        var _this = this;
	        this.handleMouseDown = function (event) {
	            _this.initCoordinateData(event);
	            if (_this.handler != null && _this.handler.onActivate != null) {
	                var exitCode = _this.handler.onActivate(event);
	                if (exitCode === false) {
	                    return;
	                }
	            }
	            _this.isActivated = true;
	            _this.maybeAlterEventChain(event);
	            // It is possible that the mouseup would not be called after the initial
	            // mousedown (for example if the mouse is moved out of the window). So,
	            // we preemptively detach to avoid duplicate listeners.
	            _this.detachDocumentEventListeners();
	            _this.attachDocumentEventListeners();
	        };
	        this.handleMouseMove = function (event) {
	            _this.maybeAlterEventChain(event);
	            if (_this.isActivated) {
	                _this.isDragging = true;
	            }
	            if (_this.isDragging) {
	                var coords = _this.updateCoordinateData(event);
	                if (_this.handler != null && _this.handler.onDragMove != null) {
	                    _this.handler.onDragMove(event, coords);
	                }
	            }
	        };
	        this.handleMouseUp = function (event) {
	            _this.maybeAlterEventChain(event);
	            if (_this.handler != null) {
	                if (_this.isDragging) {
	                    var coords = _this.updateCoordinateData(event);
	                    if (_this.handler.onDragMove != null) {
	                        _this.handler.onDragMove(event, coords);
	                    }
	                    if (_this.handler.onDragEnd != null) {
	                        _this.handler.onDragEnd(event, coords);
	                    }
	                }
	                else if (_this.isActivated) {
	                    if (_this.handler.onDoubleClick != null) {
	                        if (_this.doubleClickTimeoutToken == null) {
	                            // if this the first click of a possible double-click,
	                            // we delay the firing of the click event by the
	                            // timeout.
	                            _this.doubleClickTimeoutToken = setTimeout(function () {
	                                delete _this.doubleClickTimeoutToken;
	                                if (_this.handler.onClick != null) {
	                                    _this.handler.onClick(event);
	                                }
	                            }, DragEvents.DOUBLE_CLICK_TIMEOUT_MSEC);
	                        }
	                        else {
	                            // otherwise, this is the second click in the double-
	                            // click so we cancel the single-click timeout and
	                            // fire the double-click event.
	                            clearTimeout(_this.doubleClickTimeoutToken);
	                            delete _this.doubleClickTimeoutToken;
	                            _this.handler.onDoubleClick(event);
	                        }
	                    }
	                    else if (_this.handler.onClick != null) {
	                        _this.handler.onClick(event);
	                    }
	                }
	            }
	            _this.isActivated = false;
	            _this.isDragging = false;
	            _this.detachDocumentEventListeners();
	        };
	    }
	    DragEvents.isAdditive = function (event) {
	        return event.ctrlKey || event.metaKey;
	    };
	    DragEvents.prototype.attach = function (element, handler) {
	        this.detach();
	        this.handler = handler;
	        this.element = element;
	        if (this.isValidDragHandler(handler)) {
	            this.element.addEventListener("mousedown", this.handleMouseDown);
	        }
	        return this;
	    };
	    DragEvents.prototype.detach = function () {
	        if (this.element != null) {
	            this.element.removeEventListener("mousedown", this.handleMouseDown);
	            this.detachDocumentEventListeners();
	        }
	    };
	    DragEvents.prototype.isValidDragHandler = function (handler) {
	        return handler != null && (handler.onActivate != null
	            || handler.onDragMove != null
	            || handler.onDragEnd != null
	            || handler.onClick != null
	            || handler.onDoubleClick != null);
	    };
	    DragEvents.prototype.attachDocumentEventListeners = function () {
	        document.addEventListener("mousemove", this.handleMouseMove);
	        document.addEventListener("mouseup", this.handleMouseUp);
	    };
	    DragEvents.prototype.detachDocumentEventListeners = function () {
	        document.removeEventListener("mousemove", this.handleMouseMove);
	        document.removeEventListener("mouseup", this.handleMouseUp);
	    };
	    DragEvents.prototype.initCoordinateData = function (event) {
	        this.activationCoordinates = [event.clientX, event.clientY];
	        this.lastCoordinates = this.activationCoordinates;
	    };
	    DragEvents.prototype.updateCoordinateData = function (event) {
	        var currentCoordinates = [event.clientX, event.clientY];
	        var deltaCoordinates = [
	            currentCoordinates[0] - this.lastCoordinates[0],
	            currentCoordinates[1] - this.lastCoordinates[1],
	        ];
	        var offsetCoordinates = [
	            currentCoordinates[0] - this.activationCoordinates[0],
	            currentCoordinates[1] - this.activationCoordinates[1],
	        ];
	        var data = {
	            activation: this.activationCoordinates,
	            current: currentCoordinates,
	            delta: deltaCoordinates,
	            last: this.lastCoordinates,
	            offset: offsetCoordinates,
	        };
	        this.lastCoordinates = [event.clientX, event.clientY];
	        return data;
	    };
	    DragEvents.prototype.maybeAlterEventChain = function (event) {
	        if (this.handler.preventDefault) {
	            event.preventDefault();
	        }
	        if (this.handler.stopPropagation) {
	            event.stopPropagation();
	        }
	    };
	    return DragEvents;
	}());
	DragEvents.DOUBLE_CLICK_TIMEOUT_MSEC = 500;
	exports.DragEvents = DragEvents;
	
	//# sourceMappingURL=dragEvents.js.map


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(9);
	var Classes = __webpack_require__(10);
	var truncatedFormat_1 = __webpack_require__(19);
	var JSONFormat = (function (_super) {
	    tslib_1.__extends(JSONFormat, _super);
	    function JSONFormat() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    JSONFormat.prototype.render = function () {
	        var _a = this.props, children = _a.children, omitQuotesOnStrings = _a.omitQuotesOnStrings, stringify = _a.stringify;
	        var showPopover = this.props.showPopover;
	        // always hide popover if value is nully
	        var isNully = children == null;
	        if (isNully) {
	            showPopover = truncatedFormat_1.TruncatedPopoverMode.NEVER;
	        }
	        var className = classNames(this.props.className, (_b = {},
	            _b[Classes.TABLE_NULL] = isNully,
	            _b));
	        var displayValue = "";
	        if (omitQuotesOnStrings && typeof children === "string") {
	            displayValue = children;
	        }
	        else {
	            displayValue = stringify(children);
	        }
	        return (React.createElement(truncatedFormat_1.TruncatedFormat, tslib_1.__assign({}, this.props, { className: className, showPopover: showPopover }), displayValue));
	        var _b;
	    };
	    return JSONFormat;
	}(React.Component));
	JSONFormat.defaultProps = {
	    detectTruncation: true,
	    omitQuotesOnStrings: true,
	    showPopover: truncatedFormat_1.TruncatedPopoverMode.WHEN_TRUNCATED,
	    stringify: function (obj) { return (JSON.stringify(obj, null, 2)); },
	};
	exports.JSONFormat = JSONFormat;
	
	//# sourceMappingURL=jsonFormat.js.map


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(11);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(9);
	var Classes = __webpack_require__(10);
	var TruncatedPopoverMode;
	(function (TruncatedPopoverMode) {
	    TruncatedPopoverMode[TruncatedPopoverMode["ALWAYS"] = 0] = "ALWAYS";
	    TruncatedPopoverMode[TruncatedPopoverMode["NEVER"] = 1] = "NEVER";
	    TruncatedPopoverMode[TruncatedPopoverMode["WHEN_TRUNCATED"] = 2] = "WHEN_TRUNCATED";
	})(TruncatedPopoverMode = exports.TruncatedPopoverMode || (exports.TruncatedPopoverMode = {}));
	var TruncatedFormat = (function (_super) {
	    tslib_1.__extends(TruncatedFormat, _super);
	    function TruncatedFormat() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.state = { isTruncated: false };
	        _this.handleContentDivRef = function (ref) { return _this.contentDiv = ref; };
	        return _this;
	    }
	    TruncatedFormat.prototype.render = function () {
	        var _a = this.props, children = _a.children, detectTruncation = _a.detectTruncation, preformatted = _a.preformatted, truncateLength = _a.truncateLength, truncationSuffix = _a.truncationSuffix;
	        var content = "" + children;
	        var cellContent = content;
	        if (!detectTruncation && truncateLength > 0 && cellContent.length > truncateLength) {
	            cellContent = cellContent.substring(0, truncateLength) + truncationSuffix;
	        }
	        if (this.shouldShowPopover(content)) {
	            var popoverClasses = classNames(Classes.TABLE_TRUNCATED_POPOVER, preformatted ? Classes.TABLE_POPOVER_WHITESPACE_PRE : Classes.TABLE_POPOVER_WHITESPACE_NORMAL);
	            var popoverContent = React.createElement("div", { className: popoverClasses }, children);
	            var className = classNames(this.props.className, Classes.TABLE_TRUNCATED_FORMAT);
	            var constraints = [{
	                    attachment: "together",
	                    pin: true,
	                    to: "window",
	                }];
	            var iconClasses = classNames(core_1.Classes.ICON_STANDARD, core_1.Classes.iconClass("more"));
	            return (React.createElement("div", { className: className },
	                React.createElement("div", { className: Classes.TABLE_TRUNCATED_VALUE, ref: this.handleContentDivRef }, cellContent),
	                React.createElement(core_1.Popover, { className: Classes.TABLE_TRUNCATED_POPOVER_TARGET, tetherOptions: { constraints: constraints }, content: popoverContent, position: core_1.Position.BOTTOM, useSmartArrowPositioning: true, useSmartPositioning: true },
	                    React.createElement("span", { className: iconClasses }))));
	        }
	        else {
	            var className = classNames(this.props.className, Classes.TABLE_TRUNCATED_TEXT);
	            return React.createElement("div", { className: className, ref: this.handleContentDivRef }, cellContent);
	        }
	    };
	    TruncatedFormat.prototype.componentDidMount = function () {
	        this.setTruncationState();
	    };
	    TruncatedFormat.prototype.componentDidUpdate = function () {
	        this.setTruncationState();
	    };
	    TruncatedFormat.prototype.shouldShowPopover = function (content) {
	        var _a = this.props, detectTruncation = _a.detectTruncation, showPopover = _a.showPopover, truncateLength = _a.truncateLength;
	        switch (showPopover) {
	            case TruncatedPopoverMode.ALWAYS:
	                return true;
	            case TruncatedPopoverMode.NEVER:
	                return false;
	            case TruncatedPopoverMode.WHEN_TRUNCATED:
	                return detectTruncation
	                    ? this.state.isTruncated
	                    : (truncateLength > 0 && content.length > truncateLength);
	            default:
	                return false;
	        }
	    };
	    TruncatedFormat.prototype.setTruncationState = function () {
	        if (!this.props.detectTruncation) {
	            return;
	        }
	        var isTruncated = this.contentDiv !== undefined &&
	            (this.contentDiv.scrollWidth > this.contentDiv.clientWidth ||
	                this.contentDiv.scrollHeight > this.contentDiv.clientHeight);
	        if (this.state.isTruncated !== isTruncated) {
	            this.setState({ isTruncated: isTruncated });
	        }
	    };
	    return TruncatedFormat;
	}(React.Component));
	TruncatedFormat.defaultProps = {
	    detectTruncation: true,
	    preformatted: false,
	    showPopover: TruncatedPopoverMode.WHEN_TRUNCATED,
	    truncateLength: 80,
	    truncationSuffix: "...",
	};
	exports.TruncatedFormat = TruncatedFormat;
	
	//# sourceMappingURL=truncatedFormat.js.map


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var React = __webpack_require__(9);
	var cell_1 = __webpack_require__(2);
	var Column = (function (_super) {
	    tslib_1.__extends(Column, _super);
	    function Column() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return Column;
	}(React.Component));
	Column.defaultProps = {
	    renderCell: cell_1.emptyCellRenderer,
	};
	exports.Column = Column;
	
	//# sourceMappingURL=column.js.map


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var clipboard_1 = __webpack_require__(22);
	exports.Clipboard = clipboard_1.Clipboard;
	var grid_1 = __webpack_require__(23);
	exports.Grid = grid_1.Grid;
	var rect_1 = __webpack_require__(25);
	exports.Rect = rect_1.Rect;
	var roundSize_1 = __webpack_require__(26);
	exports.RoundSize = roundSize_1.RoundSize;
	var utils_1 = __webpack_require__(16);
	exports.Utils = utils_1.Utils;
	
	//# sourceMappingURL=index.js.map


/***/ },
/* 22 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	/* istanbul ignore next */
	exports.Clipboard = {
	    /**
	     * Overrides the inherited CSS of the element to make sure it is
	     * selectable. This method also makes the element pseudo-invisible.
	     */
	    applySelectableStyles: function (elem) {
	        elem.style.overflow = "hidden";
	        elem.style.height = "0px";
	        elem.style.setProperty("-webkit-user-select", "all");
	        elem.style.setProperty("-moz-user-select", "all");
	        elem.style.setProperty("-ms-user-select", "all");
	        elem.style.setProperty("user-select", "all");
	        return elem;
	    },
	    /**
	     * Copies table cells to the clipboard. The parameter is a row-major
	     * 2-dimensional `Array` of strings and can contain nulls. We assume all
	     * rows are the same length. If not, the cells will still be copied, but
	     * the columns may not align. Returns a boolean indicating whether the
	     * copy succeeded.
	     *
	     * See `Clipboard.copy`
	     */
	    copyCells: function (cells) {
	        var table = document.createElement("table");
	        exports.Clipboard.applySelectableStyles(table);
	        for (var _i = 0, cells_1 = cells; _i < cells_1.length; _i++) {
	            var row = cells_1[_i];
	            var tr = table.appendChild(document.createElement("tr"));
	            for (var _a = 0, row_1 = row; _a < row_1.length; _a++) {
	                var cell = row_1[_a];
	                var td = tr.appendChild(document.createElement("td"));
	                td.textContent = cell;
	            }
	        }
	        var tsv = cells.map(function (row) { return row.join("\t"); }).join("\n");
	        return exports.Clipboard.copyElement(table, tsv);
	    },
	    /**
	     * Copies the text to the clipboard. Returns a boolean
	     * indicating whether the copy succeeded.
	     *
	     * See `Clipboard.copy`
	     */
	    copyString: function (value) {
	        var text = document.createElement("textarea");
	        exports.Clipboard.applySelectableStyles(text);
	        text.value = value;
	        return exports.Clipboard.copyElement(text, value);
	    },
	    /**
	     * Copies the element and its children to the clipboard. Returns a boolean
	     * indicating whether the copy succeeded.
	     *
	     * If a plaintext argument is supplied, we add both the text/html and
	     * text/plain mime types to the clipboard. This preserves the built in
	     * semantics of copying elements to the clipboard while allowing custom
	     * plaintext output for programs that can't cope with HTML data in the
	     * clipboard.
	     *
	     * Verified on Firefox 47, Chrome 51.
	     *
	     * Note: Sometimes the copy does not succeed. Presumably, in order to
	     * prevent memory issues, browsers will limit the total amount of data you
	     * can copy to the clipboard. Based on ad hoc testing, we found an
	     * inconsistent limit at about 300KB or 40,000 cells. Depending on the on
	     * the content of cells, your limits may vary.
	     */
	    copyElement: function (elem, plaintext) {
	        if (!exports.Clipboard.isCopySupported()) {
	            return false;
	        }
	        // must be document.body instead of document.documentElement for firefox
	        document.body.appendChild(elem);
	        try {
	            window.getSelection().selectAllChildren(elem);
	            if (plaintext != null) {
	                // add plaintext fallback
	                // http://stackoverflow.com/questions/23211018/copy-to-clipboard-with-jquery-js-in-chrome
	                elem.addEventListener("copy", function (e) {
	                    e.preventDefault();
	                    var clipboardData = e.clipboardData || window.clipboardData;
	                    if (clipboardData != null) {
	                        clipboardData.setData("text/html", elem.outerHTML);
	                        clipboardData.setData("text/plain", plaintext);
	                    }
	                });
	            }
	            return document.execCommand("copy");
	        }
	        catch (err) {
	            return false;
	        }
	        finally {
	            document.body.removeChild(elem);
	        }
	    },
	    /**
	     * Returns a boolean indicating whether the current browser nominally
	     * supports the `copy` operation using the `execCommand` API.
	     */
	    isCopySupported: function () {
	        return document.queryCommandSupported != null && document.queryCommandSupported("copy");
	    },
	};
	
	//# sourceMappingURL=clipboard.js.map


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var regions_1 = __webpack_require__(24);
	var Classes = __webpack_require__(10);
	var rect_1 = __webpack_require__(25);
	var utils_1 = __webpack_require__(16);
	/**
	 * This class manages the sizes of grid cells using arrays of individual row/column sizes.
	 */
	var Grid = (function () {
	    /**
	     * This constructor accumulates the heights and widths in `O(n)`, saving
	     * time in later calculations.
	     *
	     * @param bleed - The number of rows/cols that we expand beyond the
	     *     viewport (on all sides). This helps avoid displaying an empty
	     *     viewport when the user scrolls quickly.
	     */
	    function Grid(rowHeights, columnWidths, bleed, ghostHeight, ghostWidth) {
	        if (bleed === void 0) { bleed = Grid.DEFAULT_BLEED; }
	        if (ghostHeight === void 0) { ghostHeight = Grid.DEFAULT_GHOST_HEIGHT; }
	        if (ghostWidth === void 0) { ghostWidth = Grid.DEFAULT_GHOST_WIDTH; }
	        var _this = this;
	        this.getCumulativeWidthAt = function (index) {
	            if (_this.numCols === 0) {
	                return _this.ghostWidth * index;
	            }
	            else if (index >= _this.numCols) {
	                return _this.cumulativeColumnWidths[_this.numCols - 1] + _this.ghostWidth * (index - _this.numCols + 1);
	            }
	            else {
	                return _this.cumulativeColumnWidths[index];
	            }
	        };
	        this.getCumulativeHeightAt = function (index) {
	            if (_this.numRows === 0) {
	                return _this.ghostHeight * index;
	            }
	            else if (index >= _this.numRows) {
	                return _this.cumulativeRowHeights[_this.numRows - 1] + _this.ghostHeight * (index - _this.numRows + 1);
	            }
	            else {
	                return _this.cumulativeRowHeights[index];
	            }
	        };
	        this.columnWidths = columnWidths;
	        this.rowHeights = rowHeights;
	        this.cumulativeColumnWidths = utils_1.Utils.accumulate(columnWidths);
	        this.cumulativeRowHeights = utils_1.Utils.accumulate(rowHeights);
	        this.numCols = columnWidths.length;
	        this.numRows = rowHeights.length;
	        this.bleed = bleed;
	        this.ghostHeight = ghostHeight;
	        this.ghostWidth = ghostWidth;
	    }
	    /**
	     * Returns the `Rect` bounds of a cell in scrollpane client space.
	     *
	     * Scrollpane client coordinate space uses the origin of the scrollpane
	     * client (the inside part that you're moving around).
	     *
	     * For example, let's say you're scrolling around a block of 1000 x 1000
	     * cells. Regardless where you've scrolled, the first cell is always at
	     * 0,0 in scrollpane client space. the cell to the right of it is always
	     * at, e.g., 100,0.
	     */
	    Grid.prototype.getCellRect = function (rowIndex, columnIndex) {
	        var height = this.rowHeights[rowIndex];
	        var top = this.cumulativeRowHeights[rowIndex] - height;
	        var width = this.columnWidths[columnIndex];
	        var left = this.cumulativeColumnWidths[columnIndex] - width;
	        return new rect_1.Rect(left, top, width, height);
	    };
	    /**
	     * Returns the `Rect` bounds of a cell in scrollpane client space.
	     *
	     * If the cell is beyond the bounds of the user-defined table cells, it is
	     * considered a "ghost" cell. If a width/height is not defined for that
	     * row/column, we use the default width/height.
	     */
	    Grid.prototype.getGhostCellRect = function (rowIndex, columnIndex) {
	        var left = 0;
	        var top = 0;
	        var width = 0;
	        var height = 0;
	        if (rowIndex >= this.rowHeights.length) {
	            height = this.ghostHeight;
	            top = this.getHeight() + this.ghostHeight * (rowIndex - this.numRows);
	        }
	        else {
	            height = this.rowHeights[rowIndex];
	            top = this.cumulativeRowHeights[rowIndex] - height;
	        }
	        if (columnIndex >= this.columnWidths.length) {
	            width = this.ghostWidth;
	            left = this.getWidth() + this.ghostWidth * (columnIndex - this.numCols);
	        }
	        else {
	            width = this.columnWidths[columnIndex];
	            left = this.cumulativeColumnWidths[columnIndex] - width;
	        }
	        return new rect_1.Rect(left, top, width, height);
	    };
	    /**
	     * Returns the `Rect` with the base coordinate and height of the specified row.
	     */
	    Grid.prototype.getRowRect = function (rowIndex) {
	        var height = this.rowHeights[rowIndex];
	        var top = this.cumulativeRowHeights[rowIndex] - height;
	        return new rect_1.Rect(0, top, this.getWidth(), height);
	    };
	    /**
	     * Returns the `Rect` with the base coordinate and width of the specified column.
	     */
	    Grid.prototype.getColumnRect = function (columnIndex) {
	        var width = this.columnWidths[columnIndex];
	        var left = this.cumulativeColumnWidths[columnIndex] - width;
	        return new rect_1.Rect(left, 0, width, this.getHeight());
	    };
	    /**
	     * Returns the total width of the entire grid
	     */
	    Grid.prototype.getWidth = function () {
	        return this.numCols === 0 ? 0 : this.cumulativeColumnWidths[this.numCols - 1];
	    };
	    /**
	     * Returns the total width of the entire grid
	     */
	    Grid.prototype.getHeight = function () {
	        return this.numRows === 0 ? 0 : this.cumulativeRowHeights[this.numRows - 1];
	    };
	    /**
	     * Returns the `Rect` bounds of entire grid
	     */
	    Grid.prototype.getRect = function () {
	        return new rect_1.Rect(0, 0, this.getWidth(), this.getHeight());
	    };
	    /**
	     * Maps each cell that intersects with the given `Rect` argument. The
	     * indices of iteration are extended in both directions by the integer
	     * `bleed` class property, then are clamped between 0 and the number of
	     * rows/columns.
	     *
	     * Uses a binary search for each of the 4 edges of the bounds, resulting
	     * in a runtime of `O(log(rows) + log(cols))` plus the `O(irows * icols)`
	     * iteration of intersecting cells.
	     */
	    Grid.prototype.mapCellsInRect = function (rect, callback) {
	        var results = [];
	        if (rect == null) {
	            return results;
	        }
	        var _a = this.getRowIndicesInRect(rect), rowIndexStart = _a.rowIndexStart, rowIndexEnd = _a.rowIndexEnd;
	        var _b = this.getColumnIndicesInRect(rect), columnIndexStart = _b.columnIndexStart, columnIndexEnd = _b.columnIndexEnd;
	        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {
	            for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {
	                results.push(callback(rowIndex, columnIndex));
	            }
	        }
	        return results;
	    };
	    /**
	     * Maps each row that intersects with the given `Rect` argument.
	     *
	     * See Grid.mapCellsInRect for more details.
	     */
	    Grid.prototype.mapRowsInRect = function (rect, callback) {
	        var results = [];
	        if (rect == null) {
	            return results;
	        }
	        var _a = this.getRowIndicesInRect(rect), rowIndexStart = _a.rowIndexStart, rowIndexEnd = _a.rowIndexEnd;
	        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {
	            results.push(callback(rowIndex));
	        }
	        return results;
	    };
	    /**
	     * Maps each column that intersects with the given `Rect` argument.
	     *
	     * See Grid.mapCellsInRect for more details.
	     */
	    Grid.prototype.mapColumnsInRect = function (rect, callback) {
	        var results = [];
	        if (rect == null) {
	            return results;
	        }
	        var _a = this.getColumnIndicesInRect(rect), columnIndexStart = _a.columnIndexStart, columnIndexEnd = _a.columnIndexEnd;
	        for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {
	            results.push(callback(columnIndex));
	        }
	        return results;
	    };
	    /**
	     * Returns the start and end indices of rows that intersect with the given
	     * `Rect` argument.
	     */
	    Grid.prototype.getRowIndicesInRect = function (rect, includeGhostCells, limit) {
	        if (includeGhostCells === void 0) { includeGhostCells = false; }
	        if (limit === void 0) { limit = Grid.DEFAULT_MAX_ROWS; }
	        if (rect == null) {
	            return { rowIndexEnd: 0, rowIndexStart: 0 };
	        }
	        var searchEnd = includeGhostCells ? Math.max(this.numRows, Grid.DEFAULT_MAX_ROWS) : this.numRows;
	        var _a = this.getIndicesInInterval(rect.top, rect.top + rect.height, searchEnd, !includeGhostCells, this.getCumulativeHeightAt), start = _a.start, end = _a.end;
	        var rowIndexEnd = (limit > 0 && end - start > limit)
	            ? start + limit
	            : end;
	        return {
	            rowIndexEnd: rowIndexEnd,
	            rowIndexStart: start,
	        };
	    };
	    /**
	     * Returns the start and end indices of columns that intersect with the
	     * given `Rect` argument.
	     */
	    Grid.prototype.getColumnIndicesInRect = function (rect, includeGhostCells, limit) {
	        if (includeGhostCells === void 0) { includeGhostCells = false; }
	        if (limit === void 0) { limit = Grid.DEFAULT_MAX_COLUMNS; }
	        if (rect == null) {
	            return { columnIndexEnd: 0, columnIndexStart: 0 };
	        }
	        var searchEnd = includeGhostCells ? Math.max(this.numCols, Grid.DEFAULT_MAX_COLUMNS) : this.numCols;
	        var _a = this.getIndicesInInterval(rect.left, rect.left + rect.width, searchEnd, !includeGhostCells, this.getCumulativeWidthAt), start = _a.start, end = _a.end;
	        var columnIndexEnd = (limit > 0 && end - start > limit)
	            ? start + limit
	            : end;
	        return {
	            columnIndexEnd: columnIndexEnd,
	            columnIndexStart: start,
	        };
	    };
	    Grid.prototype.isGhostIndex = function (rowIndex, columnIndex) {
	        return (rowIndex >= this.numRows || columnIndex >= this.numCols);
	    };
	    Grid.prototype.getExtremaClasses = function (rowIndex, columnIndex, rowEnd, columnEnd) {
	        if (rowIndex === rowEnd && columnIndex === columnEnd) {
	            return [Classes.TABLE_LAST_IN_COLUMN, Classes.TABLE_LAST_IN_ROW];
	        }
	        if (rowIndex === rowEnd) {
	            return [Classes.TABLE_LAST_IN_COLUMN];
	        }
	        if (columnIndex === columnEnd) {
	            return [Classes.TABLE_LAST_IN_ROW];
	        }
	        return [];
	    };
	    Grid.prototype.getRegionStyle = function (region) {
	        var cardinality = regions_1.Regions.getRegionCardinality(region);
	        switch (cardinality) {
	            case regions_1.RegionCardinality.CELLS: {
	                var cellRect0 = this.getCellRect(region.rows[0], region.cols[0]);
	                var cellRect1 = this.getCellRect(region.rows[1], region.cols[1]);
	                var offsetLeft = region.cols[0] === 0 ? 0 : 1;
	                var offsetTop = region.rows[0] === 0 ? 0 : 1;
	                var rect = cellRect0.union(cellRect1);
	                rect.height += offsetTop;
	                rect.left -= offsetLeft;
	                rect.width += offsetLeft;
	                rect.top -= offsetTop;
	                return tslib_1.__assign({}, rect.style(), { display: "block" });
	            }
	            case regions_1.RegionCardinality.FULL_COLUMNS: {
	                var cellRect0 = this.getCellRect(0, region.cols[0]);
	                var cellRect1 = this.getCellRect(0, region.cols[1]);
	                var rect = cellRect0.union(cellRect1);
	                var offsetLeft = region.cols[0] === 0 ? 0 : 1;
	                return {
	                    bottom: 0,
	                    display: "block",
	                    left: rect.left - offsetLeft,
	                    top: 0,
	                    width: rect.width + offsetLeft,
	                };
	            }
	            case regions_1.RegionCardinality.FULL_ROWS: {
	                var cellRect0 = this.getCellRect(region.rows[0], 0);
	                var cellRect1 = this.getCellRect(region.rows[1], 0);
	                var rect = cellRect0.union(cellRect1);
	                var offsetTop = region.rows[0] === 0 ? 0 : 1;
	                return {
	                    display: "block",
	                    height: rect.height + offsetTop,
	                    left: 0,
	                    right: 0,
	                    top: rect.top - offsetTop,
	                };
	            }
	            case regions_1.RegionCardinality.FULL_TABLE:
	                return {
	                    bottom: 0,
	                    display: "block",
	                    left: 0,
	                    right: 0,
	                    top: 0,
	                };
	            default: return { display: "none" };
	        }
	    };
	    Grid.prototype.getIndicesInInterval = function (min, max, count, useEndBleed, lookup) {
	        var start = utils_1.Utils.binarySearch(min, count - 1, lookup);
	        var end = utils_1.Utils.binarySearch(max, count - 1, lookup);
	        // correct exact pixel alignment
	        if (start >= 0 && min === lookup(start)) {
	            start += 1;
	        }
	        // apply bounded bleeds
	        start = Math.max(0, start - this.bleed);
	        if (useEndBleed) {
	            end = Math.min(count - 1, end + this.bleed);
	        }
	        else {
	            end = Math.min(count - 1, end);
	        }
	        return { start: start, end: end };
	    };
	    return Grid;
	}());
	Grid.DEFAULT_BLEED = 3;
	Grid.DEFAULT_MAX_COLUMNS = 50;
	Grid.DEFAULT_MAX_ROWS = 200;
	Grid.DEFAULT_GHOST_HEIGHT = 20;
	Grid.DEFAULT_GHOST_WIDTH = 150;
	exports.Grid = Grid;
	
	//# sourceMappingURL=grid.js.map


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var Classes = __webpack_require__(10);
	var utils_1 = __webpack_require__(16);
	/**
	 * `Region`s contain sets of cells. Additionally, a distinction is drawn, for
	 * example, between all cells within a column and the whole column itself.
	 * The `RegionCardinality` enum represents these distinct types of `Region`s.
	 */
	var RegionCardinality;
	(function (RegionCardinality) {
	    /**
	     * A region that contains a finite rectangular group of table cells
	     */
	    RegionCardinality[RegionCardinality["CELLS"] = 0] = "CELLS";
	    /**
	     * A region that represents all cells within 1 or more rows.
	     */
	    RegionCardinality[RegionCardinality["FULL_ROWS"] = 1] = "FULL_ROWS";
	    /**
	     * A region that represents all cells within 1 or more columns.
	     */
	    RegionCardinality[RegionCardinality["FULL_COLUMNS"] = 2] = "FULL_COLUMNS";
	    /**
	     * A region that represents all cells in the table.
	     */
	    RegionCardinality[RegionCardinality["FULL_TABLE"] = 3] = "FULL_TABLE";
	})(RegionCardinality = exports.RegionCardinality || (exports.RegionCardinality = {}));
	/**
	 * A convenience object for subsets of `RegionCardinality` that are commonly
	 * used as the `selectionMode` prop of the `<Table>`.
	 */
	exports.SelectionModes = {
	    ALL: [
	        RegionCardinality.FULL_TABLE,
	        RegionCardinality.FULL_COLUMNS,
	        RegionCardinality.FULL_ROWS,
	        RegionCardinality.CELLS,
	    ],
	    COLUMNS_AND_CELLS: [
	        RegionCardinality.FULL_COLUMNS,
	        RegionCardinality.CELLS,
	    ],
	    COLUMNS_ONLY: [
	        RegionCardinality.FULL_COLUMNS,
	    ],
	    NONE: [],
	    ROWS_AND_CELLS: [
	        RegionCardinality.FULL_ROWS,
	        RegionCardinality.CELLS,
	    ],
	    ROWS_ONLY: [
	        RegionCardinality.FULL_ROWS,
	    ],
	};
	exports.ColumnLoadingOption = {
	    CELLS: "cells",
	    HEADER: "column-header",
	};
	exports.RowLoadingOption = {
	    CELLS: "cells",
	    HEADER: "row-header",
	};
	exports.TableLoadingOption = {
	    CELLS: "cells",
	    COLUMN_HEADERS: exports.ColumnLoadingOption.HEADER,
	    ROW_HEADERS: exports.RowLoadingOption.HEADER,
	};
	var Regions = (function () {
	    function Regions() {
	    }
	    /**
	     * Determines the cardinality of a region. We use null values to indicate
	     * an unbounded interval. Therefore, an example of a region containing the
	     * second and third columns would be:
	     *
	     *     {
	     *         rows: null,
	     *         cols: [1, 2]
	     *     }
	     *
	     * In this case, this method would return `RegionCardinality.FULL_COLUMNS`.
	     *
	     * If both rows and columns are unbounded, then the region covers the
	     * entire table. Therefore, a region like this:
	     *
	     *     {
	     *         rows: null,
	     *         cols: null
	     *     }
	     *
	     * will return `RegionCardinality.FULL_TABLE`.
	     *
	     * An example of a region containing a single cell in the table would be:
	     *
	     *     {
	     *         rows: [5, 5],
	     *         cols: [2, 2]
	     *     }
	     *
	     * In this case, this method would return `RegionCardinality.CELLS`.
	     */
	    Regions.getRegionCardinality = function (region) {
	        if (region.cols != null && region.rows != null) {
	            return RegionCardinality.CELLS;
	        }
	        else if (region.cols != null) {
	            return RegionCardinality.FULL_COLUMNS;
	        }
	        else if (region.rows != null) {
	            return RegionCardinality.FULL_ROWS;
	        }
	        else {
	            return RegionCardinality.FULL_TABLE;
	        }
	    };
	    /**
	     * Returns a region containing one or more cells.
	     */
	    Regions.cell = function (row, col, row2, col2) {
	        return {
	            cols: this.normalizeInterval(col, col2),
	            rows: this.normalizeInterval(row, row2),
	        };
	    };
	    /**
	     * Returns a region containing one or more full rows.
	     */
	    Regions.row = function (row, row2) {
	        return { rows: this.normalizeInterval(row, row2) };
	    };
	    /**
	     * Returns a region containing one or more full columns.
	     */
	    Regions.column = function (col, col2) {
	        return { cols: this.normalizeInterval(col, col2) };
	    };
	    /**
	     * Returns a region containing the entire table.
	     */
	    Regions.table = function () {
	        return {};
	    };
	    /**
	     * Adds the region to the end of a cloned copy of the supplied region
	     * array.
	     */
	    Regions.add = function (regions, region) {
	        var copy = regions.slice();
	        copy.push(region);
	        return copy;
	    };
	    /**
	     * Replaces the region at the end of a cloned copy of the supplied region
	     * array.
	     */
	    Regions.update = function (regions, region) {
	        var copy = regions.slice();
	        copy.pop();
	        copy.push(region);
	        return copy;
	    };
	    /**
	     * Returns true iff the specified region is equal to the last region in
	     * the region list. This allows us to avoid immediate additive re-selection.
	     */
	    Regions.lastRegionIsEqual = function (regions, region) {
	        if (regions == null || regions.length === 0) {
	            return false;
	        }
	        var lastRegion = regions[regions.length - 1];
	        return Regions.regionsEqual(lastRegion, region);
	    };
	    /**
	     * Returns the index of the region that is equal to the supplied
	     * parameter. Returns -1 if no such region is found.
	     */
	    Regions.findMatchingRegion = function (regions, region) {
	        if (regions == null) {
	            return -1;
	        }
	        for (var i = 0; i < regions.length; i++) {
	            if (Regions.regionsEqual(regions[i], region)) {
	                return i;
	            }
	        }
	        return -1;
	    };
	    /**
	     * Returns true if the regions contain a region that has FULL_COLUMNS
	     * cardinality and contains the specified column index.
	     */
	    Regions.hasFullColumn = function (regions, col) {
	        if (regions == null) {
	            return false;
	        }
	        for (var _i = 0, regions_1 = regions; _i < regions_1.length; _i++) {
	            var region = regions_1[_i];
	            var cardinality = Regions.getRegionCardinality(region);
	            if (cardinality === RegionCardinality.FULL_TABLE) {
	                return true;
	            }
	            if (cardinality === RegionCardinality.FULL_COLUMNS && Regions.intervalContainsIndex(region.cols, col)) {
	                return true;
	            }
	        }
	        return false;
	    };
	    /**
	     * Returns true if the regions contain a region that has FULL_ROWS
	     * cardinality and contains the specified row index.
	     */
	    Regions.hasFullRow = function (regions, row) {
	        if (regions == null) {
	            return false;
	        }
	        for (var _i = 0, regions_2 = regions; _i < regions_2.length; _i++) {
	            var region = regions_2[_i];
	            var cardinality = Regions.getRegionCardinality(region);
	            if (cardinality === RegionCardinality.FULL_TABLE) {
	                return true;
	            }
	            if (cardinality === RegionCardinality.FULL_ROWS && Regions.intervalContainsIndex(region.rows, row)) {
	                return true;
	            }
	        }
	        return false;
	    };
	    /**
	     * Returns true if the regions contain a region that has FULL_TABLE cardinality
	     */
	    Regions.hasFullTable = function (regions) {
	        if (regions == null) {
	            return false;
	        }
	        for (var _i = 0, regions_3 = regions; _i < regions_3.length; _i++) {
	            var region = regions_3[_i];
	            var cardinality = Regions.getRegionCardinality(region);
	            if (cardinality === RegionCardinality.FULL_TABLE) {
	                return true;
	            }
	        }
	        return false;
	    };
	    /**
	     * Returns true if the regions contain the query region. The query region
	     * may be a subset of the `regions` parameter.
	     */
	    Regions.containsRegion = function (regions, query) {
	        if (regions == null || query == null) {
	            return false;
	        }
	        for (var _i = 0, regions_4 = regions; _i < regions_4.length; _i++) {
	            var region = regions_4[_i];
	            var cardinality = Regions.getRegionCardinality(region);
	            switch (cardinality) {
	                case RegionCardinality.FULL_TABLE:
	                    return true;
	                case RegionCardinality.FULL_COLUMNS:
	                    if (Regions.intervalOverlaps(region.cols, query.cols)) {
	                        return true;
	                    }
	                    continue;
	                case RegionCardinality.FULL_ROWS:
	                    if (Regions.intervalOverlaps(region.rows, query.rows)) {
	                        return true;
	                    }
	                    continue;
	                case RegionCardinality.CELLS:
	                    if (Regions.intervalOverlaps(region.cols, query.cols)
	                        && Regions.intervalOverlaps(region.rows, query.rows)) {
	                        return true;
	                    }
	                    continue;
	                default:
	                    break;
	            }
	        }
	        return false;
	    };
	    Regions.eachUniqueFullColumn = function (regions, iteratee) {
	        if (regions == null || regions.length === 0 || iteratee == null) {
	            return;
	        }
	        var seen = {};
	        regions.forEach(function (region) {
	            if (Regions.getRegionCardinality(region) === RegionCardinality.FULL_COLUMNS) {
	                var _a = region.cols, start = _a[0], end = _a[1];
	                for (var col = start; col <= end; col++) {
	                    if (!seen[col]) {
	                        seen[col] = true;
	                        iteratee(col);
	                    }
	                }
	            }
	        });
	    };
	    Regions.eachUniqueFullRow = function (regions, iteratee) {
	        if (regions == null || regions.length === 0 || iteratee == null) {
	            return;
	        }
	        var seen = {};
	        regions.forEach(function (region) {
	            if (Regions.getRegionCardinality(region) === RegionCardinality.FULL_ROWS) {
	                var _a = region.rows, start = _a[0], end = _a[1];
	                for (var row = start; row <= end; row++) {
	                    if (!seen[row]) {
	                        seen[row] = true;
	                        iteratee(row);
	                    }
	                }
	            }
	        });
	    };
	    /**
	     * Using the supplied array of non-contiguous `IRegion`s, this method
	     * returns an ordered array of every unique cell that exists in those
	     * regions.
	     */
	    Regions.enumerateUniqueCells = function (regions, numRows, numCols) {
	        if (regions == null || regions.length === 0) {
	            return [];
	        }
	        var seen = {};
	        var list = [];
	        for (var _i = 0, regions_5 = regions; _i < regions_5.length; _i++) {
	            var region = regions_5[_i];
	            Regions.eachCellInRegion(region, numRows, numCols, function (row, col) {
	                // add to list if not seen
	                var key = row + "-" + col;
	                if (seen[key] !== true) {
	                    seen[key] = true;
	                    list.push([row, col]);
	                }
	            });
	        }
	        // sort list by rows then columns
	        list.sort(Regions.rowFirstComparator);
	        return list;
	    };
	    /**
	     * Maps a dense array of cell coordinates to a sparse 2-dimensional array
	     * of cell values.
	     *
	     * We create a new 2-dimensional array representing the smallest single
	     * contiguous `IRegion` that contains all cells in the supplied array. We
	     * invoke the mapper callback only on the cells in the supplied coordinate
	     * array and store the result. Returns the resulting 2-dimensional array.
	     */
	    Regions.sparseMapCells = function (cells, mapper) {
	        var bounds = Regions.getBoundingRegion(cells);
	        if (bounds == null) {
	            return null;
	        }
	        var numRows = bounds.rows[1] + 1 - bounds.rows[0];
	        var numCols = bounds.cols[1] + 1 - bounds.cols[0];
	        var result = utils_1.Utils.times(numRows, function () { return new Array(numCols); });
	        cells.forEach(function (_a) {
	            var row = _a[0], col = _a[1];
	            result[row - bounds.rows[0]][col - bounds.cols[0]] = mapper(row, col);
	        });
	        return result;
	    };
	    /**
	     * Returns the smallest single contiguous `IRegion` that contains all cells in the
	     * supplied array.
	     */
	    Regions.getBoundingRegion = function (cells) {
	        var minRow;
	        var maxRow;
	        var minCol;
	        var maxCol;
	        for (var _i = 0, cells_1 = cells; _i < cells_1.length; _i++) {
	            var _a = cells_1[_i], row = _a[0], col = _a[1];
	            minRow = (minRow == null || row < minRow) ? row : minRow;
	            maxRow = (maxRow == null || row > maxRow) ? row : maxRow;
	            minCol = (minCol == null || col < minCol) ? col : minCol;
	            maxCol = (maxCol == null || col > maxCol) ? col : maxCol;
	        }
	        if (minRow == null) {
	            return null;
	        }
	        return {
	            cols: [minCol, maxCol],
	            rows: [minRow, maxRow],
	        };
	    };
	    Regions.isValid = function (region) {
	        if (region == null) {
	            return false;
	        }
	        if ((region.rows != null) && (region.rows[0] < 0 || region.rows[1] < 0)) {
	            return false;
	        }
	        if ((region.cols != null) && (region.cols[0] < 0 || region.cols[1] < 0)) {
	            return false;
	        }
	        return true;
	    };
	    Regions.isRegionValidForTable = function (region, numRows, numCols) {
	        if (region.rows != null && (region.rows[0] >= numRows || region.rows[1] >= numRows)) {
	            return false;
	        }
	        if (region.cols != null && (region.cols[0] >= numCols || region.cols[1] >= numCols)) {
	            return false;
	        }
	        return true;
	    };
	    Regions.joinStyledRegionGroups = function (selectedRegions, otherRegions, focusedCell) {
	        var regionGroups = [];
	        if (otherRegions != null) {
	            regionGroups = regionGroups.concat(otherRegions);
	        }
	        if (selectedRegions != null && selectedRegions.length > 0) {
	            regionGroups.push({
	                className: Classes.TABLE_SELECTION_REGION,
	                regions: selectedRegions,
	            });
	        }
	        if (focusedCell != null) {
	            regionGroups.push({
	                className: Classes.TABLE_FOCUS_REGION,
	                regions: [Regions.cell(focusedCell.row, focusedCell.col)],
	            });
	        }
	        return regionGroups;
	    };
	    /**
	     * Iterates over the cells within an `IRegion`, invoking the callback with
	     * each cell's coordinates.
	     */
	    Regions.eachCellInRegion = function (region, numRows, numCols, iteratee) {
	        var cardinality = Regions.getRegionCardinality(region);
	        switch (cardinality) {
	            case RegionCardinality.FULL_TABLE:
	                for (var row = 0; row < numRows; row++) {
	                    for (var col = 0; col < numCols; col++) {
	                        iteratee(row, col);
	                    }
	                }
	                break;
	            case RegionCardinality.FULL_COLUMNS:
	                for (var row = 0; row < numRows; row++) {
	                    for (var col = region.cols[0]; col <= region.cols[1]; col++) {
	                        iteratee(row, col);
	                    }
	                }
	                break;
	            case RegionCardinality.FULL_ROWS:
	                for (var row = region.rows[0]; row <= region.rows[1]; row++) {
	                    for (var col = 0; col < numCols; col++) {
	                        iteratee(row, col);
	                    }
	                }
	                break;
	            case RegionCardinality.CELLS:
	                for (var row = region.rows[0]; row <= region.rows[1]; row++) {
	                    for (var col = region.cols[0]; col <= region.cols[1]; col++) {
	                        iteratee(row, col);
	                    }
	                }
	                break;
	            default:
	                break;
	        }
	    };
	    Regions.regionsEqual = function (regionA, regionB) {
	        return Regions.intervalsEqual(regionA.rows, regionB.rows)
	            && Regions.intervalsEqual(regionA.cols, regionB.cols);
	    };
	    Regions.intervalsEqual = function (ivalA, ivalB) {
	        if (ivalA == null) {
	            return ivalB == null;
	        }
	        else if (ivalB == null) {
	            return false;
	        }
	        else {
	            return ivalA[0] === ivalB[0] && ivalA[1] === ivalB[1];
	        }
	    };
	    Regions.intervalContainsIndex = function (interval, index) {
	        if (interval == null) {
	            return false;
	        }
	        return interval[0] <= index && interval[1] >= index;
	    };
	    Regions.intervalOverlaps = function (ivalA, ivalB) {
	        if (ivalA == null || ivalB == null) {
	            return false;
	        }
	        if (ivalA[1] < ivalB[0] || ivalA[0] > ivalB[1]) {
	            return false;
	        }
	        return true;
	    };
	    Regions.rowFirstComparator = function (a, b) {
	        var rowDiff = a[0] - b[0];
	        return rowDiff === 0 ? a[1] - b[1] : rowDiff;
	    };
	    Regions.numericalComparator = function (a, b) {
	        return a - b;
	    };
	    Regions.normalizeInterval = function (coord, coord2) {
	        if (coord2 == null) {
	            coord2 = coord;
	        }
	        var interval = [coord, coord2];
	        interval.sort(Regions.numericalComparator);
	        return interval;
	    };
	    return Regions;
	}());
	exports.Regions = Regions;
	
	//# sourceMappingURL=regions.js.map


/***/ },
/* 25 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// HACKHACK: workaround for https://github.com/palantir/tslint/issues/1768
	// tslint:disable adjacent-overload-signatures
	/**
	 * A simple object for storing the client bounds of HTMLElements. Since
	 * ClientRects are immutable, this object enables editing and some simple
	 * manipulation methods.
	 */
	var Rect = (function () {
	    function Rect(left, top, width, height) {
	        this.left = left;
	        this.top = top;
	        this.width = width;
	        this.height = height;
	    }
	    /**
	     * Returns the smallest Rect that entirely contains the supplied rects
	     */
	    Rect.union = function (anyRect0, anyRect1) {
	        var rect0 = Rect.wrap(anyRect0);
	        var rect1 = Rect.wrap(anyRect1);
	        var top = Math.min(rect0.top, rect1.top);
	        var left = Math.min(rect0.left, rect1.left);
	        var bottom = Math.max(rect0.top + rect0.height, rect1.top + rect1.height);
	        var right = Math.max(rect0.left + rect0.width, rect1.left + rect1.width);
	        var height = bottom - top;
	        var width = right - left;
	        return new Rect(left, top, width, height);
	    };
	    /**
	     * Returns a new Rect that subtracts the origin of the second argument
	     * from the first.
	     */
	    Rect.subtractOrigin = function (anyRect0, anyRect1) {
	        var rect0 = Rect.wrap(anyRect0);
	        var rect1 = Rect.wrap(anyRect1);
	        return new Rect(rect0.left - rect1.left, rect0.top - rect1.top, rect0.width, rect0.height);
	    };
	    /**
	     * Returns the CSS properties representing the absolute positioning of
	     * this Rect.
	     */
	    Rect.style = function (rect) {
	        return {
	            height: rect.height + "px",
	            left: rect.left + "px",
	            position: "absolute",
	            top: rect.top + "px",
	            width: rect.width + "px",
	        };
	    };
	    /**
	     * Given a ClientRect or Rect object, returns a Rect object.
	     */
	    Rect.wrap = function (rect) {
	        if (rect instanceof Rect) {
	            return rect;
	        }
	        else {
	            return new Rect(rect.left, rect.top, rect.width, rect.height);
	        }
	    };
	    Rect.prototype.subtractOrigin = function (anyRect) {
	        return Rect.subtractOrigin(this, anyRect);
	    };
	    Rect.prototype.union = function (anyRect) {
	        return Rect.union(this, anyRect);
	    };
	    Rect.prototype.style = function () {
	        return Rect.style(this);
	    };
	    Rect.prototype.sizeStyle = function () {
	        return {
	            height: this.height + "px",
	            width: this.width + "px",
	        };
	    };
	    Rect.prototype.containsX = function (clientX) {
	        return clientX >= this.left && clientX <= this.left + this.width;
	    };
	    Rect.prototype.containsY = function (clientY) {
	        return clientY >= this.top && clientY <= this.top + this.height;
	    };
	    return Rect;
	}());
	Rect.ORIGIN = new Rect(0, 0, 0, 0);
	exports.Rect = Rect;
	
	//# sourceMappingURL=rect.js.map


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var React = __webpack_require__(9);
	var Classes = __webpack_require__(10);
	/**
	 * A React component that measures and rounds the size of its only child. This
	 * is necessary due to a Chrome bug that prevents scrolling when the size is
	 * changed to a fractional value. See this JSFiddle for a repro of the issue:
	 * https://jsfiddle.net/2rmz7p1d/5/
	 */
	var RoundSize = (function (_super) {
	    tslib_1.__extends(RoundSize, _super);
	    function RoundSize() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.setInternalRef = function (ref) { return _this.internalElement = ref; };
	        _this.setContainerRef = function (ref) { return _this.containerElement = ref; };
	        return _this;
	    }
	    RoundSize.prototype.render = function () {
	        return (React.createElement("div", { className: Classes.TABLE_ROUNDED_LAYOUT, ref: this.setContainerRef },
	            React.createElement("div", { className: Classes.TABLE_NO_LAYOUT, ref: this.setInternalRef }, React.Children.only(this.props.children))));
	    };
	    RoundSize.prototype.componentDidMount = function () {
	        this.copyRoundedSize();
	    };
	    RoundSize.prototype.componentDidUpdate = function () {
	        this.copyRoundedSize();
	    };
	    RoundSize.prototype.copyRoundedSize = function () {
	        if (this.internalElement == null || this.containerElement == null) {
	            return;
	        }
	        // measure the size of the internal children
	        var width = Math.round(this.internalElement.clientWidth) + "px";
	        var height = Math.round(this.internalElement.clientHeight) + "px";
	        // set the size of the container element with rounded values
	        this.containerElement.style.width = width;
	        this.containerElement.style.height = height;
	    };
	    return RoundSize;
	}(React.Component));
	exports.RoundSize = RoundSize;
	
	//# sourceMappingURL=roundSize.js.map


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(__webpack_require__(28));
	__export(__webpack_require__(29));
	
	//# sourceMappingURL=index.js.map


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(11);
	var React = __webpack_require__(9);
	var clipboard_1 = __webpack_require__(22);
	var regions_1 = __webpack_require__(24);
	var CopyCellsMenuItem = (function (_super) {
	    tslib_1.__extends(CopyCellsMenuItem, _super);
	    function CopyCellsMenuItem() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.handleClick = function () {
	            var _a = _this.props, context = _a.context, getCellData = _a.getCellData, onCopy = _a.onCopy;
	            var cells = context.getUniqueCells();
	            var sparse = regions_1.Regions.sparseMapCells(cells, getCellData);
	            var success = clipboard_1.Clipboard.copyCells(sparse);
	            if (onCopy != null) {
	                onCopy(success);
	            }
	        };
	        return _this;
	    }
	    CopyCellsMenuItem.prototype.render = function () {
	        return React.createElement(core_1.MenuItem, tslib_1.__assign({}, this.props, { onClick: this.handleClick }));
	    };
	    return CopyCellsMenuItem;
	}(React.Component));
	exports.CopyCellsMenuItem = CopyCellsMenuItem;
	
	//# sourceMappingURL=copyCellsMenuItem.js.map


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var regions_1 = __webpack_require__(24);
	var MenuContext = (function () {
	    function MenuContext(target, selectedRegions, numRows, numCols) {
	        this.target = target;
	        this.selectedRegions = selectedRegions;
	        this.numRows = numRows;
	        this.numCols = numCols;
	        this.regions = regions_1.Regions.containsRegion(selectedRegions, target) ? selectedRegions : [target];
	    }
	    MenuContext.prototype.getTarget = function () {
	        return this.target;
	    };
	    MenuContext.prototype.getSelectedRegions = function () {
	        return this.selectedRegions;
	    };
	    MenuContext.prototype.getRegions = function () {
	        return this.regions;
	    };
	    MenuContext.prototype.getUniqueCells = function () {
	        return regions_1.Regions.enumerateUniqueCells(this.regions, this.numRows, this.numCols);
	    };
	    return MenuContext;
	}());
	exports.MenuContext = MenuContext;
	
	//# sourceMappingURL=menuContext.js.map


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(9);
	var Classes = __webpack_require__(10);
	var draggable_1 = __webpack_require__(15);
	var Orientation;
	(function (Orientation) {
	    Orientation[Orientation["HORIZONTAL"] = 1] = "HORIZONTAL";
	    Orientation[Orientation["VERTICAL"] = 0] = "VERTICAL";
	})(Orientation = exports.Orientation || (exports.Orientation = {}));
	var ResizeHandle = (function (_super) {
	    tslib_1.__extends(ResizeHandle, _super);
	    function ResizeHandle() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.state = {
	            isDragging: false,
	        };
	        _this.handleActivate = function (event) {
	            _this.setState({ isDragging: true });
	            _this.props.onLayoutLock(true);
	            event.stopPropagation();
	            event.stopImmediatePropagation();
	            return true;
	        };
	        _this.handleDragMove = function (_event, coords) {
	            var orientationIndex = _this.props.orientation;
	            if (_this.props.onResizeMove != null) {
	                _this.props.onResizeMove(coords.offset[orientationIndex], coords.delta[orientationIndex]);
	            }
	        };
	        _this.handleDragEnd = function (_event, coords) {
	            var orientationIndex = _this.props.orientation;
	            _this.setState({ isDragging: false });
	            _this.props.onLayoutLock(false);
	            if (_this.props.onResizeMove != null) {
	                _this.props.onResizeMove(coords.offset[orientationIndex], coords.delta[orientationIndex]);
	            }
	            if (_this.props.onResizeEnd != null) {
	                _this.props.onResizeEnd(coords.offset[orientationIndex]);
	            }
	        };
	        _this.handleClick = function (_event) {
	            _this.setState({ isDragging: false });
	            _this.props.onLayoutLock(false);
	        };
	        _this.handleDoubleClick = function (_event) {
	            _this.setState({ isDragging: false });
	            _this.props.onLayoutLock(false);
	            if (_this.props.onDoubleClick != null) {
	                _this.props.onDoubleClick();
	            }
	        };
	        return _this;
	    }
	    ResizeHandle.prototype.render = function () {
	        var _a = this.props, onResizeMove = _a.onResizeMove, onResizeEnd = _a.onResizeEnd, onDoubleClick = _a.onDoubleClick, orientation = _a.orientation;
	        if (onResizeMove == null && onResizeEnd == null && onDoubleClick == null) {
	            return undefined;
	        }
	        var targetClasses = classNames(Classes.TABLE_RESIZE_HANDLE_TARGET, (_b = {},
	            _b[Classes.TABLE_DRAGGING] = this.state.isDragging,
	            _b[Classes.TABLE_RESIZE_HORIZONTAL] = orientation === Orientation.HORIZONTAL,
	            _b[Classes.TABLE_RESIZE_VERTICAL] = orientation === Orientation.VERTICAL,
	            _b));
	        var handleClasses = classNames(Classes.TABLE_RESIZE_HANDLE, (_c = {},
	            _c[Classes.TABLE_DRAGGING] = this.state.isDragging,
	            _c));
	        return (React.createElement(draggable_1.Draggable, { onActivate: this.handleActivate, onClick: this.handleClick, onDoubleClick: this.handleDoubleClick, onDragEnd: this.handleDragEnd, onDragMove: this.handleDragMove },
	            React.createElement("div", { className: targetClasses },
	                React.createElement("div", { className: handleClasses }))));
	        var _b, _c;
	    };
	    return ResizeHandle;
	}(React.Component));
	exports.ResizeHandle = ResizeHandle;
	
	//# sourceMappingURL=resizeHandle.js.map


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var PureRender = __webpack_require__(5);
	var React = __webpack_require__(9);
	var dragEvents_1 = __webpack_require__(17);
	var draggable_1 = __webpack_require__(15);
	var regions_1 = __webpack_require__(24);
	var DragSelectable = DragSelectable_1 = (function (_super) {
	    tslib_1.__extends(DragSelectable, _super);
	    function DragSelectable() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.handleActivate = function (event) {
	            if (!DragSelectable_1.isLeftClick(event)) {
	                return false;
	            }
	            var region = _this.props.locateClick(event);
	            if (!regions_1.Regions.isValid(region)) {
	                return false;
	            }
	            var focusCellCoordinates = DragSelectable_1.getFocusCellCoordinatesFromRegion(region);
	            _this.props.onFocus(focusCellCoordinates);
	            if (_this.props.selectedRegionTransform != null) {
	                region = _this.props.selectedRegionTransform(region, event);
	            }
	            var foundIndex = regions_1.Regions.findMatchingRegion(_this.props.selectedRegions, region);
	            if (foundIndex !== -1) {
	                // If re-clicking on an existing region, we either carefully
	                // remove it if the meta key is used or otherwise we clear the
	                // selection entirely.
	                if (dragEvents_1.DragEvents.isAdditive(event)) {
	                    var newSelectedRegions = _this.props.selectedRegions.slice();
	                    newSelectedRegions.splice(foundIndex, 1);
	                    _this.props.onSelection(newSelectedRegions);
	                }
	                else {
	                    _this.props.onSelection([]);
	                }
	                return false;
	            }
	            if (dragEvents_1.DragEvents.isAdditive(event) && _this.props.allowMultipleSelection) {
	                _this.props.onSelection(regions_1.Regions.add(_this.props.selectedRegions, region));
	            }
	            else {
	                _this.props.onSelection([region]);
	            }
	            return true;
	        };
	        _this.handleDragMove = function (event, coords) {
	            var region = (_this.props.allowMultipleSelection) ?
	                _this.props.locateDrag(event, coords) :
	                _this.props.locateClick(event);
	            if (!regions_1.Regions.isValid(region)) {
	                return;
	            }
	            if (_this.props.selectedRegionTransform != null) {
	                region = _this.props.selectedRegionTransform(region, event, coords);
	            }
	            _this.props.onSelection(regions_1.Regions.update(_this.props.selectedRegions, region));
	        };
	        _this.handleClick = function (event) {
	            if (!DragSelectable_1.isLeftClick(event)) {
	                return false;
	            }
	            var region = _this.props.locateClick(event);
	            if (!regions_1.Regions.isValid(region)) {
	                _this.props.onSelection([]);
	                return false;
	            }
	            if (_this.props.selectedRegionTransform != null) {
	                region = _this.props.selectedRegionTransform(region, event);
	            }
	            if (_this.props.selectedRegions.length > 0) {
	                _this.props.onSelection(regions_1.Regions.update(_this.props.selectedRegions, region));
	            }
	            else {
	                _this.props.onSelection([region]);
	            }
	            return false;
	        };
	        return _this;
	    }
	    DragSelectable.isLeftClick = function (event) {
	        return event.button === 0;
	    };
	    DragSelectable.getFocusCellCoordinatesFromRegion = function (region) {
	        var regionCardinality = regions_1.Regions.getRegionCardinality(region);
	        switch (regionCardinality) {
	            case regions_1.RegionCardinality.FULL_TABLE:
	                return { col: 0, row: 0 };
	            case regions_1.RegionCardinality.FULL_COLUMNS:
	                return { col: region.cols[0], row: 0 };
	            case regions_1.RegionCardinality.FULL_ROWS:
	                return { col: 0, row: region.rows[0] };
	            case regions_1.RegionCardinality.CELLS:
	                return { col: region.cols[0], row: region.rows[0] };
	            default:
	                return null;
	        }
	    };
	    DragSelectable.prototype.render = function () {
	        var draggableProps = this.getDraggableProps();
	        return (React.createElement(draggable_1.Draggable, tslib_1.__assign({}, draggableProps, { preventDefault: false }), this.props.children));
	    };
	    DragSelectable.prototype.getDraggableProps = function () {
	        return this.props.onSelection == null ? {} : {
	            onActivate: this.handleActivate,
	            onClick: this.handleClick,
	            onDragMove: this.handleDragMove,
	        };
	    };
	    return DragSelectable;
	}(React.Component));
	DragSelectable = DragSelectable_1 = tslib_1.__decorate([
	    PureRender
	], DragSelectable);
	exports.DragSelectable = DragSelectable;
	var DragSelectable_1;
	
	//# sourceMappingURL=selectable.js.map


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var PureRender = __webpack_require__(5);
	var React = __webpack_require__(9);
	var core_1 = __webpack_require__(11);
	var Classes = __webpack_require__(10);
	var loadableContent_1 = __webpack_require__(12);
	function HorizontalCellDivider() {
	    return React.createElement("div", { className: Classes.TABLE_HORIZONTAL_CELL_DIVIDER });
	}
	exports.HorizontalCellDivider = HorizontalCellDivider;
	var ColumnHeaderCell = (function (_super) {
	    tslib_1.__extends(ColumnHeaderCell, _super);
	    function ColumnHeaderCell() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.state = {
	            isActive: false,
	        };
	        _this.getPopoverStateChangeHandler = function (isActive) { return function () {
	            _this.setState({ isActive: isActive });
	        }; };
	        return _this;
	    }
	    /**
	     * This method determines if a `MouseEvent` was triggered on a target that
	     * should be used as the header click/drag target. This enables users of
	     * this component to render fully interactive components in their header
	     * cells without worry of selection or resize operations from capturing
	     * their mouse events.
	     */
	    ColumnHeaderCell.isHeaderMouseTarget = function (target) {
	        return target.classList.contains(Classes.TABLE_HEADER)
	            || target.classList.contains(Classes.TABLE_COLUMN_NAME)
	            || target.classList.contains(Classes.TABLE_INTERACTION_BAR)
	            || target.classList.contains(Classes.TABLE_HEADER_CONTENT);
	    };
	    ColumnHeaderCell.prototype.render = function () {
	        var _a = this.props, className = _a.className, isActive = _a.isActive, isColumnSelected = _a.isColumnSelected, loading = _a.loading, resizeHandle = _a.resizeHandle, style = _a.style;
	        var classes = classNames(Classes.TABLE_HEADER, (_b = {},
	            _b[Classes.TABLE_HEADER_ACTIVE] = isActive || this.state.isActive,
	            _b[Classes.TABLE_HEADER_SELECTED] = isColumnSelected,
	            _b[core_1.Classes.LOADING] = loading,
	            _b), className);
	        return (React.createElement("div", { className: classes, style: style },
	            this.renderName(),
	            this.maybeRenderContent(),
	            loading ? undefined : resizeHandle));
	        var _b;
	    };
	    ColumnHeaderCell.prototype.renderContextMenu = function (_event) {
	        return this.props.menu;
	    };
	    ColumnHeaderCell.prototype.renderName = function () {
	        var _a = this.props, loading = _a.loading, name = _a.name, renderName = _a.renderName, useInteractionBar = _a.useInteractionBar;
	        var dropdownMenu = this.maybeRenderDropdownMenu();
	        var defaultName = React.createElement("div", { className: Classes.TABLE_TRUNCATED_TEXT }, name);
	        var nameComponent = (React.createElement(loadableContent_1.LoadableContent, { loading: loading, variableLength: true }, renderName == null ? defaultName : renderName(name)));
	        if (useInteractionBar) {
	            return (React.createElement("div", { className: Classes.TABLE_COLUMN_NAME, title: name },
	                React.createElement("div", { className: Classes.TABLE_INTERACTION_BAR }, dropdownMenu),
	                React.createElement(HorizontalCellDivider, null),
	                React.createElement("div", { className: Classes.TABLE_COLUMN_NAME_TEXT }, nameComponent)));
	        }
	        else {
	            return (React.createElement("div", { className: Classes.TABLE_COLUMN_NAME, title: name },
	                dropdownMenu,
	                React.createElement("div", { className: Classes.TABLE_COLUMN_NAME_TEXT }, nameComponent)));
	        }
	    };
	    ColumnHeaderCell.prototype.maybeRenderContent = function () {
	        if (this.props.children === null) {
	            return undefined;
	        }
	        return (React.createElement("div", { className: Classes.TABLE_HEADER_CONTENT }, this.props.children));
	    };
	    ColumnHeaderCell.prototype.maybeRenderDropdownMenu = function () {
	        var _a = this.props, menu = _a.menu, menuIconName = _a.menuIconName;
	        if (menu == null) {
	            return undefined;
	        }
	        var popoverTargetClasses = classNames(core_1.Classes.ICON_STANDARD, core_1.Classes.iconClass(menuIconName));
	        var constraints = [{
	                attachment: "together",
	                pin: true,
	                to: "window",
	            }];
	        return (React.createElement("div", { className: Classes.TABLE_TH_MENU_CONTAINER },
	            React.createElement("div", { className: Classes.TABLE_TH_MENU_CONTAINER_BACKGROUND }),
	            React.createElement(core_1.Popover, { tetherOptions: { constraints: constraints }, content: menu, position: core_1.Position.BOTTOM, className: Classes.TABLE_TH_MENU, popoverDidOpen: this.getPopoverStateChangeHandler(true), popoverWillClose: this.getPopoverStateChangeHandler(false), useSmartArrowPositioning: true },
	                React.createElement("span", { className: popoverTargetClasses }))));
	    };
	    return ColumnHeaderCell;
	}(React.Component));
	ColumnHeaderCell.defaultProps = {
	    isActive: false,
	    menuIconName: "chevron-down",
	    useInteractionBar: false,
	};
	ColumnHeaderCell = tslib_1.__decorate([
	    core_1.ContextMenuTarget,
	    PureRender
	], ColumnHeaderCell);
	exports.ColumnHeaderCell = ColumnHeaderCell;
	
	//# sourceMappingURL=columnHeaderCell.js.map


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(9);
	var core_1 = __webpack_require__(11);
	var Classes = __webpack_require__(10);
	var loadableContent_1 = __webpack_require__(12);
	var RowHeaderCell = (function (_super) {
	    tslib_1.__extends(RowHeaderCell, _super);
	    function RowHeaderCell() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.state = {
	            isActive: false,
	        };
	        return _this;
	    }
	    RowHeaderCell.prototype.render = function () {
	        var _a = this.props, className = _a.className, isActive = _a.isActive, isRowSelected = _a.isRowSelected, loading = _a.loading, name = _a.name, resizeHandle = _a.resizeHandle, style = _a.style;
	        var rowHeaderClasses = classNames(Classes.TABLE_HEADER, (_b = {},
	            _b[core_1.Classes.LOADING] = loading,
	            _b[Classes.TABLE_HEADER_ACTIVE] = isActive || this.state.isActive,
	            _b[Classes.TABLE_HEADER_SELECTED] = isRowSelected,
	            _b), className);
	        var loadableContentDivClasses = classNames(Classes.TABLE_ROW_NAME_TEXT, Classes.TABLE_TRUNCATED_TEXT);
	        return (React.createElement("div", { className: rowHeaderClasses, style: style },
	            React.createElement("div", { className: Classes.TABLE_ROW_NAME },
	                React.createElement(loadableContent_1.LoadableContent, { loading: loading },
	                    React.createElement("div", { className: loadableContentDivClasses }, name))),
	            this.props.children,
	            loading ? undefined : resizeHandle));
	        var _b;
	    };
	    RowHeaderCell.prototype.renderContextMenu = function (_event) {
	        return this.props.menu;
	    };
	    return RowHeaderCell;
	}(React.Component));
	RowHeaderCell = tslib_1.__decorate([
	    core_1.ContextMenuTarget
	], RowHeaderCell);
	exports.RowHeaderCell = RowHeaderCell;
	
	//# sourceMappingURL=rowHeaderCell.js.map


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(11);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(9);
	var Classes = __webpack_require__(10);
	var EditableName = (function (_super) {
	    tslib_1.__extends(EditableName, _super);
	    function EditableName() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    EditableName.prototype.render = function () {
	        var _a = this.props, className = _a.className, intent = _a.intent, name = _a.name, onCancel = _a.onCancel, onChange = _a.onChange, onConfirm = _a.onConfirm;
	        return (React.createElement(core_1.EditableText, { className: classNames(className, Classes.TABLE_EDITABLE_NAME), defaultValue: name, intent: intent, minWidth: null, onCancel: onCancel, onChange: onChange, onConfirm: onConfirm, placeholder: "", selectAllOnFocus: true }));
	    };
	    return EditableName;
	}(React.Component));
	exports.EditableName = EditableName;
	
	//# sourceMappingURL=editableName.js.map


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(11);
	var core_2 = __webpack_require__(11);
	var classNames = __webpack_require__(4);
	var PureRender = __webpack_require__(5);
	var React = __webpack_require__(9);
	var column_1 = __webpack_require__(20);
	var Classes = __webpack_require__(10);
	var clipboard_1 = __webpack_require__(22);
	var grid_1 = __webpack_require__(23);
	var utils_1 = __webpack_require__(16);
	var columnHeader_1 = __webpack_require__(36);
	var columnHeaderCell_1 = __webpack_require__(32);
	var rowHeader_1 = __webpack_require__(38);
	var resizeSensor_1 = __webpack_require__(39);
	var guides_1 = __webpack_require__(40);
	var regions_1 = __webpack_require__(41);
	var locator_1 = __webpack_require__(42);
	var regions_2 = __webpack_require__(24);
	var tableBody_1 = __webpack_require__(43);
	var Table = Table_1 = (function (_super) {
	    tslib_1.__extends(Table, _super);
	    function Table(props, context) {
	        var _this = _super.call(this, props, context) || this;
	        _this.handleCopy = function (e) {
	            var grid = _this.grid;
	            var _a = _this.props, getCellClipboardData = _a.getCellClipboardData, onCopy = _a.onCopy;
	            var selectedRegions = _this.state.selectedRegions;
	            if (getCellClipboardData == null) {
	                return;
	            }
	            // prevent "real" copy from being called
	            e.preventDefault();
	            e.stopPropagation();
	            var cells = regions_2.Regions.enumerateUniqueCells(selectedRegions, grid.numRows, grid.numCols);
	            var sparse = regions_2.Regions.sparseMapCells(cells, getCellClipboardData);
	            if (sparse != null) {
	                var success = clipboard_1.Clipboard.copyCells(sparse);
	                core_1.Utils.safeInvoke(onCopy, success);
	            }
	        };
	        _this.selectAll = function () {
	            var selectionHandler = _this.getEnabledSelectionHandler(regions_2.RegionCardinality.FULL_TABLE);
	            // clicking on upper left hand corner sets selection to "all"
	            // regardless of current selection state (clicking twice does not deselect table)
	            selectionHandler([regions_2.Regions.table()]);
	        };
	        _this.handleSelectAllHotkey = function (e) {
	            // prevent "real" select all from happening as well
	            e.preventDefault();
	            e.stopPropagation();
	            _this.selectAll();
	        };
	        _this.columnHeaderCellRenderer = function (columnIndex) {
	            var props = _this.getColumnProps(columnIndex);
	            var columnLoading = _this.hasLoadingOption(props.loadingOptions, regions_2.ColumnLoadingOption.HEADER);
	            var renderColumnHeader = props.renderColumnHeader;
	            if (renderColumnHeader != null) {
	                var columnHeader = renderColumnHeader(columnIndex);
	                var columnHeaderLoading = columnHeader.props.loading;
	                return React.cloneElement(columnHeader, {
	                    loading: columnHeaderLoading != null ? columnHeaderLoading : columnLoading,
	                });
	            }
	            else if (props.name != null) {
	                return React.createElement(columnHeaderCell_1.ColumnHeaderCell, tslib_1.__assign({}, props, { loading: columnLoading }));
	            }
	            else {
	                return React.createElement(columnHeaderCell_1.ColumnHeaderCell, tslib_1.__assign({}, props, { loading: columnLoading, name: utils_1.Utils.toBase26Alpha(columnIndex) }));
	            }
	        };
	        _this.bodyCellRenderer = function (rowIndex, columnIndex) {
	            var columnProps = _this.getColumnProps(columnIndex);
	            var cell = columnProps.renderCell(rowIndex, columnIndex);
	            var cellLoading = cell.props.loading;
	            var loading = cellLoading != null
	                ? cellLoading
	                : _this.hasLoadingOption(columnProps.loadingOptions, regions_2.ColumnLoadingOption.CELLS);
	            return React.cloneElement(cell, tslib_1.__assign({}, columnProps, { loading: loading }));
	        };
	        _this.handleFocusMoveLeft = function (e) { return _this.handleFocusMove(e, "left"); };
	        _this.handleFocusMoveRight = function (e) { return _this.handleFocusMove(e, "right"); };
	        _this.handleFocusMoveUp = function (e) { return _this.handleFocusMove(e, "up"); };
	        _this.handleFocusMoveDown = function (e) { return _this.handleFocusMove(e, "down"); };
	        _this.handleColumnWidthChanged = function (columnIndex, width) {
	            var selectedRegions = _this.state.selectedRegions;
	            var columnWidths = _this.state.columnWidths.slice();
	            if (regions_2.Regions.hasFullTable(selectedRegions)) {
	                for (var col = 0; col < columnWidths.length; col++) {
	                    columnWidths[col] = width;
	                }
	            }
	            if (regions_2.Regions.hasFullColumn(selectedRegions, columnIndex)) {
	                regions_2.Regions.eachUniqueFullColumn(selectedRegions, function (col) {
	                    columnWidths[col] = width;
	                });
	            }
	            else {
	                columnWidths[columnIndex] = width;
	            }
	            _this.invalidateGrid();
	            _this.setState({ columnWidths: columnWidths });
	            var onColumnWidthChanged = _this.props.onColumnWidthChanged;
	            if (onColumnWidthChanged != null) {
	                onColumnWidthChanged(columnIndex, width);
	            }
	        };
	        _this.handleRowHeightChanged = function (rowIndex, height) {
	            var selectedRegions = _this.state.selectedRegions;
	            var rowHeights = _this.state.rowHeights.slice();
	            if (regions_2.Regions.hasFullTable(selectedRegions)) {
	                for (var row = 0; row < rowHeights.length; row++) {
	                    rowHeights[row] = height;
	                }
	            }
	            if (regions_2.Regions.hasFullRow(selectedRegions, rowIndex)) {
	                regions_2.Regions.eachUniqueFullRow(selectedRegions, function (row) {
	                    rowHeights[row] = height;
	                });
	            }
	            else {
	                rowHeights[rowIndex] = height;
	            }
	            _this.invalidateGrid();
	            _this.setState({ rowHeights: rowHeights });
	            var onRowHeightChanged = _this.props.onRowHeightChanged;
	            if (onRowHeightChanged != null) {
	                onRowHeightChanged(rowIndex, height);
	            }
	        };
	        _this.handleRootScroll = function (_event) {
	            // Bug #211 - Native browser text selection events can cause the root
	            // element to scroll even though it has a overflow:hidden style. The
	            // only viable solution to this is to unscroll the element after the
	            // browser scrolls it.
	            if (_this.rootTableElement != null) {
	                _this.rootTableElement.scrollLeft = 0;
	                _this.rootTableElement.scrollTop = 0;
	            }
	        };
	        _this.handleBodyScroll = function (event) {
	            // Prevent the event from propagating to avoid a resize event on the
	            // resize sensor.
	            event.stopPropagation();
	            var _a = _this.state, locator = _a.locator, isLayoutLocked = _a.isLayoutLocked;
	            if (locator != null && !isLayoutLocked) {
	                var viewportRect = locator.getViewportRect();
	                _this.setState({ viewportRect: viewportRect });
	            }
	        };
	        _this.handleColumnResizeGuide = function (verticalGuides) {
	            _this.setState({ verticalGuides: verticalGuides });
	        };
	        _this.handleRowResizeGuide = function (horizontalGuides) {
	            _this.setState({ horizontalGuides: horizontalGuides });
	        };
	        _this.clearSelection = function (_selectedRegions) {
	            _this.handleSelection([]);
	        };
	        // no good way to call arrow-key keyboard events from tests
	        /* istanbul ignore next */
	        _this.handleFocusMove = function (e, direction) {
	            e.preventDefault();
	            e.stopPropagation();
	            var focusedCell = _this.state.focusedCell;
	            var newFocusedCell = { col: focusedCell.col, row: focusedCell.row };
	            var grid = _this.grid;
	            switch (direction) {
	                case "up":
	                    newFocusedCell.row -= 1;
	                    break;
	                case "down":
	                    newFocusedCell.row += 1;
	                    break;
	                case "left":
	                    newFocusedCell.col -= 1;
	                    break;
	                case "right":
	                    newFocusedCell.col += 1;
	                    break;
	                default:
	                    break;
	            }
	            if (newFocusedCell.row < 0 || newFocusedCell.row >= grid.numRows ||
	                newFocusedCell.col < 0 || newFocusedCell.col >= grid.numCols) {
	                return;
	            }
	            // change selection to match new focus cell location
	            var newSelectionRegions = [regions_2.Regions.cell(newFocusedCell.row, newFocusedCell.col)];
	            _this.handleSelection(newSelectionRegions);
	            _this.handleFocus(newFocusedCell);
	        };
	        _this.handleFocus = function (focusedCell) {
	            if (!_this.props.enableFocus) {
	                // don't set focus state if focus is not allowed
	                return;
	            }
	            // only set focused cell state if not specified in props
	            if (_this.props.focusedCell == null) {
	                _this.setState({ focusedCell: focusedCell });
	            }
	            core_1.Utils.safeInvoke(_this.props.onFocus, focusedCell);
	        };
	        _this.handleSelection = function (selectedRegions) {
	            // only set selectedRegions state if not specified in props
	            if (_this.props.selectedRegions == null) {
	                _this.setState({ selectedRegions: selectedRegions });
	            }
	            var onSelection = _this.props.onSelection;
	            if (onSelection != null) {
	                onSelection(selectedRegions);
	            }
	        };
	        _this.handleLayoutLock = function (isLayoutLocked) {
	            if (isLayoutLocked === void 0) { isLayoutLocked = false; }
	            _this.setState({ isLayoutLocked: isLayoutLocked });
	        };
	        _this.hasLoadingOption = function (loadingOptions, loadingOption) {
	            if (loadingOptions == null) {
	                return undefined;
	            }
	            return loadingOptions.indexOf(loadingOption) >= 0;
	        };
	        _this.setBodyRef = function (ref) { return _this.bodyElement = ref; };
	        _this.setMenuRef = function (ref) { return _this.menuElement = ref; };
	        _this.setRootTableRef = function (ref) { return _this.rootTableElement = ref; };
	        _this.setRowHeaderRef = function (ref) { return _this.rowHeaderElement = ref; };
	        var _a = _this.props, defaultRowHeight = _a.defaultRowHeight, defaultColumnWidth = _a.defaultColumnWidth, numRows = _a.numRows, columnWidths = _a.columnWidths, rowHeights = _a.rowHeights, children = _a.children;
	        _this.childrenArray = React.Children.toArray(children);
	        _this.columnIdToIndex = Table_1.createColumnIdIndex(_this.childrenArray);
	        // Create height/width arrays using the lengths from props and
	        // children, the default values from props, and finally any sparse
	        // arrays passed into props.
	        var newColumnWidths = _this.childrenArray.map(function () { return defaultColumnWidth; });
	        newColumnWidths = utils_1.Utils.assignSparseValues(newColumnWidths, columnWidths);
	        var newRowHeights = utils_1.Utils.times(numRows, function () { return defaultRowHeight; });
	        newRowHeights = utils_1.Utils.assignSparseValues(newRowHeights, rowHeights);
	        var selectedRegions = (props.selectedRegions == null) ? [] : props.selectedRegions;
	        var focusedCell;
	        if (props.enableFocus) {
	            if (props.focusedCell != null) {
	                focusedCell = props.focusedCell;
	            }
	            else {
	                focusedCell = { col: 0, row: 0 };
	            }
	        }
	        _this.state = {
	            columnWidths: newColumnWidths,
	            focusedCell: focusedCell,
	            isLayoutLocked: false,
	            rowHeights: newRowHeights,
	            selectedRegions: selectedRegions,
	        };
	        return _this;
	    }
	    Table.createColumnIdIndex = function (children) {
	        var columnIdToIndex = {};
	        for (var i = 0; i < children.length; i++) {
	            var key = children[i].props.id;
	            if (key != null) {
	                columnIdToIndex[String(key)] = i;
	            }
	        }
	        return columnIdToIndex;
	    };
	    Table.prototype.componentWillReceiveProps = function (nextProps) {
	        var _this = this;
	        var defaultRowHeight = nextProps.defaultRowHeight, defaultColumnWidth = nextProps.defaultColumnWidth, columnWidths = nextProps.columnWidths, focusedCell = nextProps.focusedCell, rowHeights = nextProps.rowHeights, children = nextProps.children, numRows = nextProps.numRows, selectedRegions = nextProps.selectedRegions;
	        var newChildArray = React.Children.toArray(children);
	        // Try to maintain widths of columns by looking up the width of the
	        // column that had the same `ID` prop. If none is found, use the
	        // previous width at the same index.
	        var previousColumnWidths = newChildArray.map(function (child, index) {
	            var mappedIndex = _this.columnIdToIndex[child.props.id];
	            return _this.state.columnWidths[mappedIndex != null ? mappedIndex : index];
	        });
	        // Make sure the width/height arrays have the correct length, but keep
	        // as many existing widths/heights when possible. Also, apply the
	        // sparse width/heights from props.
	        var newColumnWidths = this.state.columnWidths;
	        newColumnWidths = utils_1.Utils.arrayOfLength(newColumnWidths, newChildArray.length, defaultColumnWidth);
	        newColumnWidths = utils_1.Utils.assignSparseValues(newColumnWidths, previousColumnWidths);
	        newColumnWidths = utils_1.Utils.assignSparseValues(newColumnWidths, columnWidths);
	        var newRowHeights = this.state.rowHeights;
	        newRowHeights = utils_1.Utils.arrayOfLength(newRowHeights, numRows, defaultRowHeight);
	        newRowHeights = utils_1.Utils.assignSparseValues(newRowHeights, rowHeights);
	        var numCols = newColumnWidths.length;
	        var newSelectedRegions = selectedRegions;
	        if (selectedRegions == null) {
	            // if we're in uncontrolled mode, filter out all selected regions that don't
	            // fit in the current new table dimensions
	            newSelectedRegions = this.state.selectedRegions.filter(function (region) {
	                return regions_2.Regions.isRegionValidForTable(region, numRows, numCols);
	            });
	        }
	        var newFocusedCellCoordinates = (focusedCell == null)
	            ? this.state.focusedCell
	            : focusedCell;
	        this.childrenArray = newChildArray;
	        this.columnIdToIndex = Table_1.createColumnIdIndex(this.childrenArray);
	        this.invalidateGrid();
	        this.setState({
	            columnWidths: newColumnWidths,
	            focusedCell: newFocusedCellCoordinates,
	            rowHeights: newRowHeights,
	            selectedRegions: newSelectedRegions,
	        });
	    };
	    Table.prototype.render = function () {
	        var _a = this.props, className = _a.className, isRowHeaderShown = _a.isRowHeaderShown;
	        this.validateGrid();
	        return (React.createElement("div", { className: classNames(Classes.TABLE_CONTAINER, className), ref: this.setRootTableRef, onScroll: this.handleRootScroll },
	            React.createElement("div", { className: Classes.TABLE_TOP_CONTAINER },
	                isRowHeaderShown ? this.renderMenu() : undefined,
	                this.renderColumnHeader()),
	            React.createElement("div", { className: Classes.TABLE_BOTTOM_CONTAINER },
	                isRowHeaderShown ? this.renderRowHeader() : undefined,
	                this.renderBody())));
	    };
	    Table.prototype.renderHotkeys = function () {
	        var hotkeys = [this.maybeRenderCopyHotkey(), this.maybeRenderSelectAllHotkey(), this.maybeRenderFocusHotkeys()];
	        return (React.createElement(core_2.Hotkeys, null, hotkeys.filter(function (element) { return element !== undefined; })));
	    };
	    /**
	     * When the component mounts, the HTML Element refs will be available, so
	     * we constructor the Locator, which queries the elements' bounding
	     * ClientRects.
	     */
	    Table.prototype.componentDidMount = function () {
	        var _this = this;
	        this.validateGrid();
	        var locator = new locator_1.Locator(this.rootTableElement, this.bodyElement, this.grid);
	        var viewportRect = locator.getViewportRect();
	        this.setState({ locator: locator, viewportRect: viewportRect });
	        this.resizeSensorDetach = resizeSensor_1.ResizeSensor.attach(this.rootTableElement, function () {
	            if (!_this.state.isLayoutLocked) {
	                _this.setState({ viewportRect: locator.getViewportRect() });
	            }
	        });
	        this.syncMenuWidth();
	    };
	    Table.prototype.componentWillUnmount = function () {
	        if (this.resizeSensorDetach != null) {
	            this.resizeSensorDetach();
	            delete this.resizeSensorDetach;
	        }
	    };
	    Table.prototype.componentDidUpdate = function () {
	        var locator = this.state.locator;
	        if (locator != null) {
	            this.validateGrid();
	            locator.setGrid(this.grid);
	        }
	        this.syncMenuWidth();
	    };
	    Table.prototype.validateProps = function (props) {
	        var WARNING_MESSAGE = "Children of Table must be Columns";
	        React.Children.forEach(props.children, function (child) {
	            // save as a variable so that union type narrowing works
	            var cType = child.type;
	            if (typeof cType === "string") {
	                console.warn(WARNING_MESSAGE);
	            }
	            else {
	                var isColumn = cType.prototype === column_1.Column.prototype || column_1.Column.prototype.isPrototypeOf(cType);
	                if (!isColumn) {
	                    console.warn(WARNING_MESSAGE);
	                }
	            }
	        });
	    };
	    Table.prototype.renderMenu = function () {
	        var classes = classNames(Classes.TABLE_MENU, (_a = {},
	            _a[Classes.TABLE_SELECTION_ENABLED] = this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_TABLE),
	            _a));
	        return (React.createElement("div", { className: classes, ref: this.setMenuRef, onClick: this.selectAll }, this.maybeRenderMenuRegions()));
	        var _a;
	    };
	    Table.prototype.syncMenuWidth = function () {
	        var _a = this, menuElement = _a.menuElement, rowHeaderElement = _a.rowHeaderElement;
	        if (menuElement != null && rowHeaderElement != null) {
	            var width = rowHeaderElement.getBoundingClientRect().width;
	            menuElement.style.width = width + "px";
	        }
	    };
	    Table.prototype.getColumnProps = function (columnIndex) {
	        var column = this.childrenArray[columnIndex];
	        return column.props;
	    };
	    Table.prototype.renderColumnHeader = function () {
	        var grid = this.grid;
	        var _a = this.state, locator = _a.locator, selectedRegions = _a.selectedRegions, viewportRect = _a.viewportRect;
	        var _b = this.props, allowMultipleSelection = _b.allowMultipleSelection, fillBodyWithGhostCells = _b.fillBodyWithGhostCells, isColumnResizable = _b.isColumnResizable, loadingOptions = _b.loadingOptions, maxColumnWidth = _b.maxColumnWidth, minColumnWidth = _b.minColumnWidth, selectedRegionTransform = _b.selectedRegionTransform;
	        var classes = classNames(Classes.TABLE_COLUMN_HEADERS, (_c = {},
	            _c[Classes.TABLE_SELECTION_ENABLED] = this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_COLUMNS),
	            _c));
	        var columnIndices = grid.getColumnIndicesInRect(viewportRect, fillBodyWithGhostCells);
	        return (React.createElement("div", { className: classes },
	            React.createElement(columnHeader_1.ColumnHeader, tslib_1.__assign({ allowMultipleSelection: allowMultipleSelection, cellRenderer: this.columnHeaderCellRenderer, grid: grid, isResizable: isColumnResizable, loading: this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.COLUMN_HEADERS), locator: locator, maxColumnWidth: maxColumnWidth, minColumnWidth: minColumnWidth, onColumnWidthChanged: this.handleColumnWidthChanged, onFocus: this.handleFocus, onLayoutLock: this.handleLayoutLock, onResizeGuide: this.handleColumnResizeGuide, onSelection: this.getEnabledSelectionHandler(regions_2.RegionCardinality.FULL_COLUMNS), selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, viewportRect: viewportRect }, columnIndices), this.props.children),
	            this.maybeRenderColumnHeaderRegions()));
	        var _c;
	    };
	    Table.prototype.renderRowHeader = function () {
	        var grid = this.grid;
	        var _a = this.state, locator = _a.locator, selectedRegions = _a.selectedRegions, viewportRect = _a.viewportRect;
	        var _b = this.props, allowMultipleSelection = _b.allowMultipleSelection, fillBodyWithGhostCells = _b.fillBodyWithGhostCells, isRowResizable = _b.isRowResizable, loadingOptions = _b.loadingOptions, maxRowHeight = _b.maxRowHeight, minRowHeight = _b.minRowHeight, renderRowHeader = _b.renderRowHeader, selectedRegionTransform = _b.selectedRegionTransform;
	        var classes = classNames(Classes.TABLE_ROW_HEADERS, (_c = {},
	            _c[Classes.TABLE_SELECTION_ENABLED] = this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_ROWS),
	            _c));
	        var rowIndices = grid.getRowIndicesInRect(viewportRect, fillBodyWithGhostCells);
	        return (React.createElement("div", { className: classes, ref: this.setRowHeaderRef },
	            React.createElement(rowHeader_1.RowHeader, tslib_1.__assign({ allowMultipleSelection: allowMultipleSelection, grid: grid, locator: locator, isResizable: isRowResizable, loading: this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.ROW_HEADERS), maxRowHeight: maxRowHeight, minRowHeight: minRowHeight, onFocus: this.handleFocus, onLayoutLock: this.handleLayoutLock, onResizeGuide: this.handleRowResizeGuide, onRowHeightChanged: this.handleRowHeightChanged, onSelection: this.getEnabledSelectionHandler(regions_2.RegionCardinality.FULL_ROWS), renderRowHeader: renderRowHeader, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, viewportRect: viewportRect }, rowIndices)),
	            this.maybeRenderRowHeaderRegions()));
	        var _c;
	    };
	    Table.prototype.renderBody = function () {
	        var grid = this.grid;
	        var _a = this.props, allowMultipleSelection = _a.allowMultipleSelection, fillBodyWithGhostCells = _a.fillBodyWithGhostCells, loadingOptions = _a.loadingOptions, renderBodyContextMenu = _a.renderBodyContextMenu, selectedRegionTransform = _a.selectedRegionTransform;
	        var _b = this.state, locator = _b.locator, selectedRegions = _b.selectedRegions, viewportRect = _b.viewportRect, verticalGuides = _b.verticalGuides, horizontalGuides = _b.horizontalGuides;
	        var style = grid.getRect().sizeStyle();
	        var rowIndices = grid.getRowIndicesInRect(viewportRect, fillBodyWithGhostCells);
	        var columnIndices = grid.getColumnIndicesInRect(viewportRect, fillBodyWithGhostCells);
	        var noVerticalScroll = fillBodyWithGhostCells &&
	            grid.isGhostIndex(rowIndices.rowIndexEnd, 0) &&
	            viewportRect != null && viewportRect.top === 0 ||
	            this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.ROW_HEADERS);
	        var noHorizontalScroll = fillBodyWithGhostCells &&
	            grid.isGhostIndex(0, columnIndices.columnIndexEnd) &&
	            viewportRect != null && viewportRect.left === 0 ||
	            this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.COLUMN_HEADERS);
	        // disable scroll for ghost cells
	        var classes = classNames(Classes.TABLE_BODY, (_c = {},
	            _c[Classes.TABLE_NO_HORIZONTAL_SCROLL] = noHorizontalScroll,
	            _c[Classes.TABLE_NO_VERTICAL_SCROLL] = noVerticalScroll,
	            _c[Classes.TABLE_SELECTION_ENABLED] = this.isSelectionModeEnabled(regions_2.RegionCardinality.CELLS),
	            _c));
	        return (React.createElement("div", { className: classes, onScroll: this.handleBodyScroll, ref: this.setBodyRef },
	            React.createElement("div", { className: Classes.TABLE_BODY_SCROLL_CLIENT, style: style },
	                React.createElement(tableBody_1.TableBody, tslib_1.__assign({ allowMultipleSelection: allowMultipleSelection, cellRenderer: this.bodyCellRenderer, grid: grid, loading: this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.CELLS), locator: locator, onFocus: this.handleFocus, onSelection: this.getEnabledSelectionHandler(regions_2.RegionCardinality.CELLS), renderBodyContextMenu: renderBodyContextMenu, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, viewportRect: viewportRect }, rowIndices, columnIndices)),
	                this.maybeRenderBodyRegions(),
	                React.createElement(guides_1.GuideLayer, { className: Classes.TABLE_RESIZE_GUIDES, verticalGuides: verticalGuides, horizontalGuides: horizontalGuides }))));
	        var _c;
	    };
	    Table.prototype.isGuidesShowing = function () {
	        return this.state.verticalGuides != null || this.state.horizontalGuides != null;
	    };
	    Table.prototype.isSelectionModeEnabled = function (selectionMode) {
	        return this.props.selectionModes.indexOf(selectionMode) >= 0;
	    };
	    Table.prototype.getEnabledSelectionHandler = function (selectionMode) {
	        if (!this.isSelectionModeEnabled(selectionMode)) {
	            // If the selection mode isn't enabled, return a callback that
	            // will clear the selection. For example, if row selection is
	            // disabled, clicking on the row header will clear the table's
	            // selection. If all selection modes are enabled, clicking on the
	            // same region twice will clear the selection.
	            return this.clearSelection;
	        }
	        else {
	            return this.handleSelection;
	        }
	    };
	    Table.prototype.invalidateGrid = function () {
	        this.grid = null;
	    };
	    Table.prototype.validateGrid = function () {
	        if (this.grid == null) {
	            var _a = this.props, defaultRowHeight = _a.defaultRowHeight, defaultColumnWidth = _a.defaultColumnWidth;
	            var _b = this.state, rowHeights = _b.rowHeights, columnWidths = _b.columnWidths;
	            this.grid = new grid_1.Grid(rowHeights, columnWidths, grid_1.Grid.DEFAULT_BLEED, defaultRowHeight, defaultColumnWidth);
	        }
	    };
	    /**
	     * Renders a `RegionLayer`, applying styles to the regions using the
	     * supplied `IRegionStyler`. `RegionLayer` is a `PureRender` component, so
	     * the `IRegionStyler` should be a new instance on every render if we
	     * intend to redraw the region layer.
	     */
	    Table.prototype.maybeRenderRegions = function (getRegionStyle) {
	        if (this.isGuidesShowing()) {
	            return undefined;
	        }
	        var regionGroups = regions_2.Regions.joinStyledRegionGroups(this.state.selectedRegions, this.props.styledRegionGroups, this.state.focusedCell);
	        return regionGroups.map(function (regionGroup, index) {
	            return (React.createElement(regions_1.RegionLayer, { className: classNames(regionGroup.className), key: index, regions: regionGroup.regions, getRegionStyle: getRegionStyle }));
	        });
	    };
	    Table.prototype.maybeRenderCopyHotkey = function () {
	        var getCellClipboardData = this.props.getCellClipboardData;
	        if (getCellClipboardData != null) {
	            return (React.createElement(core_2.Hotkey, { key: "copy-hotkey", label: "Copy selected table cells", group: "Table", combo: "mod+c", onKeyDown: this.handleCopy }));
	        }
	        else {
	            return undefined;
	        }
	    };
	    Table.prototype.maybeRenderFocusHotkeys = function () {
	        var enableFocus = this.props.enableFocus;
	        if (enableFocus != null) {
	            return [
	                React.createElement(core_2.Hotkey, { key: "move left", label: "Move focus cell left", group: "Table", combo: "left", onKeyDown: this.handleFocusMoveLeft }),
	                React.createElement(core_2.Hotkey, { key: "move right", label: "Move focus cell right", group: "Table", combo: "right", onKeyDown: this.handleFocusMoveRight }),
	                React.createElement(core_2.Hotkey, { key: "move up", label: "Move focus cell up", group: "Table", combo: "up", onKeyDown: this.handleFocusMoveUp }),
	                React.createElement(core_2.Hotkey, { key: "move down", label: "Move focus cell down", group: "Table", combo: "down", onKeyDown: this.handleFocusMoveDown }),
	            ];
	        }
	        else {
	            return [];
	        }
	    };
	    Table.prototype.maybeRenderSelectAllHotkey = function () {
	        if (this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_TABLE)) {
	            return (React.createElement(core_2.Hotkey, { key: "select-all-hotkey", label: "Select all", group: "Table", combo: "mod+a", onKeyDown: this.handleSelectAllHotkey }));
	        }
	        else {
	            return undefined;
	        }
	    };
	    Table.prototype.maybeRenderBodyRegions = function () {
	        var _this = this;
	        var styler = function (region) {
	            var cardinality = regions_2.Regions.getRegionCardinality(region);
	            var style = _this.grid.getRegionStyle(region);
	            switch (cardinality) {
	                case regions_2.RegionCardinality.CELLS:
	                    return style;
	                case regions_2.RegionCardinality.FULL_COLUMNS:
	                    style.top = "-1px";
	                    return style;
	                case regions_2.RegionCardinality.FULL_ROWS:
	                    style.left = "-1px";
	                    return style;
	                case regions_2.RegionCardinality.FULL_TABLE:
	                    style.left = "-1px";
	                    style.top = "-1px";
	                    return style;
	                default:
	                    return { display: "none" };
	            }
	        };
	        return this.maybeRenderRegions(styler);
	    };
	    Table.prototype.maybeRenderMenuRegions = function () {
	        var _this = this;
	        var styler = function (region) {
	            var grid = _this.grid;
	            var viewportRect = _this.state.viewportRect;
	            if (viewportRect == null) {
	                return {};
	            }
	            var cardinality = regions_2.Regions.getRegionCardinality(region);
	            var style = grid.getRegionStyle(region);
	            switch (cardinality) {
	                case regions_2.RegionCardinality.FULL_TABLE:
	                    style.right = "0px";
	                    style.bottom = "0px";
	                    style.top = "0px";
	                    style.left = "0px";
	                    style.borderBottom = "none";
	                    style.borderRight = "none";
	                    return style;
	                default:
	                    return { display: "none" };
	            }
	        };
	        return this.maybeRenderRegions(styler);
	    };
	    Table.prototype.maybeRenderColumnHeaderRegions = function () {
	        var _this = this;
	        var styler = function (region) {
	            var grid = _this.grid;
	            var viewportRect = _this.state.viewportRect;
	            if (viewportRect == null) {
	                return {};
	            }
	            var cardinality = regions_2.Regions.getRegionCardinality(region);
	            var style = grid.getRegionStyle(region);
	            switch (cardinality) {
	                case regions_2.RegionCardinality.FULL_TABLE:
	                    style.left = "-1px";
	                    style.borderLeft = "none";
	                    style.bottom = "-1px";
	                    style.transform = "translate3d(" + -viewportRect.left + "px, 0, 0)";
	                    return style;
	                case regions_2.RegionCardinality.FULL_COLUMNS:
	                    style.bottom = "-1px";
	                    style.transform = "translate3d(" + -viewportRect.left + "px, 0, 0)";
	                    return style;
	                default:
	                    return { display: "none" };
	            }
	        };
	        return this.maybeRenderRegions(styler);
	    };
	    Table.prototype.maybeRenderRowHeaderRegions = function () {
	        var _this = this;
	        var styler = function (region) {
	            var grid = _this.grid;
	            var viewportRect = _this.state.viewportRect;
	            if (viewportRect == null) {
	                return {};
	            }
	            var cardinality = regions_2.Regions.getRegionCardinality(region);
	            var style = grid.getRegionStyle(region);
	            switch (cardinality) {
	                case regions_2.RegionCardinality.FULL_TABLE:
	                    style.top = "-1px";
	                    style.borderTop = "none";
	                    style.right = "-1px";
	                    style.transform = "translate3d(0, " + -viewportRect.top + "px, 0)";
	                    return style;
	                case regions_2.RegionCardinality.FULL_ROWS:
	                    style.right = "-1px";
	                    style.transform = "translate3d(0, " + -viewportRect.top + "px, 0)";
	                    return style;
	                default:
	                    return { display: "none" };
	            }
	        };
	        return this.maybeRenderRegions(styler);
	    };
	    return Table;
	}(core_1.AbstractComponent));
	Table.defaultProps = {
	    allowMultipleSelection: true,
	    defaultColumnWidth: 150,
	    defaultRowHeight: 20,
	    enableFocus: false,
	    fillBodyWithGhostCells: false,
	    isRowHeaderShown: true,
	    loadingOptions: [],
	    minColumnWidth: 50,
	    minRowHeight: 20,
	    numRows: 0,
	    renderRowHeader: rowHeader_1.renderDefaultRowHeader,
	    selectionModes: regions_2.SelectionModes.ALL,
	};
	Table = Table_1 = tslib_1.__decorate([
	    PureRender,
	    core_2.HotkeysTarget
	], Table);
	exports.Table = Table;
	var Table_1;
	
	//# sourceMappingURL=table.js.map


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var PureRender = __webpack_require__(5);
	var React = __webpack_require__(9);
	var Classes = __webpack_require__(10);
	var index_1 = __webpack_require__(21);
	var resizable_1 = __webpack_require__(37);
	var resizeHandle_1 = __webpack_require__(30);
	var selectable_1 = __webpack_require__(31);
	var regions_1 = __webpack_require__(24);
	var columnHeaderCell_1 = __webpack_require__(32);
	var ColumnHeader = (function (_super) {
	    tslib_1.__extends(ColumnHeader, _super);
	    function ColumnHeader() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.renderGhostCell = function (columnIndex, extremaClasses) {
	            var _a = _this.props, grid = _a.grid, loading = _a.loading;
	            var rect = grid.getGhostCellRect(0, columnIndex);
	            var style = {
	                flexBasis: rect.width + "px",
	                width: rect.width + "px",
	            };
	            return (React.createElement(columnHeaderCell_1.ColumnHeaderCell, { key: Classes.columnIndexClass(columnIndex), className: classNames(extremaClasses), loading: loading, style: style }));
	        };
	        _this.renderCell = function (columnIndex, extremaClasses) {
	            var _a = _this.props, allowMultipleSelection = _a.allowMultipleSelection, cellRenderer = _a.cellRenderer, grid = _a.grid, isResizable = _a.isResizable, loading = _a.loading, maxColumnWidth = _a.maxColumnWidth, minColumnWidth = _a.minColumnWidth, onFocus = _a.onFocus, onColumnWidthChanged = _a.onColumnWidthChanged, onLayoutLock = _a.onLayoutLock, onResizeGuide = _a.onResizeGuide, onSelection = _a.onSelection, selectedRegions = _a.selectedRegions, selectedRegionTransform = _a.selectedRegionTransform;
	            var rect = grid.getColumnRect(columnIndex);
	            var handleSizeChanged = function (size) {
	                onResizeGuide([rect.left + size + 1]);
	            };
	            var handleResizeEnd = function (size) {
	                onResizeGuide(null);
	                onColumnWidthChanged(columnIndex, size);
	            };
	            var handleDoubleClick = function () {
	                var width = _this.props.locator.getWidestVisibleCellInColumn(columnIndex);
	                var clampedWidth = index_1.Utils.clamp(width, minColumnWidth, maxColumnWidth);
	                onResizeGuide(null);
	                onColumnWidthChanged(columnIndex, clampedWidth);
	            };
	            var cell = cellRenderer(columnIndex);
	            var className = classNames(cell.props.className, extremaClasses, (_b = {},
	                _b[Classes.TABLE_DRAGGABLE] = (onSelection != null),
	                _b));
	            var cellLoading = cell.props.loading != null ? cell.props.loading : loading;
	            var isColumnSelected = regions_1.Regions.hasFullColumn(selectedRegions, columnIndex);
	            var cellProps = { className: className, isColumnSelected: isColumnSelected, loading: cellLoading };
	            return (React.createElement(selectable_1.DragSelectable, { allowMultipleSelection: allowMultipleSelection, key: Classes.columnIndexClass(columnIndex), locateClick: _this.locateClick, locateDrag: _this.locateDrag, onFocus: onFocus, onSelection: onSelection, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform },
	                React.createElement(resizable_1.Resizable, { isResizable: isResizable, maxSize: maxColumnWidth, minSize: minColumnWidth, onDoubleClick: handleDoubleClick, onLayoutLock: onLayoutLock, onResizeEnd: handleResizeEnd, onSizeChanged: handleSizeChanged, orientation: resizeHandle_1.Orientation.VERTICAL, size: rect.width }, React.cloneElement(cell, cellProps))));
	            var _b;
	        };
	        _this.locateClick = function (event) {
	            // Abort selection unless the mouse actually hit a table header. This allows
	            // users to supply interactive components in their renderHeader methods.
	            if (!columnHeaderCell_1.ColumnHeaderCell.isHeaderMouseTarget(event.target)) {
	                return null;
	            }
	            var col = _this.props.locator.convertPointToColumn(event.clientX);
	            return regions_1.Regions.column(col);
	        };
	        _this.locateDrag = function (_event, coords) {
	            var colStart = _this.props.locator.convertPointToColumn(coords.activation[0]);
	            var colEnd = _this.props.locator.convertPointToColumn(coords.current[0]);
	            return regions_1.Regions.column(colStart, colEnd);
	        };
	        return _this;
	    }
	    ColumnHeader.prototype.render = function () {
	        var _a = this.props, grid = _a.grid, viewportRect = _a.viewportRect, columnIndexStart = _a.columnIndexStart, columnIndexEnd = _a.columnIndexEnd;
	        var cells = [];
	        for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {
	            var extremaClasses = grid.getExtremaClasses(0, columnIndex, 1, columnIndexEnd);
	            var renderer = grid.isGhostIndex(-1, columnIndex) ? this.renderGhostCell : this.renderCell;
	            cells.push(renderer(columnIndex, extremaClasses));
	        }
	        // always set width so that the layout can push out the element unless it overflows.
	        var style = {
	            width: grid.getRect().width + "px",
	        };
	        // use CSS translation to offset the cells
	        if (viewportRect != null) {
	            style.transform = "translate3d(" + (grid.getColumnRect(columnIndexStart).left - viewportRect.left) + "px, 0, 0)";
	        }
	        var classes = classNames(Classes.TABLE_THEAD, Classes.TABLE_COLUMN_HEADER_TR, (_b = {},
	            _b[Classes.TABLE_DRAGGABLE] = (this.props.onSelection != null),
	            _b));
	        return React.createElement("div", { style: style, className: classes }, cells);
	        var _b;
	    };
	    return ColumnHeader;
	}(React.Component));
	ColumnHeader.defaultProps = {
	    isResizable: true,
	    loading: false,
	};
	ColumnHeader = tslib_1.__decorate([
	    PureRender
	], ColumnHeader);
	exports.ColumnHeader = ColumnHeader;
	
	//# sourceMappingURL=columnHeader.js.map


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var PureRender = __webpack_require__(5);
	var React = __webpack_require__(9);
	var index_1 = __webpack_require__(21);
	var resizeHandle_1 = __webpack_require__(30);
	var Resizable = (function (_super) {
	    tslib_1.__extends(Resizable, _super);
	    function Resizable(props, context) {
	        var _this = _super.call(this, props, context) || this;
	        var size = props.size;
	        _this.state = {
	            size: size,
	            unclampedSize: size,
	        };
	        return _this;
	    }
	    Resizable.prototype.componentWillReceiveProps = function (nextProps) {
	        var size = nextProps.size;
	        this.setState({
	            size: size,
	            unclampedSize: size,
	        });
	    };
	    Resizable.prototype.render = function () {
	        var child = React.Children.only(this.props.children);
	        var style = tslib_1.__assign({}, child.props.style, this.getStyle());
	        if (this.props.isResizable === false) {
	            return React.cloneElement(child, { style: style });
	        }
	        var resizeHandle = this.renderResizeHandle();
	        return React.cloneElement(child, { style: style, resizeHandle: resizeHandle });
	    };
	    Resizable.prototype.renderResizeHandle = function () {
	        var _this = this;
	        var _a = this.props, onLayoutLock = _a.onLayoutLock, onDoubleClick = _a.onDoubleClick, orientation = _a.orientation;
	        var onResizeMove = function (_offset, delta) {
	            _this.offsetSize(delta);
	            if (_this.props.onSizeChanged != null) {
	                _this.props.onSizeChanged(_this.state.size);
	            }
	        };
	        var onResizeEnd = function (_offset) {
	            // reset "unclamped" size on end
	            _this.setState({ unclampedSize: _this.state.size });
	            if (_this.props.onResizeEnd != null) {
	                _this.props.onResizeEnd(_this.state.size);
	            }
	        };
	        return (React.createElement(resizeHandle_1.ResizeHandle, { key: "resize-handle", onDoubleClick: onDoubleClick, onLayoutLock: onLayoutLock, onResizeEnd: onResizeEnd, onResizeMove: onResizeMove, orientation: orientation }));
	    };
	    /**
	     * Returns the CSS style to apply to the child element given the state's
	     * size value.
	     */
	    Resizable.prototype.getStyle = function () {
	        if (this.props.orientation === resizeHandle_1.Orientation.VERTICAL) {
	            return {
	                flexBasis: this.state.size + "px",
	                minWidth: "0px",
	                width: this.state.size + "px",
	            };
	        }
	        else {
	            return {
	                flexBasis: this.state.size + "px",
	                height: this.state.size + "px",
	                minHeight: "0px",
	            };
	        }
	    };
	    Resizable.prototype.offsetSize = function (offset) {
	        var unclampedSize = this.state.unclampedSize + offset;
	        this.setState({
	            size: index_1.Utils.clamp(unclampedSize, this.props.minSize, this.props.maxSize),
	            unclampedSize: unclampedSize,
	        });
	    };
	    return Resizable;
	}(React.Component));
	Resizable.defaultProps = {
	    isResizable: true,
	    minSize: 0,
	};
	Resizable = tslib_1.__decorate([
	    PureRender
	], Resizable);
	exports.Resizable = Resizable;
	
	//# sourceMappingURL=resizable.js.map


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var PureRender = __webpack_require__(5);
	var React = __webpack_require__(9);
	var Classes = __webpack_require__(10);
	var roundSize_1 = __webpack_require__(26);
	var resizable_1 = __webpack_require__(37);
	var resizeHandle_1 = __webpack_require__(30);
	var selectable_1 = __webpack_require__(31);
	var regions_1 = __webpack_require__(24);
	var rowHeaderCell_1 = __webpack_require__(33);
	var RowHeader = (function (_super) {
	    tslib_1.__extends(RowHeader, _super);
	    function RowHeader() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.renderGhostCell = function (rowIndex, extremaClasses) {
	            var _a = _this.props, grid = _a.grid, loading = _a.loading;
	            var rect = grid.getGhostCellRect(rowIndex, 0);
	            var style = {
	                height: rect.height + "px",
	            };
	            return (React.createElement(rowHeaderCell_1.RowHeaderCell, { key: Classes.rowIndexClass(rowIndex), className: classNames(extremaClasses), loading: loading, style: style }));
	        };
	        _this.renderCell = function (rowIndex, extremaClasses) {
	            var _a = _this.props, allowMultipleSelection = _a.allowMultipleSelection, grid = _a.grid, isResizable = _a.isResizable, loading = _a.loading, maxRowHeight = _a.maxRowHeight, minRowHeight = _a.minRowHeight, onFocus = _a.onFocus, onLayoutLock = _a.onLayoutLock, onResizeGuide = _a.onResizeGuide, onRowHeightChanged = _a.onRowHeightChanged, onSelection = _a.onSelection, renderRowHeader = _a.renderRowHeader, selectedRegions = _a.selectedRegions, selectedRegionTransform = _a.selectedRegionTransform;
	            var rect = grid.getRowRect(rowIndex);
	            var handleSizeChanged = function (size) {
	                onResizeGuide([rect.top + size + 1]);
	            };
	            var handleResizeEnd = function (size) {
	                onResizeGuide(null);
	                onRowHeightChanged(rowIndex, size);
	            };
	            var cell = renderRowHeader(rowIndex);
	            var className = classNames(cell.props.className, extremaClasses, (_b = {},
	                _b[Classes.TABLE_DRAGGABLE] = onSelection != null,
	                _b));
	            var cellLoading = cell.props.loading != null ? cell.props.loading : loading;
	            var isRowSelected = regions_1.Regions.hasFullRow(selectedRegions, rowIndex);
	            var cellProps = { className: className, isRowSelected: isRowSelected, loading: cellLoading };
	            return (React.createElement(selectable_1.DragSelectable, { allowMultipleSelection: allowMultipleSelection, key: Classes.rowIndexClass(rowIndex), locateClick: _this.locateClick, locateDrag: _this.locateDrag, onFocus: onFocus, onSelection: onSelection, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform },
	                React.createElement(resizable_1.Resizable, { isResizable: isResizable, maxSize: maxRowHeight, minSize: minRowHeight, onLayoutLock: onLayoutLock, onResizeEnd: handleResizeEnd, onSizeChanged: handleSizeChanged, orientation: resizeHandle_1.Orientation.HORIZONTAL, size: rect.height }, React.cloneElement(cell, cellProps))));
	            var _b;
	        };
	        _this.locateClick = function (event) {
	            var row = _this.props.locator.convertPointToRow(event.clientY);
	            return regions_1.Regions.row(row);
	        };
	        _this.locateDrag = function (_event, coords) {
	            var rowStart = _this.props.locator.convertPointToRow(coords.activation[1]);
	            var rowEnd = _this.props.locator.convertPointToRow(coords.current[1]);
	            return regions_1.Regions.row(rowStart, rowEnd);
	        };
	        return _this;
	    }
	    RowHeader.prototype.render = function () {
	        var _a = this.props, grid = _a.grid, rowIndexEnd = _a.rowIndexEnd, rowIndexStart = _a.rowIndexStart, viewportRect = _a.viewportRect;
	        var cells = [];
	        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {
	            var extremaClasses = grid.getExtremaClasses(rowIndex, 0, rowIndexEnd, 1);
	            var renderer = grid.isGhostIndex(rowIndex, -1) ? this.renderGhostCell : this.renderCell;
	            cells.push(renderer(rowIndex, extremaClasses));
	        }
	        // always set height so that the layout can push out the element unless it overflows.
	        var style = {
	            height: grid.getRect().height + "px",
	        };
	        // use CSS translation to offset the cells
	        if (viewportRect != null) {
	            style.transform = "translate3d(0, " + (grid.getRowRect(rowIndexStart).top - viewportRect.top) + "px, 0)";
	        }
	        return (React.createElement(roundSize_1.RoundSize, null,
	            React.createElement("div", { style: style }, cells)));
	    };
	    return RowHeader;
	}(React.Component));
	RowHeader.defaultProps = {
	    isResizable: false,
	    loading: false,
	    renderRowHeader: renderDefaultRowHeader,
	};
	RowHeader = tslib_1.__decorate([
	    PureRender
	], RowHeader);
	exports.RowHeader = RowHeader;
	/**
	 * A default implementation of `IRowHeaderRenderer` that displays 1-indexed
	 * numbers for each row.
	 */
	function renderDefaultRowHeader(rowIndex) {
	    return React.createElement(rowHeaderCell_1.RowHeaderCell, { name: "" + (rowIndex + 1) });
	}
	exports.renderDefaultRowHeader = renderDefaultRowHeader;
	
	//# sourceMappingURL=rowHeader.js.map


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var Classes = __webpack_require__(10);
	/**
	 * Efficiently detect when an HTMLElement is resized.
	 *
	 * Attaches an invisible "resize-sensor" div to the element. Then it checks
	 * the element's offsetWidth and offsetHeight whenever a scroll event is
	 * triggered on the "resize-sensor" children. These events are further
	 * debounced using requestAnimationFrame.
	 *
	 * Inspired by: https://github.com/marcj/css-element-queries/blob/master/src/ResizeSensor.js
	 */
	var ResizeSensor = (function () {
	    function ResizeSensor() {
	    }
	    ResizeSensor.attach = function (element, callback) {
	        var lifecycle = ResizeSensor.debounce(callback);
	        var resizeSensor = document.createElement("div");
	        resizeSensor.className = Classes.TABLE_RESIZE_SENSOR;
	        resizeSensor.style.cssText = ResizeSensor.RESIZE_SENSOR_STYLE;
	        resizeSensor.innerHTML = ResizeSensor.RESIZE_SENSOR_HTML;
	        element.appendChild(resizeSensor);
	        if (getComputedStyle(element, null).getPropertyValue("position") === "static") {
	            element.style.position = "relative";
	        }
	        var expand = resizeSensor.childNodes[0];
	        var expandChild = expand.childNodes[0];
	        var shrink = resizeSensor.childNodes[1];
	        var reset = function () {
	            expandChild.style.width = "100000px";
	            expandChild.style.height = "100000px";
	            expand.scrollLeft = 100000;
	            expand.scrollTop = 100000;
	            shrink.scrollLeft = 100000;
	            shrink.scrollTop = 100000;
	        };
	        reset();
	        var lastWidth;
	        var lastHeight;
	        var onScroll = function () {
	            var currentWidth = element.offsetWidth;
	            var currentHeight = element.offsetHeight;
	            if (currentWidth !== lastWidth || currentHeight !== lastHeight) {
	                lastWidth = currentWidth;
	                lastHeight = currentHeight;
	                lifecycle.trigger();
	            }
	            reset();
	        };
	        expand.addEventListener("scroll", onScroll);
	        shrink.addEventListener("scroll", onScroll);
	        return function () {
	            element.removeChild(resizeSensor);
	            lifecycle.cancelled = true;
	        };
	    };
	    ResizeSensor.debounce = function (callback) {
	        var scope = {
	            cancelled: false,
	            trigger: function () {
	                if (scope.triggered || scope.cancelled) {
	                    return;
	                }
	                scope.triggered = true;
	                requestAnimationFrame(function () {
	                    scope.triggered = false;
	                    if (!scope.cancelled) {
	                        callback();
	                    }
	                });
	            },
	            triggered: false,
	        };
	        return scope;
	    };
	    return ResizeSensor;
	}());
	ResizeSensor.RESIZE_SENSOR_STYLE = "position: absolute; left: 0; top: 0; right: 0; " +
	    "bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;";
	ResizeSensor.RESIZE_SENSOR_HTML = "<div class=\"" + Classes.TABLE_RESIZE_SENSOR_EXPAND + "\"\n        style=\"" + ResizeSensor.RESIZE_SENSOR_STYLE + "\"><div style=\"position: absolute; left: 0; top: 0; transition: 0s;\"\n        ></div></div><div class=\"" + Classes.TABLE_RESIZE_SENSOR_SHRINK + "\" style=\"" + ResizeSensor.RESIZE_SENSOR_STYLE + "\"\n        ><div style=\"position: absolute; left: 0; top: 0; transition: 0s; width: 200%; height: 200%;\"></div></div>";
	exports.ResizeSensor = ResizeSensor;
	
	//# sourceMappingURL=resizeSensor.js.map


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(9);
	var Classes = __webpack_require__(10);
	var GuideLayer = (function (_super) {
	    tslib_1.__extends(GuideLayer, _super);
	    function GuideLayer() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.renderVerticalGuide = function (offset, index) {
	            var style = {
	                left: offset + "px",
	            };
	            var className = classNames(Classes.TABLE_OVERLAY, Classes.TABLE_VERTICAL_GUIDE);
	            return (React.createElement("div", { className: className, key: index, style: style }));
	        };
	        _this.renderHorizontalGuide = function (offset, index) {
	            var style = {
	                top: offset + "px",
	            };
	            var className = classNames(Classes.TABLE_OVERLAY, Classes.TABLE_HORIZONTAL_GUIDE);
	            return (React.createElement("div", { className: className, key: index, style: style }));
	        };
	        return _this;
	    }
	    GuideLayer.prototype.render = function () {
	        var _a = this.props, verticalGuides = _a.verticalGuides, horizontalGuides = _a.horizontalGuides, className = _a.className;
	        var verticals = (verticalGuides == null) ? undefined : verticalGuides.map(this.renderVerticalGuide);
	        var horizontals = (horizontalGuides == null) ? undefined : horizontalGuides.map(this.renderHorizontalGuide);
	        return (React.createElement("div", { className: classNames(className, Classes.TABLE_OVERLAY_LAYER) },
	            verticals,
	            horizontals));
	    };
	    return GuideLayer;
	}(React.Component));
	exports.GuideLayer = GuideLayer;
	
	//# sourceMappingURL=guides.js.map


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var PureRender = __webpack_require__(5);
	var React = __webpack_require__(9);
	var Classes = __webpack_require__(10);
	var RegionLayer = (function (_super) {
	    tslib_1.__extends(RegionLayer, _super);
	    function RegionLayer() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.renderRegion = function (region, index) {
	            var _a = _this.props, className = _a.className, getRegionStyle = _a.getRegionStyle;
	            return (React.createElement("div", { className: classNames(Classes.TABLE_OVERLAY, Classes.TABLE_REGION, className), key: index, style: getRegionStyle(region) }));
	        };
	        return _this;
	    }
	    RegionLayer.prototype.render = function () {
	        return React.createElement("div", { className: Classes.TABLE_OVERLAY_LAYER }, this.renderRegionChildren());
	    };
	    RegionLayer.prototype.renderRegionChildren = function () {
	        var regions = this.props.regions;
	        if (regions == null) {
	            return undefined;
	        }
	        return regions.map(this.renderRegion);
	    };
	    return RegionLayer;
	}(React.Component));
	RegionLayer = tslib_1.__decorate([
	    PureRender
	], RegionLayer);
	exports.RegionLayer = RegionLayer;
	
	//# sourceMappingURL=regions.js.map


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var Classes = __webpack_require__(10);
	var rect_1 = __webpack_require__(25);
	var utils_1 = __webpack_require__(16);
	var Locator = (function () {
	    function Locator(tableElement, bodyElement, grid) {
	        var _this = this;
	        this.tableElement = tableElement;
	        this.bodyElement = bodyElement;
	        this.grid = grid;
	        this.convertCellIndexToClientX = function (index) {
	            var bodyRect = _this.getBodyRect();
	            return bodyRect.left + _this.grid.getCumulativeWidthAt(index);
	        };
	        this.convertCellIndexToClientY = function (index) {
	            var bodyRect = _this.getBodyRect();
	            return bodyRect.top + _this.grid.getCumulativeHeightAt(index);
	        };
	    }
	    Locator.prototype.setGrid = function (grid) {
	        this.grid = grid;
	    };
	    Locator.prototype.getViewportRect = function () {
	        return new rect_1.Rect(this.bodyElement.scrollLeft, this.bodyElement.scrollTop, this.bodyElement.clientWidth, this.bodyElement.clientHeight);
	    };
	    Locator.prototype.getWidestVisibleCellInColumn = function (columnIndex) {
	        var cellClasses = [
	            "." + Classes.columnCellIndexClass(columnIndex),
	            "." + Classes.TABLE_COLUMN_NAME,
	        ];
	        var cells = this.tableElement.querySelectorAll(cellClasses.join(", "));
	        var max = 0;
	        for (var i = 0; i < cells.length; i++) {
	            var contentWidth = utils_1.Utils.measureElementTextContent(cells.item(i)).width;
	            var cellWidth = Math.ceil(contentWidth) + Locator.CELL_HORIZONTAL_PADDING * 2;
	            if (cellWidth > max) {
	                max = cellWidth;
	            }
	        }
	        return max;
	    };
	    Locator.prototype.convertPointToColumn = function (clientX) {
	        var tableRect = this.getTableRect();
	        if (!tableRect.containsX(clientX)) {
	            return -1;
	        }
	        return utils_1.Utils.binarySearch(clientX, this.grid.numCols - 1, this.convertCellIndexToClientX);
	    };
	    Locator.prototype.convertPointToRow = function (clientY) {
	        var tableRect = this.getTableRect();
	        if (!tableRect.containsY(clientY)) {
	            return -1;
	        }
	        return utils_1.Utils.binarySearch(clientY, this.grid.numRows - 1, this.convertCellIndexToClientY);
	    };
	    Locator.prototype.convertPointToCell = function (clientX, clientY) {
	        var col = utils_1.Utils.binarySearch(clientX, this.grid.numCols - 1, this.convertCellIndexToClientX);
	        var row = utils_1.Utils.binarySearch(clientY, this.grid.numRows - 1, this.convertCellIndexToClientY);
	        return { col: col, row: row };
	    };
	    Locator.prototype.getTableRect = function () {
	        return rect_1.Rect.wrap(this.tableElement.getBoundingClientRect());
	    };
	    Locator.prototype.getBodyRect = function () {
	        return this.unscrollElementRect(this.bodyElement);
	    };
	    /**
	     * Subtracts the scroll offset from the element's bounding client rect.
	     */
	    Locator.prototype.unscrollElementRect = function (element) {
	        var rect = rect_1.Rect.wrap(element.getBoundingClientRect());
	        rect.left -= element.scrollLeft;
	        rect.top -= element.scrollTop;
	        return rect;
	    };
	    return Locator;
	}());
	Locator.CELL_HORIZONTAL_PADDING = 10;
	exports.Locator = Locator;
	
	//# sourceMappingURL=locator.js.map


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(9);
	var cell_1 = __webpack_require__(2);
	var Classes = __webpack_require__(10);
	var contextMenuTargetWrapper_1 = __webpack_require__(44);
	var rect_1 = __webpack_require__(25);
	var utils_1 = __webpack_require__(16);
	var menus_1 = __webpack_require__(27);
	var selectable_1 = __webpack_require__(31);
	var regions_1 = __webpack_require__(24);
	/**
	 * For perf, we want to ignore changes to the `ISelectableProps` part of the
	 * `ITableBodyProps` since those are only used when a context menu is launched.
	 */
	var UPDATE_PROPS_KEYS = [
	    "grid",
	    "locator",
	    "viewportRect",
	    "cellRenderer",
	    "rowIndexStart",
	    "rowIndexEnd",
	    "columnIndexStart",
	    "columnIndexEnd",
	    "selectedRegions",
	];
	var TableBody = (function (_super) {
	    tslib_1.__extends(TableBody, _super);
	    function TableBody() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.renderContextMenu = function (e) {
	            var _a = _this.props, selectedRegions = _a.selectedRegions, renderBodyContextMenu = _a.renderBodyContextMenu, grid = _a.grid;
	            if (renderBodyContextMenu == null) {
	                return undefined;
	            }
	            var target = _this.locateClick(e.nativeEvent);
	            return renderBodyContextMenu(new menus_1.MenuContext(target, selectedRegions, grid.numRows, grid.numCols));
	        };
	        _this.renderCell = function (rowIndex, columnIndex, extremaClasses, isGhost) {
	            var _a = _this.props, cellRenderer = _a.cellRenderer, loading = _a.loading, grid = _a.grid;
	            var baseCell = isGhost ? cell_1.emptyCellRenderer() : cellRenderer(rowIndex, columnIndex);
	            var className = classNames(TableBody.cellClassNames(rowIndex, columnIndex), extremaClasses, (_b = {},
	                _b[Classes.TABLE_CELL_GHOST] = isGhost,
	                _b[Classes.TABLE_CELL_LEDGER_ODD] = (rowIndex % 2) === 1,
	                _b[Classes.TABLE_CELL_LEDGER_EVEN] = (rowIndex % 2) === 0,
	                _b), baseCell.props.className);
	            var key = TableBody.cellReactKey(rowIndex, columnIndex);
	            var rect = isGhost ? grid.getGhostCellRect(rowIndex, columnIndex) : grid.getCellRect(rowIndex, columnIndex);
	            var cellLoading = baseCell.props.loading != null ? baseCell.props.loading : loading;
	            var style = tslib_1.__assign({}, baseCell.props.style, rect_1.Rect.style(rect));
	            return React.cloneElement(baseCell, { className: className, key: key, loading: cellLoading, style: style });
	            var _b;
	        };
	        _this.locateClick = function (event) {
	            var _a = _this.props.locator.convertPointToCell(event.clientX, event.clientY), col = _a.col, row = _a.row;
	            return regions_1.Regions.cell(row, col);
	        };
	        _this.locateDrag = function (_event, coords) {
	            var start = _this.props.locator.convertPointToCell(coords.activation[0], coords.activation[1]);
	            var end = _this.props.locator.convertPointToCell(coords.current[0], coords.current[1]);
	            return regions_1.Regions.cell(start.row, start.col, end.row, end.col);
	        };
	        return _this;
	    }
	    /**
	     * Returns the array of class names that must be applied to each table
	     * cell so that we can locate any cell based on its coordinate.
	     */
	    TableBody.cellClassNames = function (rowIndex, columnIndex) {
	        return [
	            Classes.rowCellIndexClass(rowIndex),
	            Classes.columnCellIndexClass(columnIndex),
	        ];
	    };
	    TableBody.cellReactKey = function (rowIndex, columnIndex) {
	        return "cell-" + rowIndex + "-" + columnIndex;
	    };
	    TableBody.prototype.shouldComponentUpdate = function (nextProps) {
	        var shallowEqual = utils_1.Utils.shallowCompareKeys(this.props, nextProps, UPDATE_PROPS_KEYS);
	        return !shallowEqual;
	    };
	    TableBody.prototype.render = function () {
	        var _a = this.props, allowMultipleSelection = _a.allowMultipleSelection, columnIndexEnd = _a.columnIndexEnd, columnIndexStart = _a.columnIndexStart, grid = _a.grid, onFocus = _a.onFocus, onSelection = _a.onSelection, rowIndexEnd = _a.rowIndexEnd, rowIndexStart = _a.rowIndexStart, selectedRegions = _a.selectedRegions, selectedRegionTransform = _a.selectedRegionTransform;
	        var style = grid.getRect().sizeStyle();
	        var cells = [];
	        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {
	            for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {
	                var extremaClasses = grid.getExtremaClasses(rowIndex, columnIndex, rowIndexEnd, columnIndexEnd);
	                var isGhost = grid.isGhostIndex(rowIndex, columnIndex);
	                cells.push(this.renderCell(rowIndex, columnIndex, extremaClasses, isGhost));
	            }
	        }
	        return (React.createElement(selectable_1.DragSelectable, { allowMultipleSelection: allowMultipleSelection, locateClick: this.locateClick, locateDrag: this.locateDrag, onFocus: onFocus, onSelection: onSelection, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform },
	            React.createElement(contextMenuTargetWrapper_1.ContextMenuTargetWrapper, { className: classNames(Classes.TABLE_BODY_VIRTUAL_CLIENT, Classes.TABLE_CELL_CLIENT), renderContextMenu: this.renderContextMenu, style: style }, cells)));
	    };
	    return TableBody;
	}(React.Component));
	TableBody.defaultProps = {
	    loading: false,
	};
	exports.TableBody = TableBody;
	
	//# sourceMappingURL=tableBody.js.map


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(11);
	var React = __webpack_require__(9);
	/**
	 * Since the ContextMenuTarget uses the `onContextMenu` prop instead
	 * `element.addEventListener`, the prop can be lost. This wrapper helps us
	 * maintain context menu fuctionality when doing fancy React.cloneElement
	 * chains.
	 */
	var ContextMenuTargetWrapper = (function (_super) {
	    tslib_1.__extends(ContextMenuTargetWrapper, _super);
	    function ContextMenuTargetWrapper() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ContextMenuTargetWrapper.prototype.render = function () {
	        var _a = this.props, className = _a.className, children = _a.children, style = _a.style;
	        return React.createElement("div", { className: className, style: style }, children);
	    };
	    ContextMenuTargetWrapper.prototype.renderContextMenu = function (e) {
	        return this.props.renderContextMenu(e);
	    };
	    return ContextMenuTargetWrapper;
	}(React.Component));
	ContextMenuTargetWrapper = tslib_1.__decorate([
	    core_1.ContextMenuTarget
	], ContextMenuTargetWrapper);
	exports.ContextMenuTargetWrapper = ContextMenuTargetWrapper;
	
	//# sourceMappingURL=contextMenuTargetWrapper.js.map


/***/ }
/******/ ])
});
;
//# sourceMappingURL=table.bundle.js.map