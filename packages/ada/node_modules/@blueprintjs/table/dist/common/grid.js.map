{"version":3,"sources":["../src/common/grid.ts"],"names":[],"mappings":"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","file":"common/grid.js","sourcesContent":["/**\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport { CSSProperties } from \"react\";\n\nimport { IRegion, RegionCardinality, Regions } from \"../regions\";\nimport * as Classes from \"./classes\";\nimport { Rect } from \"./rect\";\nimport { Utils } from \"./utils\";\n\nexport type ICellMapper<T> = (rowIndex: number, columnIndex: number) => T;\nexport type IRowMapper<T> = (rowIndex: number) => T;\nexport type IColumnMapper<T> = (columnIndex: number) => T;\n\nexport interface IRowIndices {\n    rowIndexStart: number;\n    rowIndexEnd: number;\n}\n\nexport interface IColumnIndices {\n    columnIndexStart: number;\n    columnIndexEnd: number;\n}\n\n/**\n * This class manages the sizes of grid cells using arrays of individual row/column sizes.\n */\nexport class Grid {\n    public static DEFAULT_BLEED = 3;\n    public static DEFAULT_MAX_COLUMNS = 50;\n    public static DEFAULT_MAX_ROWS = 200;\n    public static DEFAULT_GHOST_HEIGHT = 20;\n    public static DEFAULT_GHOST_WIDTH = 150;\n\n    public numCols: number;\n    public numRows: number;\n    private bleed: number;\n    private columnWidths: number[];\n    private rowHeights: number[];\n    private cumulativeColumnWidths: number[];\n    private cumulativeRowHeights: number[];\n    private ghostHeight: number;\n    private ghostWidth: number;\n\n    /**\n     * This constructor accumulates the heights and widths in `O(n)`, saving\n     * time in later calculations.\n     *\n     * @param bleed - The number of rows/cols that we expand beyond the\n     *     viewport (on all sides). This helps avoid displaying an empty\n     *     viewport when the user scrolls quickly.\n     */\n    public constructor(\n        rowHeights: number[],\n        columnWidths: number[],\n        bleed = Grid.DEFAULT_BLEED,\n        ghostHeight = Grid.DEFAULT_GHOST_HEIGHT,\n        ghostWidth = Grid.DEFAULT_GHOST_WIDTH,\n    ) {\n        this.columnWidths = columnWidths;\n        this.rowHeights = rowHeights;\n        this.cumulativeColumnWidths = Utils.accumulate(columnWidths);\n        this.cumulativeRowHeights = Utils.accumulate(rowHeights);\n        this.numCols = columnWidths.length;\n        this.numRows = rowHeights.length;\n        this.bleed = bleed;\n        this.ghostHeight = ghostHeight;\n        this.ghostWidth = ghostWidth;\n    }\n\n    /**\n     * Returns the `Rect` bounds of a cell in scrollpane client space.\n     *\n     * Scrollpane client coordinate space uses the origin of the scrollpane\n     * client (the inside part that you're moving around).\n     *\n     * For example, let's say you're scrolling around a block of 1000 x 1000\n     * cells. Regardless where you've scrolled, the first cell is always at\n     * 0,0 in scrollpane client space. the cell to the right of it is always\n     * at, e.g., 100,0.\n     */\n    public getCellRect(rowIndex: number, columnIndex: number) {\n        const height = this.rowHeights[rowIndex];\n        const top = this.cumulativeRowHeights[rowIndex] - height;\n        const width = this.columnWidths[columnIndex];\n        const left = this.cumulativeColumnWidths[columnIndex] - width;\n        return new Rect(left, top, width, height);\n    }\n\n    /**\n     * Returns the `Rect` bounds of a cell in scrollpane client space.\n     *\n     * If the cell is beyond the bounds of the user-defined table cells, it is\n     * considered a \"ghost\" cell. If a width/height is not defined for that\n     * row/column, we use the default width/height.\n     */\n    public getGhostCellRect(rowIndex: number, columnIndex: number) {\n        let left = 0;\n        let top = 0;\n        let width = 0;\n        let height = 0;\n        if (rowIndex >= this.rowHeights.length) {\n            height = this.ghostHeight;\n            top = this.getHeight() + this.ghostHeight * (rowIndex - this.numRows);\n        } else {\n            height = this.rowHeights[rowIndex];\n            top = this.cumulativeRowHeights[rowIndex] - height;\n        }\n\n        if (columnIndex >= this.columnWidths.length) {\n            width = this.ghostWidth;\n            left = this.getWidth() + this.ghostWidth * (columnIndex - this.numCols);\n        } else {\n            width = this.columnWidths[columnIndex];\n            left = this.cumulativeColumnWidths[columnIndex] - width;\n        }\n        return new Rect(left, top, width, height);\n    }\n\n    /**\n     * Returns the `Rect` with the base coordinate and height of the specified row.\n     */\n    public getRowRect(rowIndex: number) {\n        const height = this.rowHeights[rowIndex];\n        const top = this.cumulativeRowHeights[rowIndex] - height;\n        return new Rect(0, top, this.getWidth(), height);\n    }\n\n    /**\n     * Returns the `Rect` with the base coordinate and width of the specified column.\n     */\n    public getColumnRect(columnIndex: number) {\n        const width = this.columnWidths[columnIndex];\n        const left = this.cumulativeColumnWidths[columnIndex] - width;\n        return new Rect(left, 0, width, this.getHeight());\n    }\n\n    /**\n     * Returns the total width of the entire grid\n     */\n    public getWidth() {\n        return this.numCols === 0 ? 0 : this.cumulativeColumnWidths[this.numCols - 1];\n    }\n\n    /**\n     * Returns the total width of the entire grid\n     */\n    public getHeight() {\n        return this.numRows === 0 ? 0 : this.cumulativeRowHeights[this.numRows - 1];\n    }\n\n    /**\n     * Returns the `Rect` bounds of entire grid\n     */\n    public getRect() {\n        return new Rect(0, 0, this.getWidth(), this.getHeight());\n    }\n\n    /**\n     * Maps each cell that intersects with the given `Rect` argument. The\n     * indices of iteration are extended in both directions by the integer\n     * `bleed` class property, then are clamped between 0 and the number of\n     * rows/columns.\n     *\n     * Uses a binary search for each of the 4 edges of the bounds, resulting\n     * in a runtime of `O(log(rows) + log(cols))` plus the `O(irows * icols)`\n     * iteration of intersecting cells.\n     */\n    public mapCellsInRect<T>(rect: Rect, callback: ICellMapper<T>): T[] {\n        const results: T[] = [];\n        if (rect == null) {\n            return results;\n        }\n\n        const {rowIndexStart, rowIndexEnd} = this.getRowIndicesInRect(rect);\n        const {columnIndexStart, columnIndexEnd} = this.getColumnIndicesInRect(rect);\n        for (let rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n            for (let columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n                results.push(callback(rowIndex, columnIndex));\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Maps each row that intersects with the given `Rect` argument.\n     *\n     * See Grid.mapCellsInRect for more details.\n     */\n    public mapRowsInRect<T>(rect: Rect, callback: IRowMapper<T>): T[] {\n        const results: T[] = [];\n        if (rect == null) {\n            return results;\n        }\n\n        const {rowIndexStart, rowIndexEnd} = this.getRowIndicesInRect(rect);\n        for (let rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n            results.push(callback(rowIndex));\n        }\n        return results;\n    }\n\n    /**\n     * Maps each column that intersects with the given `Rect` argument.\n     *\n     * See Grid.mapCellsInRect for more details.\n     */\n    public mapColumnsInRect<T>(rect: Rect, callback: IColumnMapper<T>): T[] {\n        const results: T[] = [];\n        if (rect == null) {\n            return results;\n        }\n\n        const {columnIndexStart, columnIndexEnd} = this.getColumnIndicesInRect(rect);\n        for (let columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n            results.push(callback(columnIndex));\n        }\n        return results;\n    }\n\n    /**\n     * Returns the start and end indices of rows that intersect with the given\n     * `Rect` argument.\n     */\n    public getRowIndicesInRect(\n        rect: Rect,\n        includeGhostCells = false,\n        limit = Grid.DEFAULT_MAX_ROWS,\n    ): IRowIndices {\n\n        if (rect == null) {\n            return {rowIndexEnd: 0, rowIndexStart: 0};\n        }\n\n        const searchEnd = includeGhostCells ? Math.max(this.numRows, Grid.DEFAULT_MAX_ROWS) : this.numRows;\n        const { start, end } = this.getIndicesInInterval(\n            rect.top,\n            rect.top + rect.height,\n            searchEnd,\n            !includeGhostCells,\n            this.getCumulativeHeightAt,\n        );\n        const rowIndexEnd = (limit > 0 && end - start > limit)\n            ? start + limit\n            : end;\n\n        return {\n            rowIndexEnd,\n            rowIndexStart: start,\n        };\n    }\n\n    /**\n     * Returns the start and end indices of columns that intersect with the\n     * given `Rect` argument.\n     */\n    public getColumnIndicesInRect(\n        rect: Rect,\n        includeGhostCells = false,\n        limit = Grid.DEFAULT_MAX_COLUMNS,\n    ): IColumnIndices {\n\n        if (rect == null) {\n            return {columnIndexEnd: 0, columnIndexStart: 0};\n        }\n\n        const searchEnd = includeGhostCells ? Math.max(this.numCols, Grid.DEFAULT_MAX_COLUMNS) : this.numCols;\n        const { start, end } = this.getIndicesInInterval(\n            rect.left,\n            rect.left + rect.width,\n            searchEnd,\n            !includeGhostCells,\n            this.getCumulativeWidthAt,\n        );\n\n        const columnIndexEnd = (limit > 0 && end - start > limit)\n            ? start + limit\n            : end;\n\n        return {\n            columnIndexEnd,\n            columnIndexStart: start,\n        };\n    }\n\n    public isGhostIndex(rowIndex: number, columnIndex: number) {\n        return (rowIndex >= this.numRows || columnIndex >= this.numCols);\n    }\n\n    public getExtremaClasses(rowIndex: number, columnIndex: number, rowEnd: number, columnEnd: number) {\n        if (rowIndex === rowEnd && columnIndex === columnEnd) {\n            return [Classes.TABLE_LAST_IN_COLUMN, Classes.TABLE_LAST_IN_ROW];\n        }\n        if (rowIndex === rowEnd) {\n            return [Classes.TABLE_LAST_IN_COLUMN];\n        }\n        if (columnIndex === columnEnd) {\n            return [Classes.TABLE_LAST_IN_ROW];\n        }\n        return [];\n    }\n\n    public getRegionStyle(region: IRegion): CSSProperties {\n        const cardinality = Regions.getRegionCardinality(region);\n        switch (cardinality) {\n            case RegionCardinality.CELLS: {\n                const cellRect0 = this.getCellRect(region.rows[0], region.cols[0]);\n                const cellRect1 = this.getCellRect(region.rows[1], region.cols[1]);\n                const offsetLeft = region.cols[0] === 0 ? 0 : 1;\n                const offsetTop = region.rows[0] === 0 ? 0 : 1;\n                const rect = cellRect0.union(cellRect1);\n                rect.height += offsetTop;\n                rect.left -= offsetLeft;\n                rect.width += offsetLeft;\n                rect.top -= offsetTop;\n                return { ...rect.style(), display: \"block\" };\n            }\n\n            case RegionCardinality.FULL_COLUMNS: {\n                const cellRect0 = this.getCellRect(0, region.cols[0]);\n                const cellRect1 = this.getCellRect(0, region.cols[1]);\n                const rect = cellRect0.union(cellRect1);\n                const offsetLeft = region.cols[0] === 0 ? 0 : 1;\n                return {\n                    bottom: 0,\n                    display: \"block\",\n                    left: rect.left - offsetLeft,\n                    top: 0,\n                    width: rect.width + offsetLeft,\n                };\n              }\n\n            case RegionCardinality.FULL_ROWS: {\n                const cellRect0 = this.getCellRect(region.rows[0], 0);\n                const cellRect1 = this.getCellRect(region.rows[1], 0);\n                const rect = cellRect0.union(cellRect1);\n                const offsetTop = region.rows[0] === 0 ? 0 : 1;\n                return {\n                    display: \"block\",\n                    height: rect.height + offsetTop,\n                    left: 0,\n                    right: 0,\n                    top: rect.top - offsetTop,\n                };\n            }\n\n            case RegionCardinality.FULL_TABLE:\n                return {\n                    bottom: 0,\n                    display: \"block\",\n                    left: 0,\n                    right: 0,\n                    top: 0,\n                };\n\n            default: return { display: \"none\" };\n        }\n    }\n\n    public getCumulativeWidthAt = (index: number) => {\n        if (this.numCols === 0) {\n            return this.ghostWidth * index;\n        } else if (index >= this.numCols) {\n            return this.cumulativeColumnWidths[this.numCols - 1] + this.ghostWidth * (index - this.numCols + 1);\n        } else {\n            return this.cumulativeColumnWidths[index];\n        }\n    }\n\n    public getCumulativeHeightAt = (index: number) => {\n        if (this.numRows === 0) {\n            return this.ghostHeight * index;\n        } else if (index >= this.numRows) {\n            return this.cumulativeRowHeights[this.numRows - 1] + this.ghostHeight * (index - this.numRows + 1);\n        } else {\n            return this.cumulativeRowHeights[index];\n        }\n    }\n\n    private getIndicesInInterval(\n        min: number,\n        max: number,\n        count: number,\n        useEndBleed: boolean,\n        lookup: (index: number) => number,\n    ) {\n        let start = Utils.binarySearch(min, count - 1, lookup);\n        let end = Utils.binarySearch(max, count - 1, lookup);\n\n        // correct exact pixel alignment\n        if (start >= 0 && min === lookup(start)) {\n            start += 1;\n        }\n\n        // apply bounded bleeds\n        start = Math.max(0, start - this.bleed);\n        if (useEndBleed) {\n            end = Math.min(count - 1, end + this.bleed);\n        } else {\n            end = Math.min(count - 1, end);\n        }\n        return {start, end};\n    }\n}\n"]}