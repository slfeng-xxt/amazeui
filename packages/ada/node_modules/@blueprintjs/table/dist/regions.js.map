{"version":3,"sources":["../src/regions.ts"],"names":[],"mappings":"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","file":"regions.js","sourcesContent":["/**\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport { IFocusedCellCoordinates } from \"./common/cell\";\nimport * as Classes from \"./common/classes\";\nimport { Utils } from \"./common/utils\";\n\n/**\n * `Region`s contain sets of cells. Additionally, a distinction is drawn, for\n * example, between all cells within a column and the whole column itself.\n * The `RegionCardinality` enum represents these distinct types of `Region`s.\n */\nexport enum RegionCardinality {\n    /**\n     * A region that contains a finite rectangular group of table cells\n     */\n    CELLS,\n\n    /**\n     * A region that represents all cells within 1 or more rows.\n     */\n    FULL_ROWS,\n\n    /**\n     * A region that represents all cells within 1 or more columns.\n     */\n    FULL_COLUMNS,\n\n    /**\n     * A region that represents all cells in the table.\n     */\n    FULL_TABLE,\n}\n\n/**\n * A convenience object for subsets of `RegionCardinality` that are commonly\n * used as the `selectionMode` prop of the `<Table>`.\n */\nexport const SelectionModes = {\n    ALL: [\n        RegionCardinality.FULL_TABLE,\n        RegionCardinality.FULL_COLUMNS,\n        RegionCardinality.FULL_ROWS,\n        RegionCardinality.CELLS,\n    ],\n    COLUMNS_AND_CELLS: [\n        RegionCardinality.FULL_COLUMNS,\n        RegionCardinality.CELLS,\n    ],\n    COLUMNS_ONLY: [\n        RegionCardinality.FULL_COLUMNS,\n    ],\n    NONE: [] as RegionCardinality[],\n    ROWS_AND_CELLS: [\n        RegionCardinality.FULL_ROWS,\n        RegionCardinality.CELLS,\n    ],\n    ROWS_ONLY: [\n        RegionCardinality.FULL_ROWS,\n    ],\n};\n\nexport type ColumnLoadingOption = \"cells\" | \"column-header\";\nexport const ColumnLoadingOption = {\n    CELLS: \"cells\" as ColumnLoadingOption,\n    HEADER: \"column-header\" as ColumnLoadingOption,\n};\n\nexport type RowLoadingOption = \"cells\" | \"row-header\";\nexport const RowLoadingOption = {\n    CELLS: \"cells\" as RowLoadingOption,\n    HEADER: \"row-header\" as RowLoadingOption,\n};\n\nexport type TableLoadingOption = ColumnLoadingOption | RowLoadingOption;\nexport const TableLoadingOption = {\n    CELLS: \"cells\" as TableLoadingOption,\n    COLUMN_HEADERS: ColumnLoadingOption.HEADER as TableLoadingOption,\n    ROW_HEADERS: RowLoadingOption.HEADER as TableLoadingOption,\n};\n\nexport interface IStyledRegionGroup {\n    className?: string;\n    regions: IRegion[];\n}\n\n/**\n * An _inclusive_ interval of ZERO-indexed cell indices.\n */\nexport type ICellInterval = [number, number];\n\n/**\n * Small datastructure for storing cell coordinates [row, column]\n */\nexport type ICellCoordinate = [number, number];\n\n/**\n * A ZERO-indexed region of cells.\n *\n * @see `Regions.getRegionCardinality` for more about the format of this object.\n */\nexport interface IRegion {\n    rows?: ICellInterval;\n    cols?: ICellInterval;\n}\n\nexport class Regions {\n    /**\n     * Determines the cardinality of a region. We use null values to indicate\n     * an unbounded interval. Therefore, an example of a region containing the\n     * second and third columns would be:\n     *\n     *     {\n     *         rows: null,\n     *         cols: [1, 2]\n     *     }\n     *\n     * In this case, this method would return `RegionCardinality.FULL_COLUMNS`.\n     *\n     * If both rows and columns are unbounded, then the region covers the\n     * entire table. Therefore, a region like this:\n     *\n     *     {\n     *         rows: null,\n     *         cols: null\n     *     }\n     *\n     * will return `RegionCardinality.FULL_TABLE`.\n     *\n     * An example of a region containing a single cell in the table would be:\n     *\n     *     {\n     *         rows: [5, 5],\n     *         cols: [2, 2]\n     *     }\n     *\n     * In this case, this method would return `RegionCardinality.CELLS`.\n     */\n    public static getRegionCardinality(region: IRegion) {\n        if (region.cols != null && region.rows != null) {\n            return RegionCardinality.CELLS;\n        } else if (region.cols != null) {\n            return RegionCardinality.FULL_COLUMNS;\n        } else if (region.rows != null) {\n            return RegionCardinality.FULL_ROWS;\n        } else {\n            return RegionCardinality.FULL_TABLE;\n        }\n    }\n\n    /**\n     * Returns a region containing one or more cells.\n     */\n    public static cell(row: number, col: number, row2?: number, col2?: number): IRegion {\n        return {\n            cols: this.normalizeInterval(col, col2),\n            rows: this.normalizeInterval(row, row2),\n        };\n    }\n\n    /**\n     * Returns a region containing one or more full rows.\n     */\n    public static row(row: number, row2?: number): IRegion  {\n        return { rows: this.normalizeInterval(row, row2) };\n    }\n\n    /**\n     * Returns a region containing one or more full columns.\n     */\n    public static column(col: number, col2?: number): IRegion  {\n        return { cols: this.normalizeInterval(col, col2) };\n    }\n\n    /**\n     * Returns a region containing the entire table.\n     */\n    public static table(): IRegion  {\n        return {};\n    }\n\n    /**\n     * Adds the region to the end of a cloned copy of the supplied region\n     * array.\n     */\n    public static add(regions: IRegion[], region: IRegion) {\n        const copy = regions.slice();\n        copy.push(region);\n        return copy;\n    }\n\n    /**\n     * Replaces the region at the end of a cloned copy of the supplied region\n     * array.\n     */\n    public static update(regions: IRegion[], region: IRegion) {\n        const copy = regions.slice();\n        copy.pop();\n        copy.push(region);\n        return copy;\n    }\n\n    /**\n     * Returns true iff the specified region is equal to the last region in\n     * the region list. This allows us to avoid immediate additive re-selection.\n     */\n    public static lastRegionIsEqual(regions: IRegion[], region: IRegion) {\n        if (regions == null || regions.length === 0) {\n            return false;\n        }\n        const lastRegion = regions[regions.length - 1];\n        return Regions.regionsEqual(lastRegion, region);\n    }\n\n    /**\n     * Returns the index of the region that is equal to the supplied\n     * parameter. Returns -1 if no such region is found.\n     */\n    public static findMatchingRegion(regions: IRegion[], region: IRegion) {\n        if (regions == null) {\n            return -1;\n        }\n\n        for (let i = 0; i < regions.length; i++) {\n            if (Regions.regionsEqual(regions[i], region)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns true if the regions contain a region that has FULL_COLUMNS\n     * cardinality and contains the specified column index.\n     */\n    public static hasFullColumn(regions: IRegion[], col: number) {\n        if (regions == null) {\n            return false;\n        }\n\n        for (const region of regions) {\n            const cardinality = Regions.getRegionCardinality(region);\n            if (cardinality === RegionCardinality.FULL_TABLE) {\n                return true;\n            }\n            if (cardinality === RegionCardinality.FULL_COLUMNS && Regions.intervalContainsIndex(region.cols, col)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns true if the regions contain a region that has FULL_ROWS\n     * cardinality and contains the specified row index.\n     */\n    public static hasFullRow(regions: IRegion[], row: number) {\n        if (regions == null) {\n            return false;\n        }\n\n        for (const region of regions) {\n            const cardinality = Regions.getRegionCardinality(region);\n            if (cardinality === RegionCardinality.FULL_TABLE) {\n                return true;\n            }\n            if (cardinality === RegionCardinality.FULL_ROWS && Regions.intervalContainsIndex(region.rows, row)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns true if the regions contain a region that has FULL_TABLE cardinality\n     */\n    public static hasFullTable(regions: IRegion[]) {\n        if (regions == null) {\n            return false;\n        }\n\n        for (const region of regions) {\n            const cardinality = Regions.getRegionCardinality(region);\n            if (cardinality === RegionCardinality.FULL_TABLE) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns true if the regions contain the query region. The query region\n     * may be a subset of the `regions` parameter.\n     */\n    public static containsRegion(regions: IRegion[], query: IRegion) {\n        if (regions == null || query == null) {\n            return false;\n        }\n\n        for (const region of regions) {\n            const cardinality = Regions.getRegionCardinality(region);\n            switch (cardinality) {\n                case RegionCardinality.FULL_TABLE:\n                    return true;\n                case RegionCardinality.FULL_COLUMNS:\n                    if (Regions.intervalOverlaps(region.cols, query.cols)) {\n                        return true;\n                    }\n                    continue;\n                case RegionCardinality.FULL_ROWS:\n                    if (Regions.intervalOverlaps(region.rows, query.rows)) {\n                        return true;\n                    }\n                    continue;\n                case RegionCardinality.CELLS:\n                    if (Regions.intervalOverlaps(region.cols, query.cols)\n                        && Regions.intervalOverlaps(region.rows, query.rows)) {\n                        return true;\n                    }\n                    continue;\n                default:\n                    break;\n            }\n        }\n\n        return false;\n    }\n\n    public static eachUniqueFullColumn(regions: IRegion[], iteratee: (col: number) => void) {\n        if (regions == null || regions.length === 0 || iteratee == null) {\n            return;\n        }\n\n        const seen: {[col: number]: boolean} = {};\n        regions.forEach((region: IRegion) => {\n            if (Regions.getRegionCardinality(region) === RegionCardinality.FULL_COLUMNS) {\n                const [ start, end ] = region.cols;\n                for (let col = start; col <= end; col++) {\n                    if (!seen[col]) {\n                        seen[col] = true;\n                        iteratee(col);\n                    }\n                }\n            }\n        });\n    }\n\n    public static eachUniqueFullRow(regions: IRegion[], iteratee: (row: number) => void) {\n        if (regions == null || regions.length === 0 || iteratee == null) {\n            return;\n        }\n\n        const seen: {[row: number]: boolean} = {};\n        regions.forEach((region: IRegion) => {\n            if (Regions.getRegionCardinality(region) === RegionCardinality.FULL_ROWS) {\n                const [ start, end ] = region.rows;\n                for (let row = start; row <= end; row++) {\n                    if (!seen[row]) {\n                        seen[row] = true;\n                        iteratee(row);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Using the supplied array of non-contiguous `IRegion`s, this method\n     * returns an ordered array of every unique cell that exists in those\n     * regions.\n     */\n    public static enumerateUniqueCells(\n        regions: IRegion[],\n        numRows: number,\n        numCols: number,\n    ): ICellCoordinate[] {\n\n        if (regions == null || regions.length === 0) {\n            return [];\n        }\n\n        const seen: {[key: string]: boolean} = {};\n        const list: ICellCoordinate[] = [];\n        for (const region of regions) {\n            Regions.eachCellInRegion(region, numRows, numCols, (row: number, col: number) => {\n                // add to list if not seen\n                const key = `${row}-${col}`;\n                if (seen[key] !== true) {\n                    seen[key] = true;\n                    list.push([row, col]);\n                }\n            });\n        }\n\n        // sort list by rows then columns\n        list.sort(Regions.rowFirstComparator);\n        return list;\n    }\n\n    /**\n     * Maps a dense array of cell coordinates to a sparse 2-dimensional array\n     * of cell values.\n     *\n     * We create a new 2-dimensional array representing the smallest single\n     * contiguous `IRegion` that contains all cells in the supplied array. We\n     * invoke the mapper callback only on the cells in the supplied coordinate\n     * array and store the result. Returns the resulting 2-dimensional array.\n     */\n    public static sparseMapCells<T>(\n        cells: ICellCoordinate[],\n        mapper: (row: number, col: number) => T,\n    ): T[][] {\n        const bounds = Regions.getBoundingRegion(cells);\n        if (bounds == null) {\n            return null;\n        }\n\n        const numRows = bounds.rows[1] + 1 - bounds.rows[0];\n        const numCols = bounds.cols[1] + 1 - bounds.cols[0];\n        const result = Utils.times(numRows, () => new Array<T>(numCols));\n        cells.forEach(([row, col]) => {\n            result[row - bounds.rows[0]][col - bounds.cols[0]] = mapper(row, col);\n        });\n        return result;\n    }\n\n    /**\n     * Returns the smallest single contiguous `IRegion` that contains all cells in the\n     * supplied array.\n     */\n    public static getBoundingRegion(cells: ICellCoordinate[]): IRegion {\n        let minRow: number;\n        let maxRow: number;\n        let minCol: number;\n        let maxCol: number;\n        for (const [row, col] of cells) {\n            minRow = (minRow == null || row < minRow) ? row : minRow;\n            maxRow = (maxRow == null || row > maxRow) ? row : maxRow;\n            minCol = (minCol == null || col < minCol) ? col : minCol;\n            maxCol = (maxCol == null || col > maxCol) ? col : maxCol;\n        }\n        if (minRow == null) {\n            return null;\n        }\n        return {\n            cols: [minCol, maxCol],\n            rows: [minRow, maxRow],\n        };\n    }\n\n    public static isValid(region: IRegion) {\n        if (region == null) {\n            return false;\n        }\n        if ((region.rows != null) && (region.rows[0] < 0 || region.rows[1] < 0)) {\n            return false;\n        }\n        if ((region.cols != null) && (region.cols[0] < 0 || region.cols[1] < 0)) {\n            return false;\n        }\n        return true;\n    }\n\n    public static isRegionValidForTable(region: IRegion, numRows: number, numCols: number) {\n        if (region.rows != null && (region.rows[0] >= numRows || region.rows[1] >= numRows)) {\n            return false;\n        }\n        if (region.cols != null && (region.cols[0] >= numCols || region.cols[1] >= numCols)) {\n            return false;\n        }\n        return true;\n    }\n\n    public static joinStyledRegionGroups(\n        selectedRegions: IRegion[],\n        otherRegions: IStyledRegionGroup[],\n        focusedCell: IFocusedCellCoordinates,\n    ) {\n        let regionGroups: IStyledRegionGroup[] = [];\n        if (otherRegions != null) {\n            regionGroups = regionGroups.concat(otherRegions);\n        }\n        if (selectedRegions != null && selectedRegions.length > 0) {\n            regionGroups.push({\n                className: Classes.TABLE_SELECTION_REGION,\n                regions: selectedRegions,\n            });\n        }\n\n        if (focusedCell != null) {\n            regionGroups.push({\n                className: Classes.TABLE_FOCUS_REGION,\n                regions: [Regions.cell(focusedCell.row, focusedCell.col)],\n            });\n        }\n        return regionGroups;\n    }\n\n    /**\n     * Iterates over the cells within an `IRegion`, invoking the callback with\n     * each cell's coordinates.\n     */\n    private static eachCellInRegion(\n        region: IRegion,\n        numRows: number,\n        numCols: number,\n        iteratee: (row: number, col: number) => void,\n    ) {\n        const cardinality = Regions.getRegionCardinality(region);\n        switch (cardinality) {\n            case RegionCardinality.FULL_TABLE:\n                for (let row = 0; row < numRows; row++) {\n                    for (let col = 0; col < numCols; col++) {\n                        iteratee(row, col);\n                    }\n                }\n                break;\n            case RegionCardinality.FULL_COLUMNS:\n                for (let row = 0; row < numRows; row++) {\n                    for (let col = region.cols[0]; col <= region.cols[1]; col++) {\n                        iteratee(row, col);\n                    }\n                }\n                break;\n            case RegionCardinality.FULL_ROWS:\n                for (let row = region.rows[0]; row <= region.rows[1]; row++) {\n                    for (let col = 0; col < numCols; col++) {\n                        iteratee(row, col);\n                    }\n                }\n                break;\n            case RegionCardinality.CELLS:\n                for (let row = region.rows[0]; row <= region.rows[1]; row++) {\n                    for (let col = region.cols[0]; col <= region.cols[1]; col++) {\n                        iteratee(row, col);\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }\n\n    private static regionsEqual(regionA: IRegion, regionB: IRegion) {\n        return Regions.intervalsEqual(regionA.rows, regionB.rows)\n            && Regions.intervalsEqual(regionA.cols, regionB.cols);\n    }\n\n    private static intervalsEqual(ivalA: ICellInterval, ivalB: ICellInterval) {\n        if (ivalA == null) {\n            return ivalB == null;\n        } else if (ivalB == null) {\n            return false;\n        } else {\n            return ivalA[0] === ivalB[0] && ivalA[1] === ivalB[1];\n        }\n    }\n\n    private static intervalContainsIndex(interval: ICellInterval, index: number) {\n        if (interval == null) {\n            return false;\n        }\n        return interval[0] <= index && interval[1] >= index;\n    }\n\n    private static intervalOverlaps(ivalA: ICellInterval, ivalB: ICellInterval) {\n        if (ivalA == null || ivalB == null) {\n            return false;\n        }\n        if (ivalA[1] < ivalB[0] || ivalA[0] > ivalB[1]) {\n            return false;\n        }\n        return true;\n    }\n\n    private static rowFirstComparator(a: ICellCoordinate, b: ICellCoordinate) {\n        const rowDiff = a[0] - b[0];\n        return rowDiff === 0 ? a[1] - b[1] : rowDiff;\n    }\n\n    private static numericalComparator(a: number, b: number) {\n        return a - b;\n    }\n\n    private static normalizeInterval(coord: number, coord2?: number) {\n        if (coord2 == null) {\n            coord2 = coord;\n        }\n\n        const interval = [coord, coord2];\n        interval.sort(Regions.numericalComparator);\n        return interval as ICellInterval;\n    }\n}\n"]}