/**
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@blueprintjs/core");
var classNames = require("classnames");
var React = require("react");
var Classes = require("../../common/classes");
var TruncatedPopoverMode;
(function (TruncatedPopoverMode) {
    TruncatedPopoverMode[TruncatedPopoverMode["ALWAYS"] = 0] = "ALWAYS";
    TruncatedPopoverMode[TruncatedPopoverMode["NEVER"] = 1] = "NEVER";
    TruncatedPopoverMode[TruncatedPopoverMode["WHEN_TRUNCATED"] = 2] = "WHEN_TRUNCATED";
})(TruncatedPopoverMode = exports.TruncatedPopoverMode || (exports.TruncatedPopoverMode = {}));
var TruncatedFormat = (function (_super) {
    tslib_1.__extends(TruncatedFormat, _super);
    function TruncatedFormat() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { isTruncated: false };
        _this.handleContentDivRef = function (ref) { return _this.contentDiv = ref; };
        return _this;
    }
    TruncatedFormat.prototype.render = function () {
        var _a = this.props, children = _a.children, detectTruncation = _a.detectTruncation, preformatted = _a.preformatted, truncateLength = _a.truncateLength, truncationSuffix = _a.truncationSuffix;
        var content = "" + children;
        var cellContent = content;
        if (!detectTruncation && truncateLength > 0 && cellContent.length > truncateLength) {
            cellContent = cellContent.substring(0, truncateLength) + truncationSuffix;
        }
        if (this.shouldShowPopover(content)) {
            var popoverClasses = classNames(Classes.TABLE_TRUNCATED_POPOVER, preformatted ? Classes.TABLE_POPOVER_WHITESPACE_PRE : Classes.TABLE_POPOVER_WHITESPACE_NORMAL);
            var popoverContent = React.createElement("div", { className: popoverClasses }, children);
            var className = classNames(this.props.className, Classes.TABLE_TRUNCATED_FORMAT);
            var constraints = [{
                    attachment: "together",
                    pin: true,
                    to: "window",
                }];
            var iconClasses = classNames(core_1.Classes.ICON_STANDARD, core_1.Classes.iconClass("more"));
            return (React.createElement("div", { className: className },
                React.createElement("div", { className: Classes.TABLE_TRUNCATED_VALUE, ref: this.handleContentDivRef }, cellContent),
                React.createElement(core_1.Popover, { className: Classes.TABLE_TRUNCATED_POPOVER_TARGET, tetherOptions: { constraints: constraints }, content: popoverContent, position: core_1.Position.BOTTOM, useSmartArrowPositioning: true, useSmartPositioning: true },
                    React.createElement("span", { className: iconClasses }))));
        }
        else {
            var className = classNames(this.props.className, Classes.TABLE_TRUNCATED_TEXT);
            return React.createElement("div", { className: className, ref: this.handleContentDivRef }, cellContent);
        }
    };
    TruncatedFormat.prototype.componentDidMount = function () {
        this.setTruncationState();
    };
    TruncatedFormat.prototype.componentDidUpdate = function () {
        this.setTruncationState();
    };
    TruncatedFormat.prototype.shouldShowPopover = function (content) {
        var _a = this.props, detectTruncation = _a.detectTruncation, showPopover = _a.showPopover, truncateLength = _a.truncateLength;
        switch (showPopover) {
            case TruncatedPopoverMode.ALWAYS:
                return true;
            case TruncatedPopoverMode.NEVER:
                return false;
            case TruncatedPopoverMode.WHEN_TRUNCATED:
                return detectTruncation
                    ? this.state.isTruncated
                    : (truncateLength > 0 && content.length > truncateLength);
            default:
                return false;
        }
    };
    TruncatedFormat.prototype.setTruncationState = function () {
        if (!this.props.detectTruncation) {
            return;
        }
        var isTruncated = this.contentDiv !== undefined &&
            (this.contentDiv.scrollWidth > this.contentDiv.clientWidth ||
                this.contentDiv.scrollHeight > this.contentDiv.clientHeight);
        if (this.state.isTruncated !== isTruncated) {
            this.setState({ isTruncated: isTruncated });
        }
    };
    return TruncatedFormat;
}(React.Component));
TruncatedFormat.defaultProps = {
    detectTruncation: true,
    preformatted: false,
    showPopover: TruncatedPopoverMode.WHEN_TRUNCATED,
    truncateLength: 80,
    truncationSuffix: "...",
};
exports.TruncatedFormat = TruncatedFormat;

//# sourceMappingURL=truncatedFormat.js.map
