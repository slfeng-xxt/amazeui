{"version":3,"sources":["../src/interactions/draggable.tsx"],"names":[],"mappings":"AAAA;;;;;GAKG;;;;AAGH,kDAAoD;AACpD,6BAA+B;AAC/B,oCAAsC;AAEtC,yCAAwC;AACxC,2CAA0C;AA6F1C,IAAM,mBAAmB,GAAG;IACxB,iBAAiB;IACjB,gBAAgB;CACnB,CAAC;AAEF;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AAEH,IAAa,SAAS;IAAS,qCAAoC;IAAnE;;IA2BA,CAAC;IAnBU,0BAAM,GAAb;QACI,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;IACpD,CAAC;IAEM,6CAAyB,GAAhC,UAAiC,SAA0B;QACvD,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,aAAK,CAAC,kBAAkB,CAAC,IAAI,CAAC,KAAK,EAAE,SAAS,EAAE,mBAAmB,CAAC,CAAC,CAAC,CAAC;YACvF,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAgB,EAAE,SAAS,CAAC,CAAC;QAC7E,CAAC;IACL,CAAC;IAEM,qCAAiB,GAAxB;QACI,IAAI,CAAC,MAAM,GAAG,IAAI,uBAAU,EAAE,CAAC;QAC/B,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAgB,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;IAC9E,CAAC;IAEM,wCAAoB,GAA3B;QACI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;QACrB,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;IACL,gBAAC;AAAD,CA3BA,AA2BC,CA3B8B,KAAK,CAAC,SAAS,GA2B7C;AA1BiB,sBAAY,GAAG;IACzB,cAAc,EAAE,IAAI;IACpB,eAAe,EAAE,KAAK;CACzB,CAAC;AAJO,SAAS;IADrB,UAAU;GACE,SAAS,CA2BrB;AA3BY,8BAAS","file":"interactions/draggable.js","sourcesContent":["/**\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport { IProps } from \"@blueprintjs/core\";\nimport * as PureRender from \"pure-render-decorator\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport { Utils } from \"../common/utils\";\nimport { DragEvents } from \"./dragEvents\";\n\nexport type IClientCoordinates = [number, number];\n\n/**\n * Various useful coordinate values are pre-computed for you and supplied to\n * onDragMove and onDragEnd callbacks.\n */\nexport interface ICoordinateData {\n    /**\n     * The client coordinates where the interaction was activated.\n     */\n    activation: IClientCoordinates;\n\n    /**\n     * The client coordinates of the current mouse event.\n     */\n    current: IClientCoordinates;\n\n    /**\n     * The difference between current and last client coordinates.\n     */\n    delta: IClientCoordinates;\n\n    /**\n     * The client coordinates of the previous mouse event.\n     */\n    last: IClientCoordinates;\n\n    /**\n     * The difference between current and activation client coordinates.\n     */\n    offset: IClientCoordinates;\n}\n\nexport interface IDragHandler {\n    /**\n     * Called when the mouse is pressed down. Drag and click operations may\n     * be cancelled at this point by returning false from this method.\n     */\n    onActivate?: (event: MouseEvent) => boolean;\n\n    /**\n     * Called every time the mouse is moved after activation and before the\n     * mouse is released. This method is also called on the last even when the\n     * mouse is released.\n     */\n    onDragMove?: (event: MouseEvent, coords: ICoordinateData) => void;\n\n    /**\n     * Called when the mouse is released iff the mouse was dragged after\n     * activation.\n     */\n    onDragEnd?: (event: MouseEvent, coords: ICoordinateData) => void;\n\n    /**\n     * Called when the mouse is released iff the mouse was NOT dragged after\n     * activation.\n     *\n     * This will be called asynchronously if `onDoubleClick` is defined. See\n     * that callback for more details.\n     */\n    onClick?: (event: MouseEvent) => void;\n\n    /**\n     * Called iff there are two click events within the timeout\n     * `DragEvents.DOUBLE_CLICK_TIMEOUT_MSEC`, which defaults to 500 msec.\n     *\n     * NOTE: Defining this callback requires that we wait to invoke the\n     * `onClick` callback until the timeout has expired and we are certain the\n     * interaction was only a single click. If this callback is not defined,\n     * the `onClick` callback will be invoked synchronously with the mouseup\n     * event.\n     */\n    onDoubleClick?: (event: MouseEvent) => void;\n\n    /**\n     * This prevents mouse events from performing their default operation such\n     * as text selection.\n     * @default true\n     */\n    preventDefault?: boolean;\n\n    /**\n     * This prevents the event from propagating up to parent elements.\n     * @default false\n     */\n    stopPropagation?: boolean;\n}\n\nexport interface IDraggableProps extends IProps, IDragHandler {\n}\n\nconst REATTACH_PROPS_KEYS = [\n    \"stopPropagation\",\n    \"preventDefault\",\n];\n\n/**\n * This component provides a simple interface for combined drag and/or click\n * events.\n *\n * Since the mouse interactions for drag and click are overloaded, here are\n * the events that will fire in these cases:\n *\n * A Click Interaction\n * 1. The user presses down on the render element, triggering the onActivate\n *    callback.\n * 2. The user releases the mouse button without moving it, triggering the\n *    onClick callback.\n *\n * A Drag Interaction\n * 1. The user presses down on the render element, triggering the onActivate\n *    callback.\n * 2. The user moves the mouse, triggering the onDragMove callback.\n * 3. The user moves the mouse, triggering the onDragMove callback.\n * 4. The user moves the mouse, triggering the onDragMove callback.\n * 5. The user releases the mouse button, triggering a final onDragMove\n *    callback as well as an onDragEnd callback.\n *\n * If `false` is returned from the onActivate callback, no further events\n * will be fired until the next activation.\n */\n@PureRender\nexport class Draggable extends React.Component<IDraggableProps, {}> {\n    public static defaultProps = {\n        preventDefault: true,\n        stopPropagation: false,\n    };\n\n    private events: DragEvents;\n\n    public render() {\n        return React.Children.only(this.props.children);\n    }\n\n    public componentWillReceiveProps(nextProps: IDraggableProps) {\n        if (this.events && !Utils.shallowCompareKeys(this.props, nextProps, REATTACH_PROPS_KEYS)) {\n            this.events.attach(ReactDOM.findDOMNode(this) as HTMLElement, nextProps);\n        }\n    }\n\n    public componentDidMount() {\n        this.events = new DragEvents();\n        this.events.attach(ReactDOM.findDOMNode(this) as HTMLElement, this.props);\n    }\n\n    public componentWillUnmount() {\n        this.events.detach();\n        delete this.events;\n    }\n}\n"]}