/**
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var PureRender = require("pure-render-decorator");
var React = require("react");
var dragEvents_1 = require("../interactions/dragEvents");
var draggable_1 = require("../interactions/draggable");
var regions_1 = require("../regions");
var DragSelectable = DragSelectable_1 = (function (_super) {
    tslib_1.__extends(DragSelectable, _super);
    function DragSelectable() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.handleActivate = function (event) {
            if (!DragSelectable_1.isLeftClick(event)) {
                return false;
            }
            var region = _this.props.locateClick(event);
            if (!regions_1.Regions.isValid(region)) {
                return false;
            }
            var focusCellCoordinates = DragSelectable_1.getFocusCellCoordinatesFromRegion(region);
            _this.props.onFocus(focusCellCoordinates);
            if (_this.props.selectedRegionTransform != null) {
                region = _this.props.selectedRegionTransform(region, event);
            }
            var foundIndex = regions_1.Regions.findMatchingRegion(_this.props.selectedRegions, region);
            if (foundIndex !== -1) {
                // If re-clicking on an existing region, we either carefully
                // remove it if the meta key is used or otherwise we clear the
                // selection entirely.
                if (dragEvents_1.DragEvents.isAdditive(event)) {
                    var newSelectedRegions = _this.props.selectedRegions.slice();
                    newSelectedRegions.splice(foundIndex, 1);
                    _this.props.onSelection(newSelectedRegions);
                }
                else {
                    _this.props.onSelection([]);
                }
                return false;
            }
            if (dragEvents_1.DragEvents.isAdditive(event) && _this.props.allowMultipleSelection) {
                _this.props.onSelection(regions_1.Regions.add(_this.props.selectedRegions, region));
            }
            else {
                _this.props.onSelection([region]);
            }
            return true;
        };
        _this.handleDragMove = function (event, coords) {
            var region = (_this.props.allowMultipleSelection) ?
                _this.props.locateDrag(event, coords) :
                _this.props.locateClick(event);
            if (!regions_1.Regions.isValid(region)) {
                return;
            }
            if (_this.props.selectedRegionTransform != null) {
                region = _this.props.selectedRegionTransform(region, event, coords);
            }
            _this.props.onSelection(regions_1.Regions.update(_this.props.selectedRegions, region));
        };
        _this.handleClick = function (event) {
            if (!DragSelectable_1.isLeftClick(event)) {
                return false;
            }
            var region = _this.props.locateClick(event);
            if (!regions_1.Regions.isValid(region)) {
                _this.props.onSelection([]);
                return false;
            }
            if (_this.props.selectedRegionTransform != null) {
                region = _this.props.selectedRegionTransform(region, event);
            }
            if (_this.props.selectedRegions.length > 0) {
                _this.props.onSelection(regions_1.Regions.update(_this.props.selectedRegions, region));
            }
            else {
                _this.props.onSelection([region]);
            }
            return false;
        };
        return _this;
    }
    DragSelectable.isLeftClick = function (event) {
        return event.button === 0;
    };
    DragSelectable.getFocusCellCoordinatesFromRegion = function (region) {
        var regionCardinality = regions_1.Regions.getRegionCardinality(region);
        switch (regionCardinality) {
            case regions_1.RegionCardinality.FULL_TABLE:
                return { col: 0, row: 0 };
            case regions_1.RegionCardinality.FULL_COLUMNS:
                return { col: region.cols[0], row: 0 };
            case regions_1.RegionCardinality.FULL_ROWS:
                return { col: 0, row: region.rows[0] };
            case regions_1.RegionCardinality.CELLS:
                return { col: region.cols[0], row: region.rows[0] };
            default:
                return null;
        }
    };
    DragSelectable.prototype.render = function () {
        var draggableProps = this.getDraggableProps();
        return (React.createElement(draggable_1.Draggable, tslib_1.__assign({}, draggableProps, { preventDefault: false }), this.props.children));
    };
    DragSelectable.prototype.getDraggableProps = function () {
        return this.props.onSelection == null ? {} : {
            onActivate: this.handleActivate,
            onClick: this.handleClick,
            onDragMove: this.handleDragMove,
        };
    };
    return DragSelectable;
}(React.Component));
DragSelectable = DragSelectable_1 = tslib_1.__decorate([
    PureRender
], DragSelectable);
exports.DragSelectable = DragSelectable;
var DragSelectable_1;

//# sourceMappingURL=selectable.js.map
