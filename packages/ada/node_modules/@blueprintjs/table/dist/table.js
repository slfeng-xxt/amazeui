/**
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@blueprintjs/core");
var core_2 = require("@blueprintjs/core");
var classNames = require("classnames");
var PureRender = require("pure-render-decorator");
var React = require("react");
var column_1 = require("./column");
var Classes = require("./common/classes");
var clipboard_1 = require("./common/clipboard");
var grid_1 = require("./common/grid");
var utils_1 = require("./common/utils");
var columnHeader_1 = require("./headers/columnHeader");
var columnHeaderCell_1 = require("./headers/columnHeaderCell");
var rowHeader_1 = require("./headers/rowHeader");
var resizeSensor_1 = require("./interactions/resizeSensor");
var guides_1 = require("./layers/guides");
var regions_1 = require("./layers/regions");
var locator_1 = require("./locator");
var regions_2 = require("./regions");
var tableBody_1 = require("./tableBody");
var Table = Table_1 = (function (_super) {
    tslib_1.__extends(Table, _super);
    function Table(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.handleCopy = function (e) {
            var grid = _this.grid;
            var _a = _this.props, getCellClipboardData = _a.getCellClipboardData, onCopy = _a.onCopy;
            var selectedRegions = _this.state.selectedRegions;
            if (getCellClipboardData == null) {
                return;
            }
            // prevent "real" copy from being called
            e.preventDefault();
            e.stopPropagation();
            var cells = regions_2.Regions.enumerateUniqueCells(selectedRegions, grid.numRows, grid.numCols);
            var sparse = regions_2.Regions.sparseMapCells(cells, getCellClipboardData);
            if (sparse != null) {
                var success = clipboard_1.Clipboard.copyCells(sparse);
                core_1.Utils.safeInvoke(onCopy, success);
            }
        };
        _this.selectAll = function () {
            var selectionHandler = _this.getEnabledSelectionHandler(regions_2.RegionCardinality.FULL_TABLE);
            // clicking on upper left hand corner sets selection to "all"
            // regardless of current selection state (clicking twice does not deselect table)
            selectionHandler([regions_2.Regions.table()]);
        };
        _this.handleSelectAllHotkey = function (e) {
            // prevent "real" select all from happening as well
            e.preventDefault();
            e.stopPropagation();
            _this.selectAll();
        };
        _this.columnHeaderCellRenderer = function (columnIndex) {
            var props = _this.getColumnProps(columnIndex);
            var columnLoading = _this.hasLoadingOption(props.loadingOptions, regions_2.ColumnLoadingOption.HEADER);
            var renderColumnHeader = props.renderColumnHeader;
            if (renderColumnHeader != null) {
                var columnHeader = renderColumnHeader(columnIndex);
                var columnHeaderLoading = columnHeader.props.loading;
                return React.cloneElement(columnHeader, {
                    loading: columnHeaderLoading != null ? columnHeaderLoading : columnLoading,
                });
            }
            else if (props.name != null) {
                return React.createElement(columnHeaderCell_1.ColumnHeaderCell, tslib_1.__assign({}, props, { loading: columnLoading }));
            }
            else {
                return React.createElement(columnHeaderCell_1.ColumnHeaderCell, tslib_1.__assign({}, props, { loading: columnLoading, name: utils_1.Utils.toBase26Alpha(columnIndex) }));
            }
        };
        _this.bodyCellRenderer = function (rowIndex, columnIndex) {
            var columnProps = _this.getColumnProps(columnIndex);
            var cell = columnProps.renderCell(rowIndex, columnIndex);
            var cellLoading = cell.props.loading;
            var loading = cellLoading != null
                ? cellLoading
                : _this.hasLoadingOption(columnProps.loadingOptions, regions_2.ColumnLoadingOption.CELLS);
            return React.cloneElement(cell, tslib_1.__assign({}, columnProps, { loading: loading }));
        };
        _this.handleFocusMoveLeft = function (e) { return _this.handleFocusMove(e, "left"); };
        _this.handleFocusMoveRight = function (e) { return _this.handleFocusMove(e, "right"); };
        _this.handleFocusMoveUp = function (e) { return _this.handleFocusMove(e, "up"); };
        _this.handleFocusMoveDown = function (e) { return _this.handleFocusMove(e, "down"); };
        _this.handleColumnWidthChanged = function (columnIndex, width) {
            var selectedRegions = _this.state.selectedRegions;
            var columnWidths = _this.state.columnWidths.slice();
            if (regions_2.Regions.hasFullTable(selectedRegions)) {
                for (var col = 0; col < columnWidths.length; col++) {
                    columnWidths[col] = width;
                }
            }
            if (regions_2.Regions.hasFullColumn(selectedRegions, columnIndex)) {
                regions_2.Regions.eachUniqueFullColumn(selectedRegions, function (col) {
                    columnWidths[col] = width;
                });
            }
            else {
                columnWidths[columnIndex] = width;
            }
            _this.invalidateGrid();
            _this.setState({ columnWidths: columnWidths });
            var onColumnWidthChanged = _this.props.onColumnWidthChanged;
            if (onColumnWidthChanged != null) {
                onColumnWidthChanged(columnIndex, width);
            }
        };
        _this.handleRowHeightChanged = function (rowIndex, height) {
            var selectedRegions = _this.state.selectedRegions;
            var rowHeights = _this.state.rowHeights.slice();
            if (regions_2.Regions.hasFullTable(selectedRegions)) {
                for (var row = 0; row < rowHeights.length; row++) {
                    rowHeights[row] = height;
                }
            }
            if (regions_2.Regions.hasFullRow(selectedRegions, rowIndex)) {
                regions_2.Regions.eachUniqueFullRow(selectedRegions, function (row) {
                    rowHeights[row] = height;
                });
            }
            else {
                rowHeights[rowIndex] = height;
            }
            _this.invalidateGrid();
            _this.setState({ rowHeights: rowHeights });
            var onRowHeightChanged = _this.props.onRowHeightChanged;
            if (onRowHeightChanged != null) {
                onRowHeightChanged(rowIndex, height);
            }
        };
        _this.handleRootScroll = function (_event) {
            // Bug #211 - Native browser text selection events can cause the root
            // element to scroll even though it has a overflow:hidden style. The
            // only viable solution to this is to unscroll the element after the
            // browser scrolls it.
            if (_this.rootTableElement != null) {
                _this.rootTableElement.scrollLeft = 0;
                _this.rootTableElement.scrollTop = 0;
            }
        };
        _this.handleBodyScroll = function (event) {
            // Prevent the event from propagating to avoid a resize event on the
            // resize sensor.
            event.stopPropagation();
            var _a = _this.state, locator = _a.locator, isLayoutLocked = _a.isLayoutLocked;
            if (locator != null && !isLayoutLocked) {
                var viewportRect = locator.getViewportRect();
                _this.setState({ viewportRect: viewportRect });
            }
        };
        _this.handleColumnResizeGuide = function (verticalGuides) {
            _this.setState({ verticalGuides: verticalGuides });
        };
        _this.handleRowResizeGuide = function (horizontalGuides) {
            _this.setState({ horizontalGuides: horizontalGuides });
        };
        _this.clearSelection = function (_selectedRegions) {
            _this.handleSelection([]);
        };
        // no good way to call arrow-key keyboard events from tests
        /* istanbul ignore next */
        _this.handleFocusMove = function (e, direction) {
            e.preventDefault();
            e.stopPropagation();
            var focusedCell = _this.state.focusedCell;
            var newFocusedCell = { col: focusedCell.col, row: focusedCell.row };
            var grid = _this.grid;
            switch (direction) {
                case "up":
                    newFocusedCell.row -= 1;
                    break;
                case "down":
                    newFocusedCell.row += 1;
                    break;
                case "left":
                    newFocusedCell.col -= 1;
                    break;
                case "right":
                    newFocusedCell.col += 1;
                    break;
                default:
                    break;
            }
            if (newFocusedCell.row < 0 || newFocusedCell.row >= grid.numRows ||
                newFocusedCell.col < 0 || newFocusedCell.col >= grid.numCols) {
                return;
            }
            // change selection to match new focus cell location
            var newSelectionRegions = [regions_2.Regions.cell(newFocusedCell.row, newFocusedCell.col)];
            _this.handleSelection(newSelectionRegions);
            _this.handleFocus(newFocusedCell);
        };
        _this.handleFocus = function (focusedCell) {
            if (!_this.props.enableFocus) {
                // don't set focus state if focus is not allowed
                return;
            }
            // only set focused cell state if not specified in props
            if (_this.props.focusedCell == null) {
                _this.setState({ focusedCell: focusedCell });
            }
            core_1.Utils.safeInvoke(_this.props.onFocus, focusedCell);
        };
        _this.handleSelection = function (selectedRegions) {
            // only set selectedRegions state if not specified in props
            if (_this.props.selectedRegions == null) {
                _this.setState({ selectedRegions: selectedRegions });
            }
            var onSelection = _this.props.onSelection;
            if (onSelection != null) {
                onSelection(selectedRegions);
            }
        };
        _this.handleLayoutLock = function (isLayoutLocked) {
            if (isLayoutLocked === void 0) { isLayoutLocked = false; }
            _this.setState({ isLayoutLocked: isLayoutLocked });
        };
        _this.hasLoadingOption = function (loadingOptions, loadingOption) {
            if (loadingOptions == null) {
                return undefined;
            }
            return loadingOptions.indexOf(loadingOption) >= 0;
        };
        _this.setBodyRef = function (ref) { return _this.bodyElement = ref; };
        _this.setMenuRef = function (ref) { return _this.menuElement = ref; };
        _this.setRootTableRef = function (ref) { return _this.rootTableElement = ref; };
        _this.setRowHeaderRef = function (ref) { return _this.rowHeaderElement = ref; };
        var _a = _this.props, defaultRowHeight = _a.defaultRowHeight, defaultColumnWidth = _a.defaultColumnWidth, numRows = _a.numRows, columnWidths = _a.columnWidths, rowHeights = _a.rowHeights, children = _a.children;
        _this.childrenArray = React.Children.toArray(children);
        _this.columnIdToIndex = Table_1.createColumnIdIndex(_this.childrenArray);
        // Create height/width arrays using the lengths from props and
        // children, the default values from props, and finally any sparse
        // arrays passed into props.
        var newColumnWidths = _this.childrenArray.map(function () { return defaultColumnWidth; });
        newColumnWidths = utils_1.Utils.assignSparseValues(newColumnWidths, columnWidths);
        var newRowHeights = utils_1.Utils.times(numRows, function () { return defaultRowHeight; });
        newRowHeights = utils_1.Utils.assignSparseValues(newRowHeights, rowHeights);
        var selectedRegions = (props.selectedRegions == null) ? [] : props.selectedRegions;
        var focusedCell;
        if (props.enableFocus) {
            if (props.focusedCell != null) {
                focusedCell = props.focusedCell;
            }
            else {
                focusedCell = { col: 0, row: 0 };
            }
        }
        _this.state = {
            columnWidths: newColumnWidths,
            focusedCell: focusedCell,
            isLayoutLocked: false,
            rowHeights: newRowHeights,
            selectedRegions: selectedRegions,
        };
        return _this;
    }
    Table.createColumnIdIndex = function (children) {
        var columnIdToIndex = {};
        for (var i = 0; i < children.length; i++) {
            var key = children[i].props.id;
            if (key != null) {
                columnIdToIndex[String(key)] = i;
            }
        }
        return columnIdToIndex;
    };
    Table.prototype.componentWillReceiveProps = function (nextProps) {
        var _this = this;
        var defaultRowHeight = nextProps.defaultRowHeight, defaultColumnWidth = nextProps.defaultColumnWidth, columnWidths = nextProps.columnWidths, focusedCell = nextProps.focusedCell, rowHeights = nextProps.rowHeights, children = nextProps.children, numRows = nextProps.numRows, selectedRegions = nextProps.selectedRegions;
        var newChildArray = React.Children.toArray(children);
        // Try to maintain widths of columns by looking up the width of the
        // column that had the same `ID` prop. If none is found, use the
        // previous width at the same index.
        var previousColumnWidths = newChildArray.map(function (child, index) {
            var mappedIndex = _this.columnIdToIndex[child.props.id];
            return _this.state.columnWidths[mappedIndex != null ? mappedIndex : index];
        });
        // Make sure the width/height arrays have the correct length, but keep
        // as many existing widths/heights when possible. Also, apply the
        // sparse width/heights from props.
        var newColumnWidths = this.state.columnWidths;
        newColumnWidths = utils_1.Utils.arrayOfLength(newColumnWidths, newChildArray.length, defaultColumnWidth);
        newColumnWidths = utils_1.Utils.assignSparseValues(newColumnWidths, previousColumnWidths);
        newColumnWidths = utils_1.Utils.assignSparseValues(newColumnWidths, columnWidths);
        var newRowHeights = this.state.rowHeights;
        newRowHeights = utils_1.Utils.arrayOfLength(newRowHeights, numRows, defaultRowHeight);
        newRowHeights = utils_1.Utils.assignSparseValues(newRowHeights, rowHeights);
        var numCols = newColumnWidths.length;
        var newSelectedRegions = selectedRegions;
        if (selectedRegions == null) {
            // if we're in uncontrolled mode, filter out all selected regions that don't
            // fit in the current new table dimensions
            newSelectedRegions = this.state.selectedRegions.filter(function (region) {
                return regions_2.Regions.isRegionValidForTable(region, numRows, numCols);
            });
        }
        var newFocusedCellCoordinates = (focusedCell == null)
            ? this.state.focusedCell
            : focusedCell;
        this.childrenArray = newChildArray;
        this.columnIdToIndex = Table_1.createColumnIdIndex(this.childrenArray);
        this.invalidateGrid();
        this.setState({
            columnWidths: newColumnWidths,
            focusedCell: newFocusedCellCoordinates,
            rowHeights: newRowHeights,
            selectedRegions: newSelectedRegions,
        });
    };
    Table.prototype.render = function () {
        var _a = this.props, className = _a.className, isRowHeaderShown = _a.isRowHeaderShown;
        this.validateGrid();
        return (React.createElement("div", { className: classNames(Classes.TABLE_CONTAINER, className), ref: this.setRootTableRef, onScroll: this.handleRootScroll },
            React.createElement("div", { className: Classes.TABLE_TOP_CONTAINER },
                isRowHeaderShown ? this.renderMenu() : undefined,
                this.renderColumnHeader()),
            React.createElement("div", { className: Classes.TABLE_BOTTOM_CONTAINER },
                isRowHeaderShown ? this.renderRowHeader() : undefined,
                this.renderBody())));
    };
    Table.prototype.renderHotkeys = function () {
        var hotkeys = [this.maybeRenderCopyHotkey(), this.maybeRenderSelectAllHotkey(), this.maybeRenderFocusHotkeys()];
        return (React.createElement(core_2.Hotkeys, null, hotkeys.filter(function (element) { return element !== undefined; })));
    };
    /**
     * When the component mounts, the HTML Element refs will be available, so
     * we constructor the Locator, which queries the elements' bounding
     * ClientRects.
     */
    Table.prototype.componentDidMount = function () {
        var _this = this;
        this.validateGrid();
        var locator = new locator_1.Locator(this.rootTableElement, this.bodyElement, this.grid);
        var viewportRect = locator.getViewportRect();
        this.setState({ locator: locator, viewportRect: viewportRect });
        this.resizeSensorDetach = resizeSensor_1.ResizeSensor.attach(this.rootTableElement, function () {
            if (!_this.state.isLayoutLocked) {
                _this.setState({ viewportRect: locator.getViewportRect() });
            }
        });
        this.syncMenuWidth();
    };
    Table.prototype.componentWillUnmount = function () {
        if (this.resizeSensorDetach != null) {
            this.resizeSensorDetach();
            delete this.resizeSensorDetach;
        }
    };
    Table.prototype.componentDidUpdate = function () {
        var locator = this.state.locator;
        if (locator != null) {
            this.validateGrid();
            locator.setGrid(this.grid);
        }
        this.syncMenuWidth();
    };
    Table.prototype.validateProps = function (props) {
        var WARNING_MESSAGE = "Children of Table must be Columns";
        React.Children.forEach(props.children, function (child) {
            // save as a variable so that union type narrowing works
            var cType = child.type;
            if (typeof cType === "string") {
                console.warn(WARNING_MESSAGE);
            }
            else {
                var isColumn = cType.prototype === column_1.Column.prototype || column_1.Column.prototype.isPrototypeOf(cType);
                if (!isColumn) {
                    console.warn(WARNING_MESSAGE);
                }
            }
        });
    };
    Table.prototype.renderMenu = function () {
        var classes = classNames(Classes.TABLE_MENU, (_a = {},
            _a[Classes.TABLE_SELECTION_ENABLED] = this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_TABLE),
            _a));
        return (React.createElement("div", { className: classes, ref: this.setMenuRef, onClick: this.selectAll }, this.maybeRenderMenuRegions()));
        var _a;
    };
    Table.prototype.syncMenuWidth = function () {
        var _a = this, menuElement = _a.menuElement, rowHeaderElement = _a.rowHeaderElement;
        if (menuElement != null && rowHeaderElement != null) {
            var width = rowHeaderElement.getBoundingClientRect().width;
            menuElement.style.width = width + "px";
        }
    };
    Table.prototype.getColumnProps = function (columnIndex) {
        var column = this.childrenArray[columnIndex];
        return column.props;
    };
    Table.prototype.renderColumnHeader = function () {
        var grid = this.grid;
        var _a = this.state, locator = _a.locator, selectedRegions = _a.selectedRegions, viewportRect = _a.viewportRect;
        var _b = this.props, allowMultipleSelection = _b.allowMultipleSelection, fillBodyWithGhostCells = _b.fillBodyWithGhostCells, isColumnResizable = _b.isColumnResizable, loadingOptions = _b.loadingOptions, maxColumnWidth = _b.maxColumnWidth, minColumnWidth = _b.minColumnWidth, selectedRegionTransform = _b.selectedRegionTransform;
        var classes = classNames(Classes.TABLE_COLUMN_HEADERS, (_c = {},
            _c[Classes.TABLE_SELECTION_ENABLED] = this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_COLUMNS),
            _c));
        var columnIndices = grid.getColumnIndicesInRect(viewportRect, fillBodyWithGhostCells);
        return (React.createElement("div", { className: classes },
            React.createElement(columnHeader_1.ColumnHeader, tslib_1.__assign({ allowMultipleSelection: allowMultipleSelection, cellRenderer: this.columnHeaderCellRenderer, grid: grid, isResizable: isColumnResizable, loading: this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.COLUMN_HEADERS), locator: locator, maxColumnWidth: maxColumnWidth, minColumnWidth: minColumnWidth, onColumnWidthChanged: this.handleColumnWidthChanged, onFocus: this.handleFocus, onLayoutLock: this.handleLayoutLock, onResizeGuide: this.handleColumnResizeGuide, onSelection: this.getEnabledSelectionHandler(regions_2.RegionCardinality.FULL_COLUMNS), selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, viewportRect: viewportRect }, columnIndices), this.props.children),
            this.maybeRenderColumnHeaderRegions()));
        var _c;
    };
    Table.prototype.renderRowHeader = function () {
        var grid = this.grid;
        var _a = this.state, locator = _a.locator, selectedRegions = _a.selectedRegions, viewportRect = _a.viewportRect;
        var _b = this.props, allowMultipleSelection = _b.allowMultipleSelection, fillBodyWithGhostCells = _b.fillBodyWithGhostCells, isRowResizable = _b.isRowResizable, loadingOptions = _b.loadingOptions, maxRowHeight = _b.maxRowHeight, minRowHeight = _b.minRowHeight, renderRowHeader = _b.renderRowHeader, selectedRegionTransform = _b.selectedRegionTransform;
        var classes = classNames(Classes.TABLE_ROW_HEADERS, (_c = {},
            _c[Classes.TABLE_SELECTION_ENABLED] = this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_ROWS),
            _c));
        var rowIndices = grid.getRowIndicesInRect(viewportRect, fillBodyWithGhostCells);
        return (React.createElement("div", { className: classes, ref: this.setRowHeaderRef },
            React.createElement(rowHeader_1.RowHeader, tslib_1.__assign({ allowMultipleSelection: allowMultipleSelection, grid: grid, locator: locator, isResizable: isRowResizable, loading: this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.ROW_HEADERS), maxRowHeight: maxRowHeight, minRowHeight: minRowHeight, onFocus: this.handleFocus, onLayoutLock: this.handleLayoutLock, onResizeGuide: this.handleRowResizeGuide, onRowHeightChanged: this.handleRowHeightChanged, onSelection: this.getEnabledSelectionHandler(regions_2.RegionCardinality.FULL_ROWS), renderRowHeader: renderRowHeader, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, viewportRect: viewportRect }, rowIndices)),
            this.maybeRenderRowHeaderRegions()));
        var _c;
    };
    Table.prototype.renderBody = function () {
        var grid = this.grid;
        var _a = this.props, allowMultipleSelection = _a.allowMultipleSelection, fillBodyWithGhostCells = _a.fillBodyWithGhostCells, loadingOptions = _a.loadingOptions, renderBodyContextMenu = _a.renderBodyContextMenu, selectedRegionTransform = _a.selectedRegionTransform;
        var _b = this.state, locator = _b.locator, selectedRegions = _b.selectedRegions, viewportRect = _b.viewportRect, verticalGuides = _b.verticalGuides, horizontalGuides = _b.horizontalGuides;
        var style = grid.getRect().sizeStyle();
        var rowIndices = grid.getRowIndicesInRect(viewportRect, fillBodyWithGhostCells);
        var columnIndices = grid.getColumnIndicesInRect(viewportRect, fillBodyWithGhostCells);
        var noVerticalScroll = fillBodyWithGhostCells &&
            grid.isGhostIndex(rowIndices.rowIndexEnd, 0) &&
            viewportRect != null && viewportRect.top === 0 ||
            this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.ROW_HEADERS);
        var noHorizontalScroll = fillBodyWithGhostCells &&
            grid.isGhostIndex(0, columnIndices.columnIndexEnd) &&
            viewportRect != null && viewportRect.left === 0 ||
            this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.COLUMN_HEADERS);
        // disable scroll for ghost cells
        var classes = classNames(Classes.TABLE_BODY, (_c = {},
            _c[Classes.TABLE_NO_HORIZONTAL_SCROLL] = noHorizontalScroll,
            _c[Classes.TABLE_NO_VERTICAL_SCROLL] = noVerticalScroll,
            _c[Classes.TABLE_SELECTION_ENABLED] = this.isSelectionModeEnabled(regions_2.RegionCardinality.CELLS),
            _c));
        return (React.createElement("div", { className: classes, onScroll: this.handleBodyScroll, ref: this.setBodyRef },
            React.createElement("div", { className: Classes.TABLE_BODY_SCROLL_CLIENT, style: style },
                React.createElement(tableBody_1.TableBody, tslib_1.__assign({ allowMultipleSelection: allowMultipleSelection, cellRenderer: this.bodyCellRenderer, grid: grid, loading: this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.CELLS), locator: locator, onFocus: this.handleFocus, onSelection: this.getEnabledSelectionHandler(regions_2.RegionCardinality.CELLS), renderBodyContextMenu: renderBodyContextMenu, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, viewportRect: viewportRect }, rowIndices, columnIndices)),
                this.maybeRenderBodyRegions(),
                React.createElement(guides_1.GuideLayer, { className: Classes.TABLE_RESIZE_GUIDES, verticalGuides: verticalGuides, horizontalGuides: horizontalGuides }))));
        var _c;
    };
    Table.prototype.isGuidesShowing = function () {
        return this.state.verticalGuides != null || this.state.horizontalGuides != null;
    };
    Table.prototype.isSelectionModeEnabled = function (selectionMode) {
        return this.props.selectionModes.indexOf(selectionMode) >= 0;
    };
    Table.prototype.getEnabledSelectionHandler = function (selectionMode) {
        if (!this.isSelectionModeEnabled(selectionMode)) {
            // If the selection mode isn't enabled, return a callback that
            // will clear the selection. For example, if row selection is
            // disabled, clicking on the row header will clear the table's
            // selection. If all selection modes are enabled, clicking on the
            // same region twice will clear the selection.
            return this.clearSelection;
        }
        else {
            return this.handleSelection;
        }
    };
    Table.prototype.invalidateGrid = function () {
        this.grid = null;
    };
    Table.prototype.validateGrid = function () {
        if (this.grid == null) {
            var _a = this.props, defaultRowHeight = _a.defaultRowHeight, defaultColumnWidth = _a.defaultColumnWidth;
            var _b = this.state, rowHeights = _b.rowHeights, columnWidths = _b.columnWidths;
            this.grid = new grid_1.Grid(rowHeights, columnWidths, grid_1.Grid.DEFAULT_BLEED, defaultRowHeight, defaultColumnWidth);
        }
    };
    /**
     * Renders a `RegionLayer`, applying styles to the regions using the
     * supplied `IRegionStyler`. `RegionLayer` is a `PureRender` component, so
     * the `IRegionStyler` should be a new instance on every render if we
     * intend to redraw the region layer.
     */
    Table.prototype.maybeRenderRegions = function (getRegionStyle) {
        if (this.isGuidesShowing()) {
            return undefined;
        }
        var regionGroups = regions_2.Regions.joinStyledRegionGroups(this.state.selectedRegions, this.props.styledRegionGroups, this.state.focusedCell);
        return regionGroups.map(function (regionGroup, index) {
            return (React.createElement(regions_1.RegionLayer, { className: classNames(regionGroup.className), key: index, regions: regionGroup.regions, getRegionStyle: getRegionStyle }));
        });
    };
    Table.prototype.maybeRenderCopyHotkey = function () {
        var getCellClipboardData = this.props.getCellClipboardData;
        if (getCellClipboardData != null) {
            return (React.createElement(core_2.Hotkey, { key: "copy-hotkey", label: "Copy selected table cells", group: "Table", combo: "mod+c", onKeyDown: this.handleCopy }));
        }
        else {
            return undefined;
        }
    };
    Table.prototype.maybeRenderFocusHotkeys = function () {
        var enableFocus = this.props.enableFocus;
        if (enableFocus != null) {
            return [
                React.createElement(core_2.Hotkey, { key: "move left", label: "Move focus cell left", group: "Table", combo: "left", onKeyDown: this.handleFocusMoveLeft }),
                React.createElement(core_2.Hotkey, { key: "move right", label: "Move focus cell right", group: "Table", combo: "right", onKeyDown: this.handleFocusMoveRight }),
                React.createElement(core_2.Hotkey, { key: "move up", label: "Move focus cell up", group: "Table", combo: "up", onKeyDown: this.handleFocusMoveUp }),
                React.createElement(core_2.Hotkey, { key: "move down", label: "Move focus cell down", group: "Table", combo: "down", onKeyDown: this.handleFocusMoveDown }),
            ];
        }
        else {
            return [];
        }
    };
    Table.prototype.maybeRenderSelectAllHotkey = function () {
        if (this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_TABLE)) {
            return (React.createElement(core_2.Hotkey, { key: "select-all-hotkey", label: "Select all", group: "Table", combo: "mod+a", onKeyDown: this.handleSelectAllHotkey }));
        }
        else {
            return undefined;
        }
    };
    Table.prototype.maybeRenderBodyRegions = function () {
        var _this = this;
        var styler = function (region) {
            var cardinality = regions_2.Regions.getRegionCardinality(region);
            var style = _this.grid.getRegionStyle(region);
            switch (cardinality) {
                case regions_2.RegionCardinality.CELLS:
                    return style;
                case regions_2.RegionCardinality.FULL_COLUMNS:
                    style.top = "-1px";
                    return style;
                case regions_2.RegionCardinality.FULL_ROWS:
                    style.left = "-1px";
                    return style;
                case regions_2.RegionCardinality.FULL_TABLE:
                    style.left = "-1px";
                    style.top = "-1px";
                    return style;
                default:
                    return { display: "none" };
            }
        };
        return this.maybeRenderRegions(styler);
    };
    Table.prototype.maybeRenderMenuRegions = function () {
        var _this = this;
        var styler = function (region) {
            var grid = _this.grid;
            var viewportRect = _this.state.viewportRect;
            if (viewportRect == null) {
                return {};
            }
            var cardinality = regions_2.Regions.getRegionCardinality(region);
            var style = grid.getRegionStyle(region);
            switch (cardinality) {
                case regions_2.RegionCardinality.FULL_TABLE:
                    style.right = "0px";
                    style.bottom = "0px";
                    style.top = "0px";
                    style.left = "0px";
                    style.borderBottom = "none";
                    style.borderRight = "none";
                    return style;
                default:
                    return { display: "none" };
            }
        };
        return this.maybeRenderRegions(styler);
    };
    Table.prototype.maybeRenderColumnHeaderRegions = function () {
        var _this = this;
        var styler = function (region) {
            var grid = _this.grid;
            var viewportRect = _this.state.viewportRect;
            if (viewportRect == null) {
                return {};
            }
            var cardinality = regions_2.Regions.getRegionCardinality(region);
            var style = grid.getRegionStyle(region);
            switch (cardinality) {
                case regions_2.RegionCardinality.FULL_TABLE:
                    style.left = "-1px";
                    style.borderLeft = "none";
                    style.bottom = "-1px";
                    style.transform = "translate3d(" + -viewportRect.left + "px, 0, 0)";
                    return style;
                case regions_2.RegionCardinality.FULL_COLUMNS:
                    style.bottom = "-1px";
                    style.transform = "translate3d(" + -viewportRect.left + "px, 0, 0)";
                    return style;
                default:
                    return { display: "none" };
            }
        };
        return this.maybeRenderRegions(styler);
    };
    Table.prototype.maybeRenderRowHeaderRegions = function () {
        var _this = this;
        var styler = function (region) {
            var grid = _this.grid;
            var viewportRect = _this.state.viewportRect;
            if (viewportRect == null) {
                return {};
            }
            var cardinality = regions_2.Regions.getRegionCardinality(region);
            var style = grid.getRegionStyle(region);
            switch (cardinality) {
                case regions_2.RegionCardinality.FULL_TABLE:
                    style.top = "-1px";
                    style.borderTop = "none";
                    style.right = "-1px";
                    style.transform = "translate3d(0, " + -viewportRect.top + "px, 0)";
                    return style;
                case regions_2.RegionCardinality.FULL_ROWS:
                    style.right = "-1px";
                    style.transform = "translate3d(0, " + -viewportRect.top + "px, 0)";
                    return style;
                default:
                    return { display: "none" };
            }
        };
        return this.maybeRenderRegions(styler);
    };
    return Table;
}(core_1.AbstractComponent));
Table.defaultProps = {
    allowMultipleSelection: true,
    defaultColumnWidth: 150,
    defaultRowHeight: 20,
    enableFocus: false,
    fillBodyWithGhostCells: false,
    isRowHeaderShown: true,
    loadingOptions: [],
    minColumnWidth: 50,
    minRowHeight: 20,
    numRows: 0,
    renderRowHeader: rowHeader_1.renderDefaultRowHeader,
    selectionModes: regions_2.SelectionModes.ALL,
};
Table = Table_1 = tslib_1.__decorate([
    PureRender,
    core_2.HotkeysTarget
], Table);
exports.Table = Table;
var Table_1;

//# sourceMappingURL=table.js.map
