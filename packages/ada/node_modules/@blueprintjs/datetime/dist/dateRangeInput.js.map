{"version":3,"sources":["../src/dateRangeInput.tsx"],"names":[],"mappings":"AAAA;;;;;GAKG;;;;AAEH,uCAAyC;AACzC,+BAAiC;AACjC,6BAA+B;AAE/B,0CAW2B;AAE3B,gDAS4B;AAC5B,mDAI0B;AAC1B,qDAG2B;AA8I1B,CAAC;AAgBD,CAAC;AAEF;IAAoC,0CAA6D;IAkC7F,wBAAmB,KAA2B,EAAE,OAAa;QAA7D,YACI,kBAAM,KAAK,EAAE,OAAO,CAAC,SAWxB;QA3BM,iBAAW,GAAG,0BAA0B,CAAC;QAIxC,iBAAW,GAAG;YAClB,WAAW,EAAE,UAAC,GAAqB;gBAC/B,KAAI,CAAC,WAAW,GAAG,GAAG,CAAC;gBACvB,YAAK,CAAC,UAAU,CAAC,KAAI,CAAC,KAAK,CAAC,aAAa,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;YAC7D,CAAC;YACD,aAAa,EAAE,UAAC,GAAqB;gBACjC,KAAI,CAAC,aAAa,GAAG,GAAG,CAAC;gBACzB,YAAK,CAAC,UAAU,CAAC,KAAI,CAAC,KAAK,CAAC,eAAe,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;YAC/D,CAAC;SACJ,CAAC;QA4HF,8BAA8B;QAC9B,8BAA8B;QAEtB,iCAA2B,GAAG,UAAC,aAAwB;YAC3D,mFAAmF;YACnF,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;gBACrB,MAAM,CAAC;YACX,CAAC;YAED,EAAE,CAAC,CAAC,KAAI,CAAC,KAAK,CAAC,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC;gBAC3B,IAAA,8DAA4E,EAA3E,qBAAa,EAAE,mBAAW,CAAkD;gBAEnF,IAAI,MAAM,GAAG,IAAI,CAAC;gBAElB,IAAI,mBAAmB,SAAS,CAAC;gBACjC,IAAI,iBAAiB,SAAS,CAAC;gBAE/B,IAAI,gBAAgB,SAAQ,CAAC;gBAC7B,IAAI,cAAc,SAAQ,CAAC;gBAE3B,EAAE,CAAC,CAAC,wBAAY,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;oBAC9B,uEAAuE;oBACvE,mBAAmB,GAAG,IAAI,CAAC;oBAC3B,iBAAiB,GAAG,KAAK,CAAC;oBAE1B,iFAAiF;oBACjF,gBAAgB,GAAG,IAAI,CAAC;gBAC5B,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,wBAAY,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBACnC,mDAAmD;oBACnD,mBAAmB,GAAG,KAAK,CAAC;oBAC5B,iBAAiB,GAAG,IAAI,CAAC;oBAEzB,cAAc,GAAG,IAAI,CAAC;gBAC1B,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC,CAAC;oBACrC,MAAM,GAAG,KAAK,CAAC;oBACf,mBAAmB,GAAG,KAAK,CAAC;oBAC5B,iBAAiB,GAAG,KAAK,CAAC;gBAC9B,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAI,CAAC,KAAK,CAAC,gBAAgB,KAAK,6BAAiB,CAAC,KAAK,CAAC,CAAC,CAAC;oBACjE,+BAA+B;oBAC/B,mBAAmB,GAAG,IAAI,CAAC;oBAC3B,iBAAiB,GAAG,KAAK,CAAC;gBAC9B,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,6BAA6B;oBAC7B,mBAAmB,GAAG,KAAK,CAAC;oBAC5B,iBAAiB,GAAG,IAAI,CAAC;gBAC7B,CAAC;gBAED,KAAI,CAAC,QAAQ,CAAC;oBACV,MAAM,QAAA;oBACN,WAAW,aAAA;oBACX,aAAa,eAAA;oBACb,iBAAiB,mBAAA;oBACjB,mBAAmB,qBAAA;oBACnB,gBAAgB,kBAAA;oBAChB,cAAc,gBAAA;oBACd,cAAc,EAAE,KAAI,CAAC,sBAAsB,CAAC,WAAW,CAAC;oBACxD,gBAAgB,EAAE,KAAI,CAAC,sBAAsB,CAAC,aAAa,CAAC;oBAC5D,4BAA4B,EAAE,KAAK;iBACtC,CAAC,CAAC;YACP,CAAC;YACD,YAAK,CAAC,UAAU,CAAC,KAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,aAAa,CAAC,CAAC;QACzD,CAAC,CAAA;QAEO,sCAAgC,GAAG,UAAC,YAAuB,EACvB,WAAiB,EACjB,eAAkC;YAC1E,mFAAmF;YACnF,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;gBAAC,MAAM,CAAC;YAAC,CAAC;YAEnC,EAAE,CAAC,CAAC,YAAY,IAAI,IAAI,CAAC,CAAC,CAAC;gBACvB,iFAAiF;gBACjF,IAAM,iBAAiB,GAAG,CAAC,KAAI,CAAC,KAAK,CAAC,gBAAgB,KAAK,6BAAiB,CAAC,GAAG,CAAC,CAAC;gBAElF,KAAI,CAAC,QAAQ,CAAC;oBACV,iBAAiB,mBAAA;oBACjB,cAAc,EAAE,IAAI;oBACpB,mBAAmB,EAAE,CAAC,iBAAiB;oBACvC,gBAAgB,EAAE,KAAI,CAAC,KAAK,CAAC,gBAAgB;oBAC7C,gBAAgB,EAAE,IAAI;iBACzB,CAAC,CAAC;YACP,CAAC;YAAC,IAAI,CAAC,CAAC;gBACE,IAAA,6DAAyE,EAAxE,oBAAY,EAAE,kBAAU,CAAiD;gBAEhF,IAAM,mBAAmB,GAAG,CAAC,eAAe,IAAI,IAAI,CAAC;sBAC/C,eAAe,KAAK,6BAAiB,CAAC,KAAK;sBAC3C,KAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC;gBACrC,IAAM,iBAAiB,GAAG,CAAC,eAAe,IAAI,IAAI,CAAC;sBAC7C,eAAe,KAAK,6BAAiB,CAAC,GAAG;sBACzC,KAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC;gBAEnC,KAAI,CAAC,QAAQ,CAAC;oBACV,mBAAmB,qBAAA;oBACnB,iBAAiB,mBAAA;oBACjB,cAAc,EAAE,KAAI,CAAC,sBAAsB,CAAC,UAAU,CAAC;oBACvD,gBAAgB,EAAE,CAAC,mBAAmB,CAAC,GAAG,6BAAiB,CAAC,KAAK,GAAG,6BAAiB,CAAC,GAAG;oBACzF,uBAAuB,EAAE,KAAI,CAAC,KAAK,CAAC,gBAAgB;oBACpD,gBAAgB,EAAE,KAAI,CAAC,sBAAsB,CAAC,YAAY,CAAC;oBAC3D,4BAA4B,EAAE,IAAI;iBACrC,CAAC,CAAC;YACP,CAAC;QACL,CAAC,CAAA;QAED,oBAAoB;QACpB,oBAAoB;QAEpB,WAAW;QAEX,oEAAoE;QACpE,4DAA4D;QAC5D,kEAAkE;QAC1D,wBAAkB,GAAG,UAAC,CAAwC;YAClE,IAAM,YAAY,GAAG,CAAC,CAAC,OAAO,KAAK,WAAI,CAAC,GAAG,CAAC;YAC5C,IAAM,cAAc,GAAG,CAAC,CAAC,QAAQ,CAAC;YAElC,qEAAqE;YACrE,mEAAmE;YACnE,sEAAsE;YACtE,wEAAwE;YACxE,IAAM,oBAAoB,GAAG,KAAI,CAAC,KAAK,CAAC,gBAAgB,KAAK,6BAAiB,CAAC,KAAK,CAAC;YACrF,IAAM,kBAAkB,GAAG,KAAI,CAAC,KAAK,CAAC,gBAAgB,KAAK,6BAAiB,CAAC,GAAG,CAAC;YAEjF,IAAI,iBAA0B,CAAC;YAC/B,IAAI,mBAA4B,CAAC;YAEjC,gCAAgC;YAChC,EAAE,CAAC,CAAC,oBAAoB,IAAI,YAAY,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;gBAC1D,mBAAmB,GAAG,KAAK,CAAC;gBAC5B,iBAAiB,GAAG,IAAI,CAAC;YAC7B,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,kBAAkB,IAAI,YAAY,IAAI,cAAc,CAAC,CAAC,CAAC;gBAC9D,mBAAmB,GAAG,IAAI,CAAC;gBAC3B,iBAAiB,GAAG,KAAK,CAAC;YAC9B,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,wDAAwD;gBACxD,MAAM,CAAC;YACX,CAAC;YAED,sEAAsE;YACtE,iEAAiE;YACjE,CAAC,CAAC,cAAc,EAAE,CAAC;YAEnB,KAAI,CAAC,QAAQ,CAAC;gBACV,mBAAmB,qBAAA;gBACnB,iBAAiB,mBAAA;gBACjB,4BAA4B,EAAE,KAAK;aACtC,CAAC,CAAC;QACP,CAAC,CAAA;QAED,aAAa;QAEL,0BAAoB,GAAG;YAC3B,wEAAwE;YACxE,wEAAwE;YACxE,iEAAiE;YACjE,KAAI,CAAC,QAAQ,CAAC,EAAE,4BAA4B,EAAE,KAAK,EAAE,CAAC,CAAC;QAC3D,CAAC,CAAA;QAED,QAAQ;QAEA,sBAAgB,GAAG,UAAC,CAAqC;YAC7D,oEAAoE;YACpE,qDAAqD;YACrD,CAAC,CAAC,eAAe,EAAE,CAAC;QACxB,CAAC,CAAA;QAED,QAAQ;QAEA,2BAAqB,GAAG,UAAC,CAAoC;YACjE,KAAI,CAAC,gBAAgB,CAAC,CAAC,EAAE,6BAAiB,CAAC,KAAK,CAAC,CAAC;QACtD,CAAC,CAAA;QAEO,yBAAmB,GAAG,UAAC,CAAoC;YAC/D,KAAI,CAAC,gBAAgB,CAAC,CAAC,EAAE,6BAAiB,CAAC,GAAG,CAAC,CAAC;QACpD,CAAC,CAAA;QAEO,sBAAgB,GAAG,UAAC,EAAqC,EAAE,QAA2B;YACpF,IAAA,qDAAkE,EAAhE,cAAI,EAAE,kBAAM,CAAqD;YACzE,IAAM,WAAW,GAAG,KAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;YAEtE,wEAAwE;YACxE,mEAAmE;YACnE,IAAM,gBAAgB,GAAG,CAAC,KAAI,CAAC,KAAK,CAAC,4BAA4B,CAAC;kBAC5D,KAAI,CAAC,KAAK,CAAC,gBAAgB;kBAC3B,QAAQ,CAAC;YAEf,KAAI,CAAC,QAAQ;oBACT,MAAM,EAAE,IAAI;oBACZ,gBAAgB,kBAAA;;gBAChB,GAAC,IAAI,CAAC,WAAW,IAAG,WAAW;gBAC/B,GAAC,IAAI,CAAC,cAAc,IAAG,IAAI;gBAC3B,mBAAgB,GAAE,QAAQ;gBAC1B,0BAAuB,GAAE,KAAI,CAAC,KAAK,CAAC,gBAAgB;gBACpD,+BAA4B,GAAE,KAAK;oBACrC,CAAC;;QACP,CAAC,CAAA;QAED,OAAO;QAEC,0BAAoB,GAAG,UAAC,CAAoC;YAChE,KAAI,CAAC,eAAe,CAAC,CAAC,EAAE,6BAAiB,CAAC,KAAK,CAAC,CAAC;QACrD,CAAC,CAAA;QAEO,wBAAkB,GAAG,UAAC,CAAoC;YAC9D,KAAI,CAAC,eAAe,CAAC,CAAC,EAAE,6BAAiB,CAAC,GAAG,CAAC,CAAC;QACnD,CAAC,CAAA;QAEO,qBAAe,GAAG,UAAC,EAAqC,EAAE,QAA2B;YACnF,IAAA,qDAAkE,EAAhE,cAAI,EAAE,kBAAM,CAAqD;YAEzE,IAAM,cAAc,GAAG,KAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;YACnE,IAAM,iBAAiB,GAAG,KAAI,CAAC,YAAY,EAAE,CAAC;YAE9C,IAAI,SAAS;gBACT,GAAC,IAAI,CAAC,cAAc,IAAG,KAAK;gBAC5B,0BAAuB,GAAE,KAAK;mBACjC,CAAC;YAEF,EAAE,CAAC,CAAC,KAAI,CAAC,YAAY,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;gBACxC,EAAE,CAAC,CAAC,iBAAiB,CAAC,CAAC,CAAC;oBACpB,SAAS,wBACF,SAAS,eACX,IAAI,CAAC,WAAW,IAAG,KAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,eAAe,CAAC,MAC1E,CAAC;gBACN,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,SAAS,wBACF,SAAS,eACX,IAAI,CAAC,WAAW,IAAG,IAAI,KACvB,IAAI,CAAC,aAAa,IAAG,MAAM,CAAC,IAAI,CAAC,MACrC,CAAC;gBACN,CAAC;YACL,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,oBAAoB,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAC9D,EAAE,CAAC,CAAC,CAAC,iBAAiB,CAAC,CAAC,CAAC;oBACrB,SAAS,wBACF,SAAS,eACX,IAAI,CAAC,WAAW,IAAG,IAAI,KACvB,IAAI,CAAC,aAAa,IAAG,cAAc,MACvC,CAAC;gBACN,CAAC;gBACD,YAAK,CAAC,UAAU,CAAC,KAAI,CAAC,KAAK,CAAC,OAAO,EAAE,KAAI,CAAC,uBAAuB,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC,CAAC;YACjG,CAAC;YAED,KAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;;QAC7B,CAAC,CAAA;QAED,SAAS;QAED,4BAAsB,GAAG,UAAC,CAAoC;YAClE,KAAI,CAAC,iBAAiB,CAAC,CAAC,EAAE,6BAAiB,CAAC,KAAK,CAAC,CAAC;YACnD,YAAK,CAAC,UAAU,CAAC,KAAI,CAAC,KAAK,CAAC,eAAe,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;QAC7D,CAAC,CAAA;QAEO,0BAAoB,GAAG,UAAC,CAAoC;YAChE,KAAI,CAAC,iBAAiB,CAAC,CAAC,EAAE,6BAAiB,CAAC,GAAG,CAAC,CAAC;YACjD,YAAK,CAAC,UAAU,CAAC,KAAI,CAAC,KAAK,CAAC,aAAa,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;QAC3D,CAAC,CAAA;QAEO,uBAAiB,GAAG,UAAC,CAAoC,EAAE,QAA2B;YAC1F,IAAM,WAAW,GAAI,CAAC,CAAC,MAA2B,CAAC,KAAK,CAAC;YAEjD,IAAA,4DAAI,CAAqD;YACjE,IAAM,cAAc,GAAG,KAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;YAC5D,IAAM,iBAAiB,GAAG,KAAI,CAAC,YAAY,EAAE,CAAC;YAE9C,IAAI,SAAS,GAAyB,EAAE,uBAAuB,EAAE,KAAK,EAAE,CAAC;YAEzE,EAAE,CAAC,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC3B,+DAA+D;gBAC/D,gEAAgE;gBAChE,uDAAuD;gBACvD,EAAE,CAAC,CAAC,iBAAiB,CAAC,CAAC,CAAC;oBACpB,SAAS,wBAAQ,SAAS,eAAG,IAAI,CAAC,WAAW,IAAG,EAAE,MAAE,CAAC;gBACzD,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,SAAS,wBAAQ,SAAS,eAAG,IAAI,CAAC,WAAW,IAAG,EAAE,KAAG,IAAI,CAAC,aAAa,IAAG,MAAM,CAAC,IAAI,CAAC,MAAE,CAAC;gBAC7F,CAAC;gBACD,YAAK,CAAC,UAAU,CAAC,KAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,KAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC;YAChG,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAI,CAAC,uBAAuB,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;gBACtD,yDAAyD;gBACzD,iEAAiE;gBACjE,mEAAmE;gBACnE,mBAAmB;gBACnB,EAAE,CAAC,CAAC,iBAAiB,CAAC,CAAC,CAAC;oBACpB,SAAS,wBAAQ,SAAS,eAAG,IAAI,CAAC,WAAW,IAAG,WAAW,MAAE,CAAC;gBAClE,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,SAAS,wBAAQ,SAAS,eAAG,IAAI,CAAC,WAAW,IAAG,WAAW,KAAG,IAAI,CAAC,aAAa,IAAG,cAAc,MAAE,CAAC;gBACxG,CAAC;gBACD,EAAE,CAAC,CAAC,KAAI,CAAC,oBAAoB,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;oBACtD,YAAK,CAAC,UAAU,CAAC,KAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,KAAI,CAAC,uBAAuB,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC,CAAC;gBAClG,CAAC;YACL,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,SAAS,wBAAQ,SAAS,eAAG,IAAI,CAAC,WAAW,IAAG,WAAW,MAAE,CAAC;YAClE,CAAC;YAED,KAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;;QAC7B,CAAC,CAAA;QAED,sBAAsB;QACtB,sBAAsB;QAEd,wBAAkB,GAAG;YACzB,KAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;YACjC,YAAK,CAAC,UAAU,CAAC,KAAI,CAAC,KAAK,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;QACtD,CAAC,CAAA;QASO,wBAAkB,GAAG,UAAC,UAAkB;YAC5C,EAAE,CAAC,CAAC,KAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAChC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YACxB,CAAC;YACD,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,KAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QACjD,CAAC,CAAA;QAEO,qBAAe,GAAG,UAAC,KAAkB;YAAlB,sBAAA,EAAA,QAAQ,KAAI,CAAC,KAAK;YACjC,IAAA,iCAAY,EAAE,mBAAK,CAAW;YACtC,EAAE,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC;gBAChB,MAAM,CAAC,0CAA8B,CAAC,KAAK,CAAC,CAAC;YACjD,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,YAAY,IAAI,IAAI,CAAC,CAAC,CAAC;gBAC9B,MAAM,CAAC,0CAA8B,CAAC,YAAY,CAAC,CAAC;YACxD,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC,IAAI,CAAC,CAAoB,CAAC;YAC3D,CAAC;QACL,CAAC,CAAA;QAEO,sBAAgB,GAAG;YACjB,IAAA,gBAA2C,EAAzC,gCAAa,EAAE,4BAAW,CAAgB;YAElD,yFAAyF;YACzF,0FAA0F;YAC1F,qCAAqC;YACrC,IAAM,sBAAsB,GAAG,KAAI,CAAC,sBAAsB,CAAC,aAAa,EAAE,6BAAiB,CAAC,KAAK,CAAC,CAAC;YACnG,IAAM,eAAe,GAAG,CAAC,aAAa,EAAE,sBAAsB,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC,CAAC;YAE7F,MAAM,CAAC,eAAe,CAAC,GAAG,CAAC,UAAC,aAA6B;gBACrD,MAAM,CAAC,KAAI,CAAC,uBAAuB,CAAC,aAAa,CAAC;sBAC5C,4BAAgB,CAAC,aAAa,CAAC;sBAC/B,SAAS,CAAC;YACpB,CAAC,CAAc,CAAC;QACpB,CAAC,CAAA;QAEO,qBAAe,GAAG,UAAC,QAA2B,EAAE,kBAAoC;YACxF,MAAM,CAAC,UAAU,CAAC,kBAAkB,CAAC,SAAS;gBAC1C,GAAC,cAAO,CAAC,aAAa,IAAG,KAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC;oBAC7D,CAAC;;QACP,CAAC,CAAA;QAEO,2BAAqB,GAAG,UAAC,QAA2B;YAChD,IAAA,gEAAM,CAAqD;YAC3D,IAAA,sCAAc,EAAE,gCAAW,EAAE,oCAAa,EAAE,gCAAW,CAAY;YAE3E,EAAE,CAAC,CAAC,WAAW,IAAI,IAAI,IAAI,CAAC,KAAI,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;gBAC9C,iEAAiE;gBACjE,MAAM,CAAC,WAAW,CAAC;YACvB,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;gBACxB,MAAM,CAAC,CAAC,WAAW,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,WAAW,CAAC;YACpD,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,wBAAY,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;gBACrC,MAAM,CAAC,EAAE,CAAC;YACd,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;gBAC9C,MAAM,CAAC,KAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC;YACxC,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAI,CAAC,mCAAmC,CAAC,aAAa,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAC3E,MAAM,CAAC,KAAI,CAAC,KAAK,CAAC,uBAAuB,CAAC;YAC9C,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,MAAM,CAAC,KAAI,CAAC,sBAAsB,CAAC,aAAa,CAAC,CAAC;YACtD,CAAC;QACL,CAAC,CAAA;QAEO,+BAAyB,GAAG,UAAC,QAA2B;YACpD,IAAA,uFAAc,CAA4D;YAClF,IAAM,eAAe,GAAG,QAAQ,KAAK,6BAAiB,CAAC,KAAK,CAAC;YAE7D,IAAM,UAAU,GAAG,eAAe,GAAG,KAAI,CAAC,KAAK,CAAC,sBAAsB,GAAG,KAAI,CAAC,KAAK,CAAC,sBAAsB,CAAC;YAC3G,IAAM,aAAa,GAAG,eAAe,GAAG,YAAY,GAAG,UAAU,CAAC;YAElE,MAAM,CAAC,cAAc,GAAG,UAAU,GAAG,aAAa,CAAC;QACvD,CAAC,CAAA;QAEO,4BAAsB,GAAG,UAAC,UAAyB,EAAE,MAAe;YACxE,EAAE,CAAC,CAAC,wBAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAC3B,MAAM,CAAC,EAAE,CAAC;YACd,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;gBAC/B,MAAM,CAAC,KAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC;YACzC,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG,MAAM,GAAG,KAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YAC5E,CAAC;QACL,CAAC,CAAA;QAEO,sCAAgC,GAAG,UAAC,QAA2B;YACnE,IAAM,eAAe,GAAG,0CAA8B,CAAC,KAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YACzE,EAAE,CAAC,CAAC,QAAQ,KAAK,6BAAiB,CAAC,KAAK,CAAC,CAAC,CAAC;gBACvC,MAAM,CAAC;oBACH,IAAI,EAAE;wBACF,WAAW,EAAE,kBAAkB;wBAC/B,WAAW,EAAE,kBAAkB;wBAC/B,cAAc,EAAE,qBAAqB;wBACrC,aAAa,EAAE,eAAe;qBACjC;oBACD,MAAM,EAAE;wBACJ,eAAe,EAAE,CAAC,eAAe,IAAI,IAAI,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,SAAS;wBAC3E,WAAW,EAAE,KAAI,CAAC,KAAK,CAAC,gBAAgB;wBACxC,WAAW,EAAE,KAAI,CAAC,KAAK,CAAC,gBAAgB;wBACxC,cAAc,EAAE,KAAI,CAAC,KAAK,CAAC,mBAAmB;wBAC9C,aAAa,EAAE,KAAI,CAAC,KAAK,CAAC,aAAa;qBAC1C;iBACyB,CAAC;YACnC,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,MAAM,CAAC;oBACH,IAAI,EAAE;wBACF,WAAW,EAAE,gBAAgB;wBAC7B,WAAW,EAAE,gBAAgB;wBAC7B,cAAc,EAAE,mBAAmB;wBACnC,aAAa,EAAE,aAAa;qBAC/B;oBACD,MAAM,EAAE;wBACJ,eAAe,EAAE,CAAC,eAAe,IAAI,IAAI,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,SAAS;wBAC3E,WAAW,EAAE,KAAI,CAAC,KAAK,CAAC,cAAc;wBACtC,WAAW,EAAE,KAAI,CAAC,KAAK,CAAC,cAAc;wBACtC,cAAc,EAAE,KAAI,CAAC,KAAK,CAAC,iBAAiB;wBAC5C,aAAa,EAAE,KAAI,CAAC,KAAK,CAAC,WAAW;qBACxC;iBACyB,CAAC;YACnC,CAAC;QACL,CAAC,CAAA;QAEO,6BAAuB,GAAG,UAAC,SAAyB,EAAE,YAAgC;YAC1F,IAAM,aAAa,GAAG,KAAI,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;YAC1D,IAAM,UAAU,GAAG,KAAI,CAAC,gCAAgC,CAAC,aAAa,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC;YAE7F,IAAM,QAAQ,GAAG,KAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC;YACpD,IAAM,SAAS,GAAG,KAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;YAEtD,MAAM,CAAC,CAAC,YAAY,KAAK,6BAAiB,CAAC,KAAK,CAAC;kBAC3C,CAAC,QAAQ,EAAE,SAAS,CAAC;kBACrB,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;QAChC,CAAC,CAAA;QAEO,wBAAkB,GAAG,UAAC,UAAyB;YACnD,EAAE,CAAC,CAAC,wBAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAC3B,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;gBAC/B,MAAM,CAAC,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC;YAC/B,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,MAAM,CAAC,4BAAgB,CAAC,UAAU,CAAC,CAAC;YACxC,CAAC;QACL,CAAC,CAAA;QAEO,sBAAgB,GAAG,UAAC,QAA4B;YACpD,MAAM,CAAC,CAAC,QAAQ,KAAK,6BAAiB,CAAC,KAAK,CAAC,GAAG,6BAAiB,CAAC,GAAG,GAAG,6BAAiB,CAAC,KAAK,CAAC;QACpG,CAAC,CAAA;QAEO,4BAAsB,GAAG,UAAC,YAA2B,EAAE,QAA2B;YAC9E,IAAA,qDAAmB,CAAgB;YAE3C,IAAM,aAAa,GAAG,KAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;YACtD,IAAM,iBAAiB,GAAG,KAAI,CAAC,gCAAgC,CAAC,aAAa,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC;YAEpG,EAAE,CAAC,CAAC,QAAQ,KAAK,6BAAiB,CAAC,KAAK,CAAC,CAAC,CAAC;gBACvC,MAAM,CAAC,mBAAmB;sBACpB,YAAY,CAAC,OAAO,CAAC,iBAAiB,EAAE,KAAK,CAAC;sBAC9C,YAAY,CAAC,aAAa,CAAC,iBAAiB,EAAE,KAAK,CAAC,CAAC;YAC/D,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,MAAM,CAAC,mBAAmB;sBACpB,YAAY,CAAC,QAAQ,CAAC,iBAAiB,EAAE,KAAK,CAAC;sBAC/C,YAAY,CAAC,cAAc,CAAC,iBAAiB,EAAE,KAAK,CAAC,CAAC;YAChE,CAAC;QACL,CAAC,CAAA;QAED;;;;WAIG;QACK,yCAAmC,GAAG,UAAC,YAA2B,EAAE,QAA2B;YACnG,MAAM,CAAC,CAAC,QAAQ,KAAK,6BAAiB,CAAC,KAAK,CAAC;kBACvC,KAAK;kBACL,KAAI,CAAC,sBAAsB,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAC;QAC9D,CAAC,CAAA;QAEO,kBAAY,GAAG;YACnB,MAAM,CAAC,KAAI,CAAC,KAAK,CAAC,KAAK,KAAK,SAAS,CAAC;QAC1C,CAAC,CAAA;QAEO,kBAAY,GAAG,UAAC,WAAmB;YACvC,MAAM,CAAC,WAAW,IAAI,IAAI,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,CAAC;QAC3D,CAAC,CAAA;QAEO,yBAAmB,GAAG,UAAC,QAA2B;YACtD,IAAM,MAAM,GAAG,KAAI,CAAC,gCAAgC,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC;YAC9D,IAAA,sCAAc,EAAE,gCAAW,EAAE,oCAAa,CAAY;YAE9D,IAAM,aAAa,GAAG,CAAC,cAAc,CAAC;kBAChC,KAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC;kBACpC,aAAa,CAAC;YAEpB,iEAAiE;YACjE,0BAA0B;YAE1B,EAAE,CAAC,CAAC,wBAAY,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;gBAC9B,MAAM,CAAC,KAAK,CAAC;YACjB,CAAC;YAED,EAAE,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;gBAC3B,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;YAED,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;gBACvC,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;YAED,EAAE,CAAC,CAAC,KAAI,CAAC,mCAAmC,CAAC,aAAa,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACpE,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;YAED,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC,CAAA;QAEO,6BAAuB,GAAG,UAAC,UAAyB;YACxD,MAAM,CAAC,mCAAuB,CAAC,UAAU,EAAE,KAAI,CAAC,KAAK,CAAC,OAAO,EAAE,KAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QACvF,CAAC,CAAA;QAEO,qBAAe,GAAG,UAAC,UAAyB;YAChD,MAAM,CAAC,2BAAe,CAAC,UAAU,EAAE,KAAI,CAAC,KAAK,CAAC,OAAO,EAAE,KAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QAC/E,CAAC,CAAA;QAnoBS,IAAA,4BAAqD,EAApD,qBAAa,EAAE,mBAAW,CAA2B;QAE5D,KAAI,CAAC,KAAK,GAAG;YACT,sBAAsB,EAAE,KAAI,CAAC,4BAA4B,CAAC,KAAK,EAAE,SAAS,CAAC;YAC3E,sBAAsB,EAAE,KAAI,CAAC,4BAA4B,CAAC,KAAK,EAAE,SAAS,CAAC;YAC3E,MAAM,EAAE,KAAK;YACb,WAAW,aAAA;YACX,aAAa,eAAA;SAChB,CAAC;;IACN,CAAC;IAEM,2CAAkB,GAAzB;QACU,IAAA,eAAgF,EAA9E,4CAAmB,EAAE,wCAAiB,EAAE,oDAAuB,CAAgB;QAEvF,IAAM,qBAAqB,GAAG,IAAI,CAAC,mBAAmB,CAAC,mBAAmB,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QAChG,IAAM,mBAAmB,GAAG,IAAI,CAAC,mBAAmB,CAAC,iBAAiB,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;QAE1F,EAAE,CAAC,CAAC,qBAAqB,CAAC,CAAC,CAAC;YACxB,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC;QAC/B,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC;YAC7B,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;QAC7B,CAAC;QAED,EAAE,CAAC,CAAC,mBAAmB,IAAI,uBAAuB,CAAC,CAAC,CAAC;YACjD,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC;QAChC,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,iBAAiB,IAAI,uBAAuB,CAAC,CAAC,CAAC;YACtD,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC;QAC9B,CAAC;IACL,CAAC;IAEM,+BAAM,GAAb;QACU,IAAA,eAA+C,EAA7C,oCAAe,EAAE,gCAAa,CAAgB;QAEtD,IAAM,cAAc,GAAG,CACnB,oBAAC,iCAAe,IACZ,mBAAmB,EAAE,IAAI,CAAC,KAAK,CAAC,mBAAmB,EACnD,gBAAgB,EAAE,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAC7C,wBAAwB,EAAE,IAAI,CAAC,KAAK,CAAC,wBAAwB,EAC7D,QAAQ,EAAE,IAAI,CAAC,2BAA2B,EAC1C,aAAa,EAAE,IAAI,CAAC,gCAAgC,EACpD,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,EAC3B,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,EAC3B,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,SAAS,EAC/B,KAAK,EAAE,IAAI,CAAC,gBAAgB,EAAE,GAChC,CACL,CAAC;QAEF,0FAA0F;QAC1F,8CAA8C;QAC9C,MAAM,CAAC,CACH,oBAAC,cAAO,qBACJ,MAAM,EAAE,IAAI,EACZ,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,EACzB,QAAQ,EAAE,eAAQ,CAAC,WAAW,IAC1B,IAAI,CAAC,KAAK,CAAC,YAAY,IAC3B,SAAS,EAAE,KAAK,EAChB,OAAO,EAAE,cAAc,EACvB,YAAY,EAAE,KAAK,EACnB,OAAO,EAAE,IAAI,CAAC,kBAAkB;YAEhC,6BAAK,SAAS,EAAE,cAAO,CAAC,aAAa;gBACjC,oBAAC,iBAAU,uBACH,eAAe,IACnB,SAAS,EAAE,IAAI,CAAC,eAAe,CAAC,6BAAiB,CAAC,KAAK,EAAE,eAAe,CAAC,EACzE,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,EAC7B,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC,aAAa,EACxC,MAAM,EAAE,IAAI,CAAC,oBAAoB,EACjC,QAAQ,EAAE,IAAI,CAAC,sBAAsB,EACrC,OAAO,EAAE,IAAI,CAAC,gBAAgB,EAC9B,OAAO,EAAE,IAAI,CAAC,qBAAqB,EACnC,SAAS,EAAE,IAAI,CAAC,kBAAkB,EAClC,WAAW,EAAE,IAAI,CAAC,oBAAoB,EACtC,WAAW,EAAE,IAAI,CAAC,yBAAyB,CAAC,6BAAiB,CAAC,KAAK,CAAC,EACpE,KAAK,EAAE,IAAI,CAAC,qBAAqB,CAAC,6BAAiB,CAAC,KAAK,CAAC,IAC5D;gBACF,oBAAC,iBAAU,uBACH,aAAa,IACjB,SAAS,EAAE,IAAI,CAAC,eAAe,CAAC,6BAAiB,CAAC,GAAG,EAAE,aAAa,CAAC,EACrE,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,EAC7B,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC,WAAW,EACtC,MAAM,EAAE,IAAI,CAAC,kBAAkB,EAC/B,QAAQ,EAAE,IAAI,CAAC,oBAAoB,EACnC,OAAO,EAAE,IAAI,CAAC,gBAAgB,EAC9B,OAAO,EAAE,IAAI,CAAC,mBAAmB,EACjC,SAAS,EAAE,IAAI,CAAC,kBAAkB,EAClC,WAAW,EAAE,IAAI,CAAC,oBAAoB,EACtC,WAAW,EAAE,IAAI,CAAC,yBAAyB,CAAC,6BAAiB,CAAC,GAAG,CAAC,EAClE,KAAK,EAAE,IAAI,CAAC,qBAAqB,CAAC,6BAAiB,CAAC,GAAG,CAAC,IAC1D,CACA,CACA,CACb,CAAC;IACN,CAAC;IAEM,kDAAyB,GAAhC,UAAiC,SAA+B;QAC5D,iBAAM,yBAAyB,YAAC,SAAS,CAAC,CAAC;QAE3C,IAAI,SAAS,GAAyB,EAAE,CAAC;QAEzC,EAAE,CAAC,CAAC,SAAS,CAAC,KAAK,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;YACjC,IAAA,oCAA8D,EAA7D,qBAAa,EAAE,mBAAW,CAAoC;YACrE,SAAS,wBAAQ,SAAS,IAAE,aAAa,eAAA,EAAE,WAAW,aAAA,GAAE,CAAC;QAC7D,CAAC;QAED,uFAAuF;QACvF,0FAA0F;QAC1F,IAAM,eAAe,GAAG,SAAS,CAAC,MAAM,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;QAC/D,EAAE,CAAC,CAAC,eAAe,IAAI,SAAS,CAAC,OAAO,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;YAC9D,IAAM,sBAAsB,GAAG,IAAI,CAAC,4BAA4B,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;YACvF,SAAS,wBAAQ,SAAS,IAAE,sBAAsB,wBAAA,GAAE,CAAC;QACzD,CAAC;QACD,EAAE,CAAC,CAAC,eAAe,IAAI,SAAS,CAAC,OAAO,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;YAC9D,IAAM,sBAAsB,GAAG,IAAI,CAAC,4BAA4B,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;YACvF,SAAS,wBAAQ,SAAS,IAAE,sBAAsB,wBAAA,GAAE,CAAC;QACzD,CAAC;QAED,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;IAC7B,CAAC;IAgTD,UAAU;IACV,UAAU;IAEF,4CAAmB,GAA3B,UAA4B,SAAkB,EAAE,QAA0B;QACtE,MAAM,CAAC,SAAS,IAAI,QAAQ,KAAK,SAAS,IAAI,QAAQ,CAAC,aAAa,KAAK,QAAQ,CAAC;IACtF,CAAC;IA2NO,6CAAoB,GAA5B,UAA6B,cAA6B,EAAE,QAA2B;QACnF,MAAM,CAAC,IAAI,CAAC,uBAAuB,CAAC,cAAc,CAAC;eAC5C,CAAC,IAAI,CAAC,sBAAsB,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;IAClE,CAAC;IAED,6FAA6F;IAC7F,iDAAiD;IACzC,qDAA4B,GAApC,UAAqC,KAA2B,EAAE,QAA+B;QAC7F,IAAM,IAAI,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;QAC7B,IAAM,WAAW,GAAG,cAAc,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAC1D,oEAAoE;QACpE,+EAA+E;QAC/E,MAAM,CAAC,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC,IAAI,KAAK,SAAS,CAAC,GAAG,WAAW,GAAG,IAAI,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;IACxG,CAAC;IACL,qBAAC;AAAD,CAxrBA,AAwrBC,CAxrBmC,wBAAiB;AACnC,2BAAY,GAAyB;IAC/C,mBAAmB,EAAE,KAAK;IAC1B,gBAAgB,EAAE,IAAI;IACtB,wBAAwB,EAAE,IAAI;IAC9B,QAAQ,EAAE,KAAK;IACf,aAAa,EAAE,EAAE;IACjB,MAAM,EAAE,YAAY;IACpB,kBAAkB,EAAE,cAAc;IAClC,OAAO,EAAE,kCAAiB,EAAE;IAC5B,OAAO,EAAE,kCAAiB,EAAE;IAC5B,iBAAiB,EAAE,cAAc;IACjC,uBAAuB,EAAE,mBAAmB;IAC5C,YAAY,EAAE,EAAE;IAChB,gBAAgB,EAAE,KAAK;IACvB,SAAS,EAAE,IAAI;IACf,eAAe,EAAE,EAAE;CACtB,CAAC;AAjBO,wCAAc","file":"dateRangeInput.js","sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport * as classNames from \"classnames\";\nimport * as moment from \"moment\";\nimport * as React from \"react\";\n\nimport {\n    AbstractComponent,\n    Classes,\n    IInputGroupProps,\n    InputGroup,\n    IPopoverProps,\n    IProps,\n    Keys,\n    Popover,\n    Position,\n    Utils,\n} from \"@blueprintjs/core\";\n\nimport {\n    DateRange,\n    DateRangeBoundary,\n    fromDateRangeToMomentDateRange,\n    fromMomentToDate,\n    isMomentInRange,\n    isMomentNull,\n    isMomentValidAndInRange,\n    MomentDateRange,\n} from \"./common/dateUtils\";\nimport {\n    getDefaultMaxDate,\n    getDefaultMinDate,\n    IDatePickerBaseProps,\n} from \"./datePickerCore\";\nimport {\n    DateRangePicker,\n    IDateRangeShortcut,\n} from \"./dateRangePicker\";\n\nexport interface IDateRangeInputProps extends IDatePickerBaseProps, IProps {\n    /**\n     * Whether the start and end dates of the range can be the same day.\n     * If `true`, clicking a selected date will create a one-day range.\n     * If `false`, clicking a selected date will clear the selection.\n     * @default false\n     */\n    allowSingleDayRange?: boolean;\n\n    /**\n     * Whether the calendar popover should close when a date range is fully selected.\n     * @default true\n     */\n    closeOnSelection?: boolean;\n\n    /**\n     * Whether displayed months in the calendar are contiguous.\n     * If false, each side of the calendar can move independently to non-contiguous months.\n     * @default true\n     */\n    contiguousCalendarMonths?: boolean;\n\n    /**\n     * The default date range to be used in the component when uncontrolled.\n     * This will be ignored if `value` is set.\n     */\n    defaultValue?: DateRange;\n\n    /**\n     * Whether the text inputs are non-interactive.\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * Props to pass to the end-date input.\n     */\n    endInputProps?: IInputGroupProps;\n\n    /**\n     * The format of each date in the date range. See options\n     * here: http://momentjs.com/docs/#/displaying/format/\n     * @default \"YYYY-MM-DD\"\n     */\n    format?: string;\n\n    /**\n     * The error message to display when the selected date is invalid.\n     * @default \"Invalid date\"\n     */\n    invalidDateMessage?: string;\n\n    /**\n     * Called when the user selects a day.\n     * If no days are selected, it will pass `[null, null]`.\n     * If a start date is selected but not an end date, it will pass `[selectedDate, null]`.\n     * If both a start and end date are selected, it will pass `[startDate, endDate]`.\n     */\n    onChange?: (selectedRange: DateRange) => void;\n\n    /**\n     * Called when the user finishes typing in a new date and the date causes an error state.\n     * If the date is invalid, `new Date(undefined)` will be returned for the corresponding\n     * boundary of the date range.\n     * If the date is out of range, the out-of-range date will be returned for the corresponding\n     * boundary of the date range (`onChange` is not called in this case).\n     */\n    onError?: (errorRange: DateRange) => void;\n\n    /**\n     * The error message to display when the date selected is out of range.\n     * @default \"Out of range\"\n     */\n    outOfRangeMessage?: string;\n\n    /**\n     * The error message to display when the selected dates overlap.\n     * This can only happen when typing dates in the input field.\n     * @default \"Overlapping dates\"\n     */\n    overlappingDatesMessage?: string;\n\n    /**\n     * The props to pass to the popover.\n     * `autoFocus`, `content`, and `enforceFocus` will be ignored to avoid compromising usability.\n     */\n    popoverProps?: Partial<IPopoverProps>;\n\n    /**\n     * Whether the entire text field should be selected on focus.\n     * @default false\n     */\n    selectAllOnFocus?: boolean;\n\n    /**\n     * Whether shortcuts to quickly select a range of dates are displayed or not.\n     * If `true`, preset shortcuts will be displayed.\n     * If `false`, no shortcuts will be displayed.\n     * If an array is provided, the custom shortcuts will be displayed.\n     * @default true\n     */\n    shortcuts?: boolean | IDateRangeShortcut[];\n\n    /**\n     * Props to pass to the start-date input.\n     */\n    startInputProps?: IInputGroupProps;\n\n    /**\n     * The currently selected date range.\n     * If this prop is present, the component acts in a controlled manner.\n     * To display no date range in the input fields, pass `[null, null]` to the value prop.\n     * To display an invalid date error in either input field, pass `new Date(undefined)`\n     * for the appropriate date in the value prop.\n     */\n    value?: DateRange;\n}\n\nexport interface IDateRangeInputState {\n    isOpen?: boolean;\n    boundaryToModify?: DateRangeBoundary;\n    lastFocusedField?: DateRangeBoundary;\n\n    formattedMinDateString?: string;\n    formattedMaxDateString?: string;\n\n    isStartInputFocused?: boolean;\n    isEndInputFocused?: boolean;\n\n    startInputString?: string;\n    endInputString?: string;\n\n    startHoverString?: string;\n    endHoverString?: string;\n\n    selectedEnd?: moment.Moment;\n    selectedStart?: moment.Moment;\n\n    shouldSelectAfterUpdate?: boolean;\n    wasLastFocusChangeDueToHover?: boolean;\n};\n\ninterface IStateKeysAndValuesObject {\n    keys: {\n        hoverString: \"startHoverString\" | \"endHoverString\";\n        inputString: \"startInputString\" | \"endInputString\";\n        isInputFocused: \"isStartInputFocused\" | \"isEndInputFocused\";\n        selectedValue: \"selectedStart\" | \"selectedEnd\";\n    };\n    values: {\n        controlledValue?: moment.Moment,\n        hoverString?: string;\n        inputString?: string;\n        isInputFocused?: boolean;\n        selectedValue?: moment.Moment;\n    };\n};\n\nexport class DateRangeInput extends AbstractComponent<IDateRangeInputProps, IDateRangeInputState> {\n    public static defaultProps: IDateRangeInputProps = {\n        allowSingleDayRange: false,\n        closeOnSelection: true,\n        contiguousCalendarMonths: true,\n        disabled: false,\n        endInputProps: {},\n        format: \"YYYY-MM-DD\",\n        invalidDateMessage: \"Invalid date\",\n        maxDate: getDefaultMaxDate(),\n        minDate: getDefaultMinDate(),\n        outOfRangeMessage: \"Out of range\",\n        overlappingDatesMessage: \"Overlapping dates\",\n        popoverProps: {},\n        selectAllOnFocus: false,\n        shortcuts: true,\n        startInputProps: {},\n    };\n\n    public displayName = \"Blueprint.DateRangeInput\";\n\n    private startInputRef: HTMLInputElement;\n    private endInputRef: HTMLInputElement;\n    private refHandlers = {\n        endInputRef: (ref: HTMLInputElement) => {\n            this.endInputRef = ref;\n            Utils.safeInvoke(this.props.endInputProps.inputRef, ref);\n        },\n        startInputRef: (ref: HTMLInputElement) => {\n            this.startInputRef = ref;\n            Utils.safeInvoke(this.props.startInputProps.inputRef, ref);\n        },\n    };\n\n    public constructor(props: IDateRangeInputProps, context?: any) {\n        super(props, context);\n\n        const [selectedStart, selectedEnd] = this.getInitialRange();\n\n        this.state = {\n            formattedMaxDateString: this.getFormattedMinMaxDateString(props, \"maxDate\"),\n            formattedMinDateString: this.getFormattedMinMaxDateString(props, \"minDate\"),\n            isOpen: false,\n            selectedEnd,\n            selectedStart,\n        };\n    }\n\n    public componentDidUpdate() {\n        const { isStartInputFocused, isEndInputFocused, shouldSelectAfterUpdate } = this.state;\n\n        const shouldFocusStartInput = this.shouldFocusInputRef(isStartInputFocused, this.startInputRef);\n        const shouldFocusEndInput = this.shouldFocusInputRef(isEndInputFocused, this.endInputRef);\n\n        if (shouldFocusStartInput) {\n            this.startInputRef.focus();\n        } else if (shouldFocusEndInput) {\n            this.endInputRef.focus();\n        }\n\n        if (isStartInputFocused && shouldSelectAfterUpdate) {\n            this.startInputRef.select();\n        } else if (isEndInputFocused && shouldSelectAfterUpdate) {\n            this.endInputRef.select();\n        }\n    }\n\n    public render() {\n        const { startInputProps, endInputProps } = this.props;\n\n        const popoverContent = (\n            <DateRangePicker\n                allowSingleDayRange={this.props.allowSingleDayRange}\n                boundaryToModify={this.state.boundaryToModify}\n                contiguousCalendarMonths={this.props.contiguousCalendarMonths}\n                onChange={this.handleDateRangePickerChange}\n                onHoverChange={this.handleDateRangePickerHoverChange}\n                maxDate={this.props.maxDate}\n                minDate={this.props.minDate}\n                shortcuts={this.props.shortcuts}\n                value={this.getSelectedRange()}\n            />\n        );\n\n        // allow custom props for the popover and each input group, but pass them in an order that\n        // guarantees only some props are overridable.\n        return (\n            <Popover\n                inline={true}\n                isOpen={this.state.isOpen}\n                position={Position.BOTTOM_LEFT}\n                {...this.props.popoverProps}\n                autoFocus={false}\n                content={popoverContent}\n                enforceFocus={false}\n                onClose={this.handlePopoverClose}\n            >\n                <div className={Classes.CONTROL_GROUP}>\n                    <InputGroup\n                        {...startInputProps}\n                        className={this.getInputClasses(DateRangeBoundary.START, startInputProps)}\n                        disabled={this.props.disabled}\n                        inputRef={this.refHandlers.startInputRef}\n                        onBlur={this.handleStartInputBlur}\n                        onChange={this.handleStartInputChange}\n                        onClick={this.handleInputClick}\n                        onFocus={this.handleStartInputFocus}\n                        onKeyDown={this.handleInputKeyDown}\n                        onMouseDown={this.handleInputMouseDown}\n                        placeholder={this.getInputPlaceholderString(DateRangeBoundary.START)}\n                        value={this.getInputDisplayString(DateRangeBoundary.START)}\n                    />\n                    <InputGroup\n                        {...endInputProps}\n                        className={this.getInputClasses(DateRangeBoundary.END, endInputProps)}\n                        disabled={this.props.disabled}\n                        inputRef={this.refHandlers.endInputRef}\n                        onBlur={this.handleEndInputBlur}\n                        onChange={this.handleEndInputChange}\n                        onClick={this.handleInputClick}\n                        onFocus={this.handleEndInputFocus}\n                        onKeyDown={this.handleInputKeyDown}\n                        onMouseDown={this.handleInputMouseDown}\n                        placeholder={this.getInputPlaceholderString(DateRangeBoundary.END)}\n                        value={this.getInputDisplayString(DateRangeBoundary.END)}\n                    />\n                </div>\n            </Popover>\n        );\n    }\n\n    public componentWillReceiveProps(nextProps: IDateRangeInputProps) {\n        super.componentWillReceiveProps(nextProps);\n\n        let nextState: IDateRangeInputState = {};\n\n        if (nextProps.value !== this.props.value) {\n            const [selectedStart, selectedEnd] = this.getInitialRange(nextProps);\n            nextState = { ...nextState, selectedStart, selectedEnd };\n        }\n\n        // we use Moment to format date strings, but min/max dates come in as vanilla JS Dates.\n        // cache the formatted date strings to avoid creating new Moment instances on each render.\n        const didFormatChange = nextProps.format !== this.props.format;\n        if (didFormatChange || nextProps.minDate !== this.props.minDate) {\n            const formattedMinDateString = this.getFormattedMinMaxDateString(nextProps, \"minDate\");\n            nextState = { ...nextState, formattedMinDateString };\n        }\n        if (didFormatChange || nextProps.maxDate !== this.props.maxDate) {\n            const formattedMaxDateString = this.getFormattedMinMaxDateString(nextProps, \"maxDate\");\n            nextState = { ...nextState, formattedMaxDateString };\n        }\n\n        this.setState(nextState);\n    }\n\n    // Callbacks - DateRangePicker\n    // ===========================\n\n    private handleDateRangePickerChange = (selectedRange: DateRange) => {\n        // ignore mouse events in the date-range picker if the popover is animating closed.\n        if (!this.state.isOpen) {\n            return;\n        }\n\n        if (this.props.value === undefined) {\n            const [selectedStart, selectedEnd] = fromDateRangeToMomentDateRange(selectedRange);\n\n            let isOpen = true;\n\n            let isStartInputFocused: boolean;\n            let isEndInputFocused: boolean;\n\n            let startHoverString: string;\n            let endHoverString: string;\n\n            if (isMomentNull(selectedStart)) {\n                // focus the start field by default or if only an end date is specified\n                isStartInputFocused = true;\n                isEndInputFocused = false;\n\n                // for clarity, hide the hover string until the mouse moves over a different date\n                startHoverString = null;\n            } else if (isMomentNull(selectedEnd)) {\n                // focus the end field if a start date is specified\n                isStartInputFocused = false;\n                isEndInputFocused = true;\n\n                endHoverString = null;\n            } else if (this.props.closeOnSelection) {\n                isOpen = false;\n                isStartInputFocused = false;\n                isEndInputFocused = false;\n            } else if (this.state.lastFocusedField === DateRangeBoundary.START) {\n                // keep the start field focused\n                isStartInputFocused = true;\n                isEndInputFocused = false;\n            } else {\n                // keep the end field focused\n                isStartInputFocused = false;\n                isEndInputFocused = true;\n            }\n\n            this.setState({\n                isOpen,\n                selectedEnd,\n                selectedStart,\n                isEndInputFocused,\n                isStartInputFocused,\n                startHoverString,\n                endHoverString,\n                endInputString: this.getFormattedDateString(selectedEnd),\n                startInputString: this.getFormattedDateString(selectedStart),\n                wasLastFocusChangeDueToHover: false,\n            });\n        }\n        Utils.safeInvoke(this.props.onChange, selectedRange);\n    }\n\n    private handleDateRangePickerHoverChange = (hoveredRange: DateRange,\n                                                _hoveredDay: Date,\n                                                hoveredBoundary: DateRangeBoundary) => {\n        // ignore mouse events in the date-range picker if the popover is animating closed.\n        if (!this.state.isOpen) { return; }\n\n        if (hoveredRange == null) {\n            // undo whatever focus changes we made while hovering over various calendar dates\n            const isEndInputFocused = (this.state.boundaryToModify === DateRangeBoundary.END);\n\n            this.setState({\n                isEndInputFocused,\n                endHoverString: null,\n                isStartInputFocused: !isEndInputFocused,\n                lastFocusedField: this.state.boundaryToModify,\n                startHoverString: null,\n            });\n        } else {\n            const [hoveredStart, hoveredEnd] = fromDateRangeToMomentDateRange(hoveredRange);\n\n            const isStartInputFocused = (hoveredBoundary != null)\n                ? hoveredBoundary === DateRangeBoundary.START\n                : this.state.isStartInputFocused;\n            const isEndInputFocused = (hoveredBoundary != null)\n                ? hoveredBoundary === DateRangeBoundary.END\n                : this.state.isEndInputFocused;\n\n            this.setState({\n                isStartInputFocused,\n                isEndInputFocused,\n                endHoverString: this.getFormattedDateString(hoveredEnd),\n                lastFocusedField: (isStartInputFocused) ? DateRangeBoundary.START : DateRangeBoundary.END,\n                shouldSelectAfterUpdate: this.props.selectAllOnFocus,\n                startHoverString: this.getFormattedDateString(hoveredStart),\n                wasLastFocusChangeDueToHover: true,\n            });\n        }\n    }\n\n    // Callbacks - Input\n    // =================\n\n    // Key down\n\n    // add a keydown listener to persistently change focus when tabbing:\n    // - if focused in start field, Tab moves focus to end field\n    // - if focused in end field, Shift+Tab moves focus to start field\n    private handleInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n        const isTabPressed = e.keyCode === Keys.TAB;\n        const isShiftPressed = e.shiftKey;\n\n        // order of JS events is our enemy here. when tabbing between fields,\n        // this handler will fire in the middle of a focus exchange when no\n        // field is currently focused. we work around this by referring to the\n        // most recently focused field, rather than the currently focused field.\n        const wasStartFieldFocused = this.state.lastFocusedField === DateRangeBoundary.START;\n        const wasEndFieldFocused = this.state.lastFocusedField === DateRangeBoundary.END;\n\n        let isEndInputFocused: boolean;\n        let isStartInputFocused: boolean;\n\n        // move focus to the other field\n        if (wasStartFieldFocused && isTabPressed && !isShiftPressed) {\n            isStartInputFocused = false;\n            isEndInputFocused = true;\n        } else if (wasEndFieldFocused && isTabPressed && isShiftPressed) {\n            isStartInputFocused = true;\n            isEndInputFocused = false;\n        } else {\n            // let the default keystroke happen without side effects\n            return;\n        }\n\n        // prevent the default focus-change behavior to avoid race conditions;\n        // we'll handle the focus change ourselves in componentDidUpdate.\n        e.preventDefault();\n\n        this.setState({\n            isStartInputFocused,\n            isEndInputFocused,\n            wasLastFocusChangeDueToHover: false,\n        });\n    }\n\n    // Mouse down\n\n    private handleInputMouseDown = () => {\n        // clicking in the field constitutes an explicit focus change. we update\n        // the flag on \"mousedown\" instead of on \"click\", because it needs to be\n        // set before onFocus is called (\"click\" triggers after \"focus\").\n        this.setState({ wasLastFocusChangeDueToHover: false });\n    }\n\n    // Click\n\n    private handleInputClick = (e: React.MouseEvent<HTMLInputElement>) => {\n        // unless we stop propagation on this event, a click within an input\n        // will close the popover almost as soon as it opens.\n        e.stopPropagation();\n    }\n\n    // Focus\n\n    private handleStartInputFocus = (e: React.FormEvent<HTMLInputElement>) => {\n        this.handleInputFocus(e, DateRangeBoundary.START);\n    }\n\n    private handleEndInputFocus = (e: React.FormEvent<HTMLInputElement>) => {\n        this.handleInputFocus(e, DateRangeBoundary.END);\n    }\n\n    private handleInputFocus = (_e: React.FormEvent<HTMLInputElement>, boundary: DateRangeBoundary) => {\n        const { keys, values } = this.getStateKeysAndValuesForBoundary(boundary);\n        const inputString = this.getFormattedDateString(values.selectedValue);\n\n        // change the boundary only if the user explicitly focused in the field.\n        // focus changes from hovering don't count; they're just temporary.\n        const boundaryToModify = (this.state.wasLastFocusChangeDueToHover)\n            ? this.state.boundaryToModify\n            : boundary;\n\n        this.setState({\n            isOpen: true,\n            boundaryToModify,\n            [keys.inputString]: inputString,\n            [keys.isInputFocused]: true,\n            lastFocusedField: boundary,\n            shouldSelectAfterUpdate: this.props.selectAllOnFocus,\n            wasLastFocusChangeDueToHover: false,\n        });\n    }\n\n    // Blur\n\n    private handleStartInputBlur = (e: React.FormEvent<HTMLInputElement>) => {\n        this.handleInputBlur(e, DateRangeBoundary.START);\n    }\n\n    private handleEndInputBlur = (e: React.FormEvent<HTMLInputElement>) => {\n        this.handleInputBlur(e, DateRangeBoundary.END);\n    }\n\n    private handleInputBlur = (_e: React.FormEvent<HTMLInputElement>, boundary: DateRangeBoundary) => {\n        const { keys, values } = this.getStateKeysAndValuesForBoundary(boundary);\n\n        const maybeNextValue = this.dateStringToMoment(values.inputString);\n        const isValueControlled = this.isControlled();\n\n        let nextState: IDateRangeInputState = {\n            [keys.isInputFocused]: false,\n            shouldSelectAfterUpdate: false,\n        };\n\n        if (this.isInputEmpty(values.inputString)) {\n            if (isValueControlled) {\n                nextState = {\n                    ...nextState,\n                    [keys.inputString]: this.getFormattedDateString(values.controlledValue),\n                };\n            } else {\n                nextState = {\n                    ...nextState,\n                    [keys.inputString]: null,\n                    [keys.selectedValue]: moment(null),\n                };\n            }\n        } else if (!this.isNextDateRangeValid(maybeNextValue, boundary)) {\n            if (!isValueControlled) {\n                nextState = {\n                    ...nextState,\n                    [keys.inputString]: null,\n                    [keys.selectedValue]: maybeNextValue,\n                };\n            }\n            Utils.safeInvoke(this.props.onError, this.getDateRangeForCallback(maybeNextValue, boundary));\n        }\n\n        this.setState(nextState);\n    }\n\n    // Change\n\n    private handleStartInputChange = (e: React.FormEvent<HTMLInputElement>) => {\n        this.handleInputChange(e, DateRangeBoundary.START);\n        Utils.safeInvoke(this.props.startInputProps.onChange, e);\n    }\n\n    private handleEndInputChange = (e: React.FormEvent<HTMLInputElement>) => {\n        this.handleInputChange(e, DateRangeBoundary.END);\n        Utils.safeInvoke(this.props.endInputProps.onChange, e);\n    }\n\n    private handleInputChange = (e: React.FormEvent<HTMLInputElement>, boundary: DateRangeBoundary) => {\n        const inputString = (e.target as HTMLInputElement).value;\n\n        const { keys } = this.getStateKeysAndValuesForBoundary(boundary);\n        const maybeNextValue = this.dateStringToMoment(inputString);\n        const isValueControlled = this.isControlled();\n\n        let nextState: IDateRangeInputState = { shouldSelectAfterUpdate: false };\n\n        if (inputString.length === 0) {\n            // this case will be relevant when we start showing the hovered\n            // range in the input fields. goal is to show an empty field for\n            // clarity until the mouse moves over a different date.\n            if (isValueControlled) {\n                nextState = { ...nextState, [keys.inputString]: \"\" };\n            } else {\n                nextState = { ...nextState, [keys.inputString]: \"\", [keys.selectedValue]: moment(null) };\n            }\n            Utils.safeInvoke(this.props.onChange, this.getDateRangeForCallback(moment(null), boundary));\n        } else if (this.isMomentValidAndInRange(maybeNextValue)) {\n            // note that error cases that depend on both fields (e.g.\n            // overlapping dates) should fall through into this block so that\n            // the UI can update immediately, possibly with an error message on\n            // the other field.\n            if (isValueControlled) {\n                nextState = { ...nextState, [keys.inputString]: inputString };\n            } else {\n                nextState = { ...nextState, [keys.inputString]: inputString, [keys.selectedValue]: maybeNextValue };\n            }\n            if (this.isNextDateRangeValid(maybeNextValue, boundary)) {\n                Utils.safeInvoke(this.props.onChange, this.getDateRangeForCallback(maybeNextValue, boundary));\n            }\n        } else {\n            nextState = { ...nextState, [keys.inputString]: inputString };\n        }\n\n        this.setState(nextState);\n    }\n\n    // Callbacks - Popover\n    // ===================\n\n    private handlePopoverClose = () => {\n        this.setState({ isOpen: false });\n        Utils.safeInvoke(this.props.popoverProps.onClose);\n    }\n\n    // Helpers\n    // =======\n\n    private shouldFocusInputRef(isFocused: boolean, inputRef: HTMLInputElement) {\n        return isFocused && inputRef !== undefined && document.activeElement !== inputRef;\n    }\n\n    private dateStringToMoment = (dateString: string) => {\n        if (this.isInputEmpty(dateString)) {\n            return moment(null);\n        }\n        return moment(dateString, this.props.format);\n    }\n\n    private getInitialRange = (props = this.props) => {\n        const { defaultValue, value } = props;\n        if (value != null) {\n            return fromDateRangeToMomentDateRange(value);\n        } else if (defaultValue != null) {\n            return fromDateRangeToMomentDateRange(defaultValue);\n        } else {\n            return [moment(null), moment(null)] as MomentDateRange;\n        }\n    }\n\n    private getSelectedRange = () => {\n        const { selectedStart, selectedEnd } = this.state;\n\n        // this helper function checks if the provided boundary date *would* overlap the selected\n        // other boundary date. providing the already-selected start date simply tells us if we're\n        // currently in an overlapping state.\n        const doBoundaryDatesOverlap = this.doBoundaryDatesOverlap(selectedStart, DateRangeBoundary.START);\n        const momentDateRange = [selectedStart, doBoundaryDatesOverlap ? moment(null) : selectedEnd];\n\n        return momentDateRange.map((selectedBound?: moment.Moment) => {\n            return this.isMomentValidAndInRange(selectedBound)\n                ? fromMomentToDate(selectedBound)\n                : undefined;\n        }) as DateRange;\n    }\n\n    private getInputClasses = (boundary: DateRangeBoundary, boundaryInputProps: IInputGroupProps) => {\n        return classNames(boundaryInputProps.className, {\n            [Classes.INTENT_DANGER]: this.isInputInErrorState(boundary),\n        });\n    }\n\n    private getInputDisplayString = (boundary: DateRangeBoundary) => {\n        const { values } = this.getStateKeysAndValuesForBoundary(boundary);\n        const { isInputFocused, inputString, selectedValue, hoverString } = values;\n\n        if (hoverString != null && !this.isControlled()) {\n            // we don't want to overwrite the inputStrings in controlled mode\n            return hoverString;\n        } else if (isInputFocused) {\n            return (inputString == null) ? \"\" : inputString;\n        } else if (isMomentNull(selectedValue)) {\n            return \"\";\n        } else if (!this.isMomentInRange(selectedValue)) {\n            return this.props.outOfRangeMessage;\n        } else if (this.doesEndBoundaryOverlapStartBoundary(selectedValue, boundary)) {\n            return this.props.overlappingDatesMessage;\n        } else {\n            return this.getFormattedDateString(selectedValue);\n        }\n    }\n\n    private getInputPlaceholderString = (boundary: DateRangeBoundary) => {\n        const { isInputFocused } = this.getStateKeysAndValuesForBoundary(boundary).values;\n        const isStartBoundary = boundary === DateRangeBoundary.START;\n\n        const dateString = isStartBoundary ? this.state.formattedMinDateString : this.state.formattedMaxDateString;\n        const defaultString = isStartBoundary ? \"Start date\" : \"End date\";\n\n        return isInputFocused ? dateString : defaultString;\n    }\n\n    private getFormattedDateString = (momentDate: moment.Moment, format?: string) => {\n        if (isMomentNull(momentDate)) {\n            return \"\";\n        } else if (!momentDate.isValid()) {\n            return this.props.invalidDateMessage;\n        } else {\n            return momentDate.format((format != null) ? format : this.props.format);\n        }\n    }\n\n    private getStateKeysAndValuesForBoundary = (boundary: DateRangeBoundary) => {\n        const controlledRange = fromDateRangeToMomentDateRange(this.props.value);\n        if (boundary === DateRangeBoundary.START) {\n            return {\n                keys: {\n                    hoverString: \"startHoverString\",\n                    inputString: \"startInputString\",\n                    isInputFocused: \"isStartInputFocused\",\n                    selectedValue: \"selectedStart\",\n                },\n                values: {\n                    controlledValue: (controlledRange != null) ? controlledRange[0] : undefined,\n                    hoverString: this.state.startHoverString,\n                    inputString: this.state.startInputString,\n                    isInputFocused: this.state.isStartInputFocused,\n                    selectedValue: this.state.selectedStart,\n                },\n            } as IStateKeysAndValuesObject;\n        } else {\n            return {\n                keys: {\n                    hoverString: \"endHoverString\",\n                    inputString: \"endInputString\",\n                    isInputFocused: \"isEndInputFocused\",\n                    selectedValue: \"selectedEnd\",\n                },\n                values: {\n                    controlledValue: (controlledRange != null) ? controlledRange[1] : undefined,\n                    hoverString: this.state.endHoverString,\n                    inputString: this.state.endInputString,\n                    isInputFocused: this.state.isEndInputFocused,\n                    selectedValue: this.state.selectedEnd,\n                },\n            } as IStateKeysAndValuesObject;\n        }\n    }\n\n    private getDateRangeForCallback = (currValue?: moment.Moment, currBoundary?: DateRangeBoundary) => {\n        const otherBoundary = this.getOtherBoundary(currBoundary);\n        const otherValue = this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;\n\n        const currDate = this.getDateForCallback(currValue);\n        const otherDate = this.getDateForCallback(otherValue);\n\n        return (currBoundary === DateRangeBoundary.START)\n            ? [currDate, otherDate]\n            : [otherDate, currDate];\n    }\n\n    private getDateForCallback = (momentDate: moment.Moment) => {\n        if (isMomentNull(momentDate)) {\n            return null;\n        } else if (!momentDate.isValid()) {\n            return new Date(undefined);\n        } else {\n            return fromMomentToDate(momentDate);\n        }\n    }\n\n    private getOtherBoundary = (boundary?: DateRangeBoundary) => {\n        return (boundary === DateRangeBoundary.START) ? DateRangeBoundary.END : DateRangeBoundary.START;\n    }\n\n    private doBoundaryDatesOverlap = (boundaryDate: moment.Moment, boundary: DateRangeBoundary) => {\n        const { allowSingleDayRange } = this.props;\n\n        const otherBoundary = this.getOtherBoundary(boundary);\n        const otherBoundaryDate = this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;\n\n        if (boundary === DateRangeBoundary.START) {\n            return allowSingleDayRange\n                ? boundaryDate.isAfter(otherBoundaryDate, \"day\")\n                : boundaryDate.isSameOrAfter(otherBoundaryDate, \"day\");\n        } else {\n            return allowSingleDayRange\n                ? boundaryDate.isBefore(otherBoundaryDate, \"day\")\n                : boundaryDate.isSameOrBefore(otherBoundaryDate, \"day\");\n        }\n    }\n\n    /**\n     * Returns true if the provided boundary is an END boundary overlapping the\n     * selected start date. (If the boundaries overlap, we consider the END\n     * boundary to be erroneous.)\n     */\n    private doesEndBoundaryOverlapStartBoundary = (boundaryDate: moment.Moment, boundary: DateRangeBoundary) => {\n        return (boundary === DateRangeBoundary.START)\n            ? false\n            : this.doBoundaryDatesOverlap(boundaryDate, boundary);\n    }\n\n    private isControlled = () => {\n        return this.props.value !== undefined;\n    }\n\n    private isInputEmpty = (inputString: string) => {\n        return inputString == null || inputString.length === 0;\n    }\n\n    private isInputInErrorState = (boundary: DateRangeBoundary) => {\n        const values = this.getStateKeysAndValuesForBoundary(boundary).values;\n        const { isInputFocused, inputString, selectedValue } = values;\n\n        const boundaryValue = (isInputFocused)\n            ? this.dateStringToMoment(inputString)\n            : selectedValue;\n\n        // break down the boolean logic to an elementary level to make it\n        // utterly simple to grok.\n\n        if (isMomentNull(boundaryValue)) {\n            return false;\n        }\n\n        if (!boundaryValue.isValid()) {\n            return true;\n        }\n\n        if (!this.isMomentInRange(boundaryValue)) {\n            return true;\n        }\n\n        if (this.doesEndBoundaryOverlapStartBoundary(boundaryValue, boundary)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    private isMomentValidAndInRange = (momentDate: moment.Moment) => {\n        return isMomentValidAndInRange(momentDate, this.props.minDate, this.props.maxDate);\n    }\n\n    private isMomentInRange = (momentDate: moment.Moment) => {\n        return isMomentInRange(momentDate, this.props.minDate, this.props.maxDate);\n    }\n\n    private isNextDateRangeValid(nextMomentDate: moment.Moment, boundary: DateRangeBoundary) {\n        return this.isMomentValidAndInRange(nextMomentDate)\n            && !this.doBoundaryDatesOverlap(nextMomentDate, boundary);\n    }\n\n    // this is a slightly kludgy function, but it saves us a good amount of repeated code between\n    // the constructor and componentWillReceiveProps.\n    private getFormattedMinMaxDateString(props: IDateRangeInputProps, propName: \"minDate\" | \"maxDate\") {\n        const date = props[propName];\n        const defaultDate = DateRangeInput.defaultProps[propName];\n        // default values are applied only if a prop is strictly `undefined`\n        // See: https://facebook.github.io/react/docs/react-component.html#defaultprops\n        return this.getFormattedDateString(moment((date === undefined) ? defaultDate : date), props.format);\n    }\n}\n"]}