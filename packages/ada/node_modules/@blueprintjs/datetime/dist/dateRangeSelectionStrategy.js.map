{"version":3,"sources":["../src/dateRangeSelectionStrategy.ts"],"names":[],"mappings":"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","file":"dateRangeSelectionStrategy.js","sourcesContent":["\nimport {\n    areSameDay,\n    DateRange,\n    DateRangeBoundary,\n} from \"./common/dateUtils\";\n\nexport interface IDateRangeSelectionState {\n    /**\n     * The boundary that would be modified by clicking the provided `day`.\n     */\n    boundary?: DateRangeBoundary;\n\n    /**\n     * The date range that would be selected after clicking the provided `day`.\n     */\n    dateRange: DateRange;\n};\n\nexport class DateRangeSelectionStrategy {\n    /**\n     * Returns the new date-range and the boundary that would be affected if `day` were clicked. The\n     * affected boundary may be different from the provided `boundary` in some cases. For example,\n     * clicking a particular boundary's selected date will always deselect it regardless of which\n     * `boundary` you provide to this function (because it's simply a more intuitive interaction).\n     */\n    public static getNextState(currentRange: DateRange,\n                               day: Date,\n                               allowSingleDayRange: boolean,\n                               boundary?: DateRangeBoundary): IDateRangeSelectionState {\n        if (boundary != null) {\n            return this.getNextStateForBoundary(currentRange, day, allowSingleDayRange, boundary);\n        } else {\n            return this.getDefaultNextState(currentRange, day, allowSingleDayRange);\n        }\n    }\n\n    private static getNextStateForBoundary(currentRange: DateRange,\n                                           day: Date,\n                                           allowSingleDayRange: boolean,\n                                           boundary: DateRangeBoundary) {\n        const boundaryDate = this.getBoundaryDate(boundary, currentRange);\n        const otherBoundary = this.getOtherBoundary(boundary);\n        const otherBoundaryDate = this.getBoundaryDate(otherBoundary, currentRange);\n\n        let nextBoundary: DateRangeBoundary;\n        let nextDateRange: DateRange;\n\n        if (boundaryDate == null && otherBoundaryDate == null) {\n            nextBoundary = boundary;\n            nextDateRange = this.createRangeForBoundary(boundary, day, null);\n        } else if (boundaryDate != null && otherBoundaryDate == null) {\n            const nextBoundaryDate = areSameDay(boundaryDate, day) ? null : day;\n            nextBoundary = boundary;\n            nextDateRange = this.createRangeForBoundary(boundary, nextBoundaryDate, null);\n        } else if (boundaryDate == null && otherBoundaryDate != null) {\n            if (areSameDay(day, otherBoundaryDate)) {\n                let nextDate: Date;\n                if (allowSingleDayRange) {\n                    nextBoundary = boundary;\n                    nextDate = otherBoundaryDate;\n                } else {\n                    nextBoundary = otherBoundary;\n                    nextDate = null;\n                }\n                nextDateRange = this.createRangeForBoundary(boundary, nextDate, nextDate);\n            } else if (this.isOverlappingOtherBoundary(boundary, day, otherBoundaryDate)) {\n                nextBoundary = otherBoundary;\n                nextDateRange = this.createRangeForBoundary(boundary, otherBoundaryDate, day);\n            } else {\n                nextBoundary = boundary;\n                nextDateRange = this.createRangeForBoundary(boundary, day, otherBoundaryDate);\n            }\n        } else {\n            // both boundaryDate and otherBoundaryDate are already defined\n            if (areSameDay(boundaryDate, day)) {\n                const isSingleDayRangeSelected = areSameDay(boundaryDate, otherBoundaryDate);\n                const nextOtherBoundaryDate = isSingleDayRangeSelected ? null : otherBoundaryDate;\n                nextBoundary = boundary;\n                nextDateRange = this.createRangeForBoundary(boundary, null, nextOtherBoundaryDate);\n            } else if (areSameDay(day, otherBoundaryDate)) {\n                const [nextBoundaryDate, nextOtherBoundaryDate] = (allowSingleDayRange)\n                    ? [otherBoundaryDate, otherBoundaryDate]\n                    : [boundaryDate, null];\n                nextBoundary = allowSingleDayRange ? boundary : otherBoundary;\n                nextDateRange = this.createRangeForBoundary(boundary, nextBoundaryDate, nextOtherBoundaryDate);\n            } else if (this.isOverlappingOtherBoundary(boundary, day, otherBoundaryDate)) {\n                nextBoundary = boundary;\n                nextDateRange = this.createRangeForBoundary(boundary, day, null);\n            } else {\n                // extend the date range with an earlier boundaryDate date\n                nextBoundary = boundary;\n                nextDateRange = this.createRangeForBoundary(boundary, day, otherBoundaryDate);\n            }\n        }\n\n        return { dateRange: nextDateRange, boundary: nextBoundary } as IDateRangeSelectionState;\n    }\n\n    private static getDefaultNextState(selectedRange: DateRange, day: Date, allowSingleDayRange: boolean) {\n        const [start, end] = selectedRange;\n\n        let nextDateRange: DateRange;\n\n        if (start == null && end == null) {\n            nextDateRange = [day, null];\n        } else if (start != null && end == null) {\n            nextDateRange = this.createRange(day, start, allowSingleDayRange);\n        } else if (start == null && end != null) {\n            nextDateRange = this.createRange(day, end, allowSingleDayRange);\n        } else {\n            const isStart = areSameDay(start, day);\n            const isEnd = areSameDay(end, day);\n            if (isStart && isEnd) {\n                nextDateRange = [null, null];\n            } else if (isStart) {\n                nextDateRange = [null, end];\n            } else if (isEnd) {\n                nextDateRange = [start, null];\n            } else {\n                nextDateRange = [day, null];\n            }\n        }\n\n        return { dateRange: nextDateRange } as IDateRangeSelectionState;\n    }\n\n    private static getOtherBoundary(boundary: DateRangeBoundary) {\n        return (boundary === DateRangeBoundary.START)\n            ? DateRangeBoundary.END\n            : DateRangeBoundary.START;\n    }\n\n    private static getBoundaryDate(boundary: DateRangeBoundary, dateRange: DateRange) {\n        return (boundary === DateRangeBoundary.START)\n            ? dateRange[0]\n            : dateRange[1];\n    }\n\n    private static isOverlappingOtherBoundary(boundary: DateRangeBoundary,\n                                              boundaryDate: Date,\n                                              otherBoundaryDate: Date) {\n        return (boundary === DateRangeBoundary.START)\n            ? boundaryDate > otherBoundaryDate\n            : boundaryDate < otherBoundaryDate;\n    }\n\n    private static createRangeForBoundary(boundary: DateRangeBoundary, boundaryDate: Date, otherBoundaryDate: Date) {\n        return (boundary === DateRangeBoundary.START)\n            ? [boundaryDate, otherBoundaryDate] as DateRange\n            : [otherBoundaryDate, boundaryDate] as DateRange;\n    }\n\n    private static createRange(a: Date, b: Date, allowSingleDayRange: boolean): DateRange {\n        // clicking the same date again will clear it\n        if (!allowSingleDayRange && areSameDay(a, b)) {\n            return [null, null];\n        }\n        return a < b ? [a, b] : [b, a];\n    }\n}\n"]}