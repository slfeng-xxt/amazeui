/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var classNames = require("classnames");
var moment = require("moment");
var React = require("react");
var core_1 = require("@blueprintjs/core");
var dateUtils_1 = require("./common/dateUtils");
var datePicker_1 = require("./datePicker");
var datePickerCore_1 = require("./datePickerCore");
var dateTimePicker_1 = require("./dateTimePicker");
var DateInput = (function (_super) {
    tslib_1.__extends(DateInput, _super);
    function DateInput(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.displayName = "Blueprint.DateInput";
        _this.inputRef = null;
        _this.getDateString = function (value) {
            if (dateUtils_1.isMomentNull(value)) {
                return "";
            }
            if (value.isValid()) {
                if (_this.isMomentInRange(value)) {
                    return value.format(_this.props.format);
                }
                else {
                    return _this.props.outOfRangeMessage;
                }
            }
            return _this.props.invalidDateMessage;
        };
        _this.handleClosePopover = function () {
            _this.setState({ isOpen: false });
        };
        _this.handleDateChange = function (date, hasUserManuallySelectedDate) {
            var momentDate = dateUtils_1.fromDateToMoment(date);
            var hasMonthChanged = date !== null && !dateUtils_1.isMomentNull(_this.state.value) && _this.state.value.isValid() &&
                momentDate.month() !== _this.state.value.month();
            var isOpen = !(_this.props.closeOnSelection && hasUserManuallySelectedDate && !hasMonthChanged);
            if (_this.props.value === undefined) {
                _this.setState({ isInputFocused: false, isOpen: isOpen, value: momentDate });
            }
            else {
                _this.setState({ isInputFocused: false, isOpen: isOpen });
            }
            core_1.Utils.safeInvoke(_this.props.onChange, date === null ? null : dateUtils_1.fromMomentToDate(momentDate));
        };
        _this.handleInputFocus = function () {
            var valueString = dateUtils_1.isMomentNull(_this.state.value) ? "" : _this.state.value.format(_this.props.format);
            if (_this.props.openOnFocus) {
                _this.setState({ isInputFocused: true, isOpen: true, valueString: valueString });
            }
            else {
                _this.setState({ isInputFocused: true, valueString: valueString });
            }
        };
        _this.handleInputClick = function (e) {
            if (_this.props.openOnFocus) {
                e.stopPropagation();
            }
        };
        _this.handleInputChange = function (e) {
            var valueString = e.target.value;
            var value = moment(valueString, _this.props.format);
            if (value.isValid() && _this.isMomentInRange(value)) {
                if (_this.props.value === undefined) {
                    _this.setState({ value: value, valueString: valueString });
                }
                else {
                    _this.setState({ valueString: valueString });
                }
                core_1.Utils.safeInvoke(_this.props.onChange, dateUtils_1.fromMomentToDate(value));
            }
            else {
                if (valueString.length === 0) {
                    core_1.Utils.safeInvoke(_this.props.onChange, null);
                }
                _this.setState({ valueString: valueString });
            }
        };
        _this.handleInputBlur = function () {
            var valueString = _this.state.valueString;
            var value = moment(valueString, _this.props.format);
            if (valueString.length > 0
                && valueString !== _this.getDateString(_this.state.value)
                && (!value.isValid() || !_this.isMomentInRange(value))) {
                if (_this.props.value === undefined) {
                    _this.setState({ isInputFocused: false, value: value, valueString: null });
                }
                else {
                    _this.setState({ isInputFocused: false });
                }
                if (!value.isValid()) {
                    core_1.Utils.safeInvoke(_this.props.onError, new Date(undefined));
                }
                else if (!_this.isMomentInRange(value)) {
                    core_1.Utils.safeInvoke(_this.props.onError, dateUtils_1.fromMomentToDate(value));
                }
                else {
                    core_1.Utils.safeInvoke(_this.props.onChange, dateUtils_1.fromMomentToDate(value));
                }
            }
            else {
                if (valueString.length === 0) {
                    _this.setState({ isInputFocused: false, value: moment(null), valueString: null });
                }
                else {
                    _this.setState({ isInputFocused: false });
                }
            }
        };
        _this.setInputRef = function (el) {
            _this.inputRef = el;
        };
        var defaultValue = _this.props.defaultValue ? dateUtils_1.fromDateToMoment(_this.props.defaultValue) : moment(null);
        _this.state = {
            isInputFocused: false,
            isOpen: false,
            value: _this.props.value !== undefined ? dateUtils_1.fromDateToMoment(_this.props.value) : defaultValue,
            valueString: null,
        };
        return _this;
    }
    DateInput.prototype.render = function () {
        var dateString = this.state.isInputFocused ? this.state.valueString : this.getDateString(this.state.value);
        var date = this.state.isInputFocused ? moment(this.state.valueString, this.props.format) : this.state.value;
        var sharedProps = tslib_1.__assign({}, this.props, { onChange: this.handleDateChange, value: this.isMomentValidAndInRange(this.state.value) ? dateUtils_1.fromMomentToDate(this.state.value) : null });
        var popoverContent = this.props.timePrecision === undefined
            ? React.createElement(datePicker_1.DatePicker, tslib_1.__assign({}, sharedProps))
            : React.createElement(dateTimePicker_1.DateTimePicker, tslib_1.__assign({}, sharedProps, { timePickerProps: { precision: this.props.timePrecision } }));
        var inputClasses = classNames({
            "pt-intent-danger": !(this.isMomentValidAndInRange(date) || dateUtils_1.isMomentNull(date) || dateString === ""),
        });
        return (React.createElement(core_1.Popover, { autoFocus: false, content: popoverContent, enforceFocus: false, inline: true, isOpen: this.state.isOpen && !this.props.disabled, onClose: this.handleClosePopover, popoverClassName: "pt-dateinput-popover", position: this.props.popoverPosition },
            React.createElement(core_1.InputGroup, { className: inputClasses, disabled: this.props.disabled, inputRef: this.setInputRef, type: "text", onBlur: this.handleInputBlur, onChange: this.handleInputChange, onClick: this.handleInputClick, onFocus: this.handleInputFocus, placeholder: this.props.format, rightElement: this.props.rightElement, value: dateString })));
    };
    DateInput.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.value !== this.props.value) {
            this.setState({ value: dateUtils_1.fromDateToMoment(nextProps.value) });
        }
        _super.prototype.componentWillReceiveProps.call(this, nextProps);
    };
    DateInput.prototype.isMomentValidAndInRange = function (value) {
        return dateUtils_1.isMomentValidAndInRange(value, this.props.minDate, this.props.maxDate);
    };
    DateInput.prototype.isMomentInRange = function (value) {
        return dateUtils_1.isMomentInRange(value, this.props.minDate, this.props.maxDate);
    };
    return DateInput;
}(core_1.AbstractComponent));
DateInput.defaultProps = {
    closeOnSelection: true,
    disabled: false,
    format: "YYYY-MM-DD",
    invalidDateMessage: "Invalid date",
    maxDate: datePickerCore_1.getDefaultMaxDate(),
    minDate: datePickerCore_1.getDefaultMinDate(),
    openOnFocus: true,
    outOfRangeMessage: "Out of range",
    popoverPosition: core_1.Position.BOTTOM,
};
exports.DateInput = DateInput;

//# sourceMappingURL=dateInput.js.map
