"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const yaml = require("js-yaml");
const marked = require("marked");
/**
 * Matches the triple-dash metadata block on the first line of markdown file.
 * The first capture group contains YAML content.
 */
const METADATA_REGEX = /^---\n?((?:.|\n)*)\n---\n/;
/**
 * Splits text content for lines that begin with `@tagName`.
 */
const TAG_REGEX = /^@(\S+)(?:\s+([^\n]+))?$/;
const TAG_SPLIT_REGEX = /^(@\S+(?:\s+[^\n]+)?)$/gm;
class Compiler {
    constructor(options) {
        this.options = options;
        this.renderBlock = (blockContent, reservedTagWords = this.options.reservedTags) => {
            const { contentsRaw, metadata } = this.extractMetadata(blockContent);
            const contents = this.renderContents(contentsRaw, reservedTagWords);
            return { contents, contentsRaw, metadata };
        };
        this.renderMarkdown = (markdown) => marked(markdown, this.options.markdown);
    }
    objectify(array, getKey) {
        return array.reduce((obj, item) => {
            obj[getKey(item)] = item;
            return obj;
        }, {});
    }
    /**
     * Converts the content string into an array of `ContentNode`s. If the
     * `contents` option is `html`, the string nodes will also be rendered with
     * markdown.
     */
    renderContents(content, reservedTagWords) {
        const splitContents = this.parseTags(content, reservedTagWords);
        return splitContents
            .map((node) => typeof node === "string" ? this.renderMarkdown(node) : node)
            .filter((node) => node !== "");
    }
    /**
     * Extracts optional YAML frontmatter metadata block from the beginning of a
     * markdown file and parses it to a JS object.
     */
    extractMetadata(text) {
        const match = METADATA_REGEX.exec(text);
        if (match === null) {
            return { contentsRaw: text, metadata: {} };
        }
        const contentsRaw = text.substr(match[0].length);
        return { contentsRaw, metadata: yaml.load(match[1]) || {} };
    }
    /**
     * Splits the content string when it encounters a line that begins with a
     * `@tag`. You may prevent this splitting by specifying an array of reserved
     * tag names.
     */
    parseTags(content, reservedWords = []) {
        // using reduce so we can squash consecutive strings (<= 1 entry per iteration)
        return content.split(TAG_SPLIT_REGEX).reduce((arr, str) => {
            const match = TAG_REGEX.exec(str);
            if (match === null || reservedWords.indexOf(match[1]) >= 0) {
                if (typeof arr[arr.length - 1] === "string") {
                    // merge consecutive strings to avoid breaking up code blocks
                    arr[arr.length - 1] += str;
                }
                else {
                    arr.push(str);
                }
            }
            else {
                const tag = match[1];
                const value = match[2];
                if (/#+/.test(tag)) {
                    // NOTE: not enough information to populate `route` field yet
                    arr.push({ tag: "heading", value, level: tag.length });
                }
                else {
                    arr.push({ tag, value });
                }
            }
            return arr;
        }, []);
    }
}
exports.Compiler = Compiler;
