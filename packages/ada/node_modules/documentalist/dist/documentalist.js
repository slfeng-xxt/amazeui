/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain
 * a copy of the license in the LICENSE and PATENTS files in the root of this
 * repository.
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const glob = require("glob");
const path = require("path");
const compiler_1 = require("./compiler");
class Documentalist {
    constructor(options = {}, plugins = []) {
        this.options = options;
        this.plugins = plugins;
    }
    static create(options) {
        return new Documentalist(options, []);
    }
    use(pattern, plugin) {
        if (typeof pattern === "string") {
            pattern = new RegExp(`${pattern}$`);
        }
        const newPlugins = [...this.plugins, { pattern, plugin }];
        return new Documentalist(this.options, newPlugins);
    }
    clearPlugins() {
        return new Documentalist(this.options, []);
    }
    documentGlobs(...filesGlobs) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = this.expandGlobs(filesGlobs);
            return this.documentFiles(files);
        });
    }
    documentFiles(files) {
        return __awaiter(this, void 0, void 0, function* () {
            const compiler = new compiler_1.Compiler(this.options);
            const documentation = {};
            for (const { pattern, plugin } of this.plugins) {
                const pluginFiles = files.filter((f) => pattern.test(f.path));
                const pluginDocumentation = yield plugin.compile(pluginFiles, compiler);
                this.mergeInto(documentation, pluginDocumentation);
            }
            return documentation;
        });
    }
    /**
     * Expands an array of globs and flatten to a single array of files.
     */
    expandGlobs(filesGlobs) {
        return filesGlobs
            .map((filesGlob) => glob.sync(filesGlob))
            .reduce((a, b) => a.concat(b))
            .map((fileName) => {
            const absolutePath = path.resolve(fileName);
            return {
                path: absolutePath,
                read: () => fs.readFileSync(absolutePath, "utf8"),
            };
        });
    }
    /**
     * Shallow-merges keys form source into destination object (modifying it in the process).
     */
    mergeInto(destination, source) {
        for (const key in source) {
            if (source.hasOwnProperty(key)) {
                if (destination.hasOwnProperty(key)) {
                    console.warn(`WARNING: Duplicate plugin key "${key}". Your plugins are overwriting each other.`);
                }
                destination[key] = source[key];
            }
        }
        return destination;
    }
}
exports.Documentalist = Documentalist;
