import { ICompilerOptions } from "./compiler";
import { IFile, IPlugin } from "./plugins";
export interface IApi<T> {
    /**
     * Finds all files matching the provided variadic glob expressions and then
     * runs `documentFiles` with them, emitting all the documentation data.
     *
     * @see documentFiles
     */
    documentGlobs: (...filesGlobs: string[]) => Promise<T>;
    /**
     * Iterates over all plugins, passing all matching files to each in turn.
     * The output of each plugin is merged to produce the resulting
     * documentation object.
     *
     * The return type T is a composite type has a composite type of all the
     * plugin data types.
     */
    documentFiles: (files: IFile[]) => Promise<T>;
    /**
     * Adds the plugin to Documentalist. Returns a new instance of Documentalist
     * with a template type that includes the data from the plugin. This way the
     * `documentFiles` and `documentGlobs` methods will return an object that is
     * already typed to include each plugin's output.
     *
     * The plugin is applied to all files whose absolute path matches the
     * supplied pattern.
     *
     * @param pattern - A regexp pattern or a file extension string like "js"
     * @param plugin - The plugin implementation
     * @returns A new instance of `Documentalist` with an extended type
     */
    use: <P>(pattern: RegExp | string, plugin: IPlugin<P>) => IApi<T & P>;
    /**
     * Returns a new instance of Documentalist with no plugins.
     */
    clearPlugins(): IApi<{}>;
}
/**
 * Plugins are stored with the regex used to match against file paths.
 */
export interface IPluginEntry<T> {
    pattern: RegExp;
    plugin: IPlugin<T>;
}
export declare class Documentalist<T> implements IApi<T> {
    private options;
    private plugins;
    static create(options?: ICompilerOptions): IApi<{}>;
    constructor(options?: ICompilerOptions, plugins?: Array<IPluginEntry<T>>);
    use<P>(pattern: RegExp | string, plugin: IPlugin<P>): IApi<T & P>;
    clearPlugins(): IApi<{}>;
    documentGlobs(...filesGlobs: string[]): Promise<T>;
    documentFiles(files: IFile[]): Promise<T>;
    /**
     * Expands an array of globs and flatten to a single array of files.
     */
    private expandGlobs(filesGlobs);
    /**
     * Shallow-merges keys form source into destination object (modifying it in the process).
     */
    private mergeInto(destination, source);
}
