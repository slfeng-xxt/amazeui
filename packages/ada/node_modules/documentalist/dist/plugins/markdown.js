/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain
 * a copy of the license in the LICENSE and PATENTS files in the root of this
 * repository.
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const client_1 = require("../client");
const page_1 = require("../page");
class MarkdownPlugin {
    constructor(options = {}) {
        this.options = Object.assign({ navPage: "_nav" }, options);
    }
    /**
     * Reads the given set of markdown files and adds their data to the internal storage.
     * Returns a plain object mapping page references to their data.
     */
    compile(markdownFiles, compiler) {
        const pageMap = this.buildPageStore(markdownFiles, compiler);
        // now that we have all known pages, we can resolve @include tags.
        this.resolveIncludeTags(pageMap);
        // generate navigation tree after all pages loaded and processed.
        const nav = pageMap.toTree(this.options.navPage).children;
        // use nav tree to fill in `route` for all pages and headings.
        this.resolveRoutes(pageMap, nav);
        // generate object at the end, after `route` has been computed throughout.
        const pages = pageMap.toObject();
        return { nav, pages };
    }
    blockToPage(filePath, block) {
        const reference = getReference(filePath, block);
        return Object.assign({ reference, route: reference, title: getTitle(block) }, block);
    }
    /** Convert each file to IPageData and populate store. */
    buildPageStore(markdownFiles, { renderBlock }) {
        const pageMap = new page_1.PageMap();
        for (const file of markdownFiles) {
            const block = renderBlock(file.read());
            const page = this.blockToPage(file.path, block);
            pageMap.set(page.reference, page);
        }
        return pageMap;
    }
    /**
     * Computes `route` for the given `node` based on its parent.
     * If node is a page, then it also computes `route` for each heading and recurses through child
     * pages.
     */
    recurseRoute(pageMap, node, parent) {
        // compute route for page and heading NODES (from nav tree)
        const path = parent === undefined ? [] : [parent.route];
        const route = client_1.isPageNode(node)
            ? path.concat(node.reference).join("/")
            : path.concat(client_1.slugify(node.title)).join(".");
        node.route = route;
        if (client_1.isPageNode(node)) {
            // node is a page, so it must exist in PageMap.
            const page = pageMap.get(node.reference);
            page.route = route;
            page.contents.forEach((content) => {
                // inject `route` field into heading TAGS (from page contents)
                if (client_1.isHeadingTag(content)) {
                    // h1 tags do not get nested as they are used as page title
                    if (content.level > 1) {
                        content.route = [route, client_1.slugify(content.value)].join(".");
                    }
                    else {
                        content.route = route;
                    }
                }
            });
            node.children.forEach((child) => this.recurseRoute(pageMap, child, node));
        }
    }
    resolveRoutes(pageMap, nav) {
        for (const page of nav) {
            // walk the nav tree and compute `route` property for each resource.
            this.recurseRoute(pageMap, page);
        }
    }
    /** Iterates `contents` array and inlines any `@include page` tags. */
    resolveIncludeTags(pageStore) {
        for (const page of pageStore.pages()) {
            // using `reduce` so we can add one or many entries for each node
            page.contents = page.contents.reduce((array, content) => {
                if (typeof content === "string" || content.tag !== "include") {
                    return array.concat(content);
                }
                // inline @include page
                const pageToInclude = pageStore.get(content.value);
                if (pageToInclude === undefined) {
                    throw new Error(`Unknown @include reference '${content.value}' in '${page.reference}'`);
                }
                return array.concat(pageToInclude.contents);
            }, []);
        }
    }
}
exports.MarkdownPlugin = MarkdownPlugin;
function getReference(absolutePath, { metadata }) {
    if (metadata.reference != null) {
        return metadata.reference;
    }
    return path.basename(absolutePath, path.extname(absolutePath));
}
function getTitle(block) {
    if (block.metadata.title != null) {
        return block.metadata.title;
    }
    const first = block.contents[0];
    if (client_1.isHeadingTag(first)) {
        return first.value;
    }
    return "(untitled)";
}
