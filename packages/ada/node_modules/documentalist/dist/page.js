/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain
 * a copy of the license in the LICENSE and PATENTS files in the root of this
 * repository.
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("./client");
class PageMap {
    constructor() {
        this.store = new Map();
    }
    /** Returns an iterator for all the pages (values) in the map. */
    pages() {
        return this.store.values();
    }
    /** Returns the page with the given ID or `undefined` if not found. */
    get(id) {
        return this.store.get(id);
    }
    /** Removes the page with the given ID and returns it or `undefined` if not found. */
    remove(id) {
        const page = this.get(id);
        if (page !== undefined) {
            this.store.delete(id);
        }
        return page;
    }
    /**
     * Sets the page data at the given ID, when you already have a full page object.
     * Warns if a page with this ID already exists.
     */
    set(id, page) {
        if (this.store.has(id)) {
            console.warn(`Found duplicate page "${id}"; overwriting previous data.`);
            console.warn("Rename headings or use metadata `reference` key to disambiguate.");
        }
        this.store.set(id, page);
    }
    /** Returns a JS object mapping page IDs to data. */
    toObject() {
        const object = {};
        for (const [key, val] of this.store.entries()) {
            object[key] = val;
        }
        return object;
    }
    toTree(id, depth = 0) {
        const page = this.get(id);
        if (page === undefined) {
            throw new Error(`Unknown @page '${id}' in toTree()`);
        }
        const pageNode = initPageNode(page, depth);
        page.contents.forEach((node) => {
            // we only care about @page and @##+ tag nodes
            if (client_1.isTag(node, "page")) {
                pageNode.children.push(this.toTree(node.value, depth + 1));
            }
            else if (client_1.isHeadingTag(node) && node.level > 1) {
                // skipping h1 headings cuz they become the page title itself.
                pageNode.children.push(initHeadingNode(node.value, pageNode.level + node.level - 1));
            }
        });
        return pageNode;
    }
}
exports.PageMap = PageMap;
function initPageNode({ reference, title }, level = 0) {
    // NOTE: `route` may be overwritten in MarkdownPlugin based on nesting.
    return { children: [], level, reference, route: reference, title };
}
function initHeadingNode(title, level) {
    // NOTE: `route` will be added in MarkdownPlugin.
    return { title, level };
}
