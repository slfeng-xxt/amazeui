"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
const path = require("path");
const ts = require("typescript");
class Documentation {
    constructor(program, options = {}) {
        this.serializeDeclaration = (symbol, fileName) => {
            const details = this.serializeSymbol(symbol, fileName);
            details.optional = (symbol.flags & ts.SymbolFlags.Optional) !== 0;
            return details;
        };
        this.filterValueDeclaration = (sym) => sym.valueDeclaration != null;
        this.filterEntry = (entry) => {
            const { excludeNames, excludePaths } = this.options;
            return testNoMatches(entry.name, excludeNames) && testNoMatches(entry.fileName, excludePaths);
        };
        this.program = program;
        this.options = __assign({ includeBasicTypeProperties: false, includeDefinitionFiles: false }, options);
    }
    static fromProgram(program, options) {
        return new Documentation(program, options).extract();
    }
    static fromFiles(filePaths, compilerOptions, options) {
        if (!Array.isArray(filePaths)) {
            throw new Error(`expected array of file paths, received ${typeof filePaths}`);
        }
        return Documentation.fromProgram(ts.createProgram(filePaths, compilerOptions), options);
    }
    get checker() { return this.program.getTypeChecker(); }
    extract() {
        const output = [];
        const visit = (node) => {
            if (node.kind === ts.SyntaxKind.InterfaceDeclaration) {
                const symbol = this.checker.getSymbolAtLocation(node.name);
                output.push(this.serializeInterface(symbol, this.getFileName(node)));
            }
            else if (node.kind === ts.SyntaxKind.VariableStatement) {
                const list = node.declarationList.declarations.map((decl) => {
                    const symbol = this.checker.getSymbolAtLocation(decl.name);
                    return this.serializeVariable(symbol, this.getFileName(node));
                });
                output.push(...list);
            }
            else if (node.kind === ts.SyntaxKind.ModuleDeclaration) {
                ts.forEachChild(node, visit);
            }
        };
        for (const sourceFile of this.program.getSourceFiles()) {
            if (!this.options.includeDefinitionFiles && /\.d\.ts$/.test(sourceFile.fileName)) {
                continue;
            }
            ts.forEachChild(sourceFile, visit);
        }
        return output.filter(this.filterEntry);
    }
    getFileName(node) {
        return path.relative(process.cwd(), node.getSourceFile().fileName);
    }
    getJsDocTags(symbol) {
        return symbol.getJsDocTags().reduce((tags, { name, text }) => {
            tags[name] = text.length > 0 ? text : true;
            return tags;
        }, {});
    }
    getTypeOfSymbol(symbol) {
        return this.checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
    }
    getTypeString(symbol) {
        return this.checker.typeToString(this.getTypeOfSymbol(symbol), null, ts.TypeFormatFlags.UseFullyQualifiedType);
    }
    serializeSymbol(symbol, fileName) {
        return {
            documentation: ts.displayPartsToString(symbol.getDocumentationComment()),
            fileName,
            name: symbol.getName(),
            tags: this.getJsDocTags(symbol),
            type: this.getTypeString(symbol),
        };
    }
    serializeInterface(symbol, fileName) {
        const details = {
            documentation: ts.displayPartsToString(symbol.getDocumentationComment()),
            fileName,
            name: symbol.getName(),
            tags: this.getJsDocTags(symbol),
            type: "interface",
        };
        const interfaceNode = symbol.declarations[0];
        if (interfaceNode.heritageClauses != null) {
            details.extends = interfaceNode.heritageClauses[0].types.map((type) => type.getText());
        }
        details.properties = Object.keys(symbol.members).sort().map((name) => symbol.members[name])
            .filter(this.filterValueDeclaration)
            .map((sym) => this.serializeDeclaration(sym, fileName))
            .filter(this.filterEntry);
        return details;
    }
    serializeVariable(symbol, fileName) {
        const details = this.serializeSymbol(symbol, fileName);
        details.fileName = fileName;
        if (this.options.includeBasicTypeProperties || !isBasicType(details.type)) {
            details.properties = this.getTypeOfSymbol(symbol).getProperties()
                .filter(this.filterValueDeclaration)
                .map((s) => this.serializeSymbol(s, fileName));
        }
        else {
            details.properties = [];
        }
        return details;
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Documentation;
function testNoMatches(value, patterns = []) {
    return patterns.every((pattern) => value.match(pattern) == null);
}
function isBasicType(type) {
    return /(boolean|number|string|RegExp)(\[\])?$/.test(type) || /^("|\d)/.test(type);
}
